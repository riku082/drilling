<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>地熱井戸掘削ゲーム</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #8B4513 20%, #654321 40%, #3E2723 60%, #D2691E 80%, #FF4500 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1200px, 95vw);
            height: min(800px, 85vh);
            max-width: 100%;
            max-height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: min(20px, 2vw);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: min(15px, 2vw);
            border-radius: min(10px, 1.5vw);
            border: 2px solid #FF4500;
            font-size: min(14px, 3vw);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #stats {
            top: min(20px, 2vh);
            left: min(20px, 2vw);
            min-width: min(200px, 40vw);
        }

        /* スマホ専用のステータス表示調整 */
        @media (max-width: 480px) {
            #stats {
                top: 5px !important;
                left: 5px !important;
                transform: scale(0.6) !important;
                max-width: 150px !important;
                font-size: 10px !important;
            }

            .info-panel {
                padding: 8px !important;
                font-size: 10px !important;
            }
        }

        #controls {
            top: 20px;
            right: 20px;
            pointer-events: all;
        }

        /* スマホ版対応 */
        @media (max-width: 768px) {
            #brazilDistanceButton {
                position: absolute !important;
                top: 10px !important;
                right: 10px !important;
                z-index: 1000;
            }
            
            #brazilDistanceButton button {
                padding: 8px 12px !important;
                font-size: 12px !important;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            #startScreen h1 {
                margin-top: 60px !important;
                font-size: 36px !important;
            }

            .instructions {
                font-size: 14px !important;
                margin: 15px 10px !important;
                line-height: 1.4 !important;
            }

            #startScreen button {
                font-size: 16px !important;
                padding: 12px 24px !important;
                margin: 8px !important;
            }

            #titleRanking {
                max-width: 90% !important;
                margin: 15px auto !important;
                padding: 15px !important;
            }

            #titleRanking h3 {
                font-size: 20px !important;
            }

            .title-record-item {
                font-size: 14px !important;
                padding: 10px !important;
            }
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #FF4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }

        /* スマホ版ゲームオーバー調整 */
        @media (max-width: 768px) {
            #gameOver {
                max-width: 95% !important;
                max-height: 90% !important;
                padding: 20px !important;
                font-size: 14px !important;
            }

            #gameOver h2 {
                font-size: 24px !important;
                margin: 10px 0 !important;
            }

            #gameOver h3 {
                font-size: 18px !important;
                margin: 8px 0 !important;
            }

            #gameOver p {
                font-size: 13px !important;
                margin: 5px 0 !important;
            }

            #gameOver button {
                font-size: 14px !important;
                padding: 10px 16px !important;
                margin: 5px !important;
            }

            #playerNameInput {
                width: 90% !important;
                font-size: 14px !important;
                padding: 8px !important;
                margin: 8px 0 !important;
            }

            .record-item {
                font-size: 12px !important;
                padding: 8px !important;
                margin: 4px 0 !important;
            }
        }
        
        #playerNameInput {
            padding: 8px;
            margin: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            color: black;
        }
        
        #recordsList {
            margin-top: 20px;
            text-align: left;
        }
        
        .record-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .record-rank {
            font-weight: bold;
            color: #FFD700;
        }
        
        .record-info {
            flex: 1;
            margin-left: 10px;
        }
        
        .record-score {
            font-weight: bold;
            color: #FF4500;
        }

        button {
            background: #FF4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            background: #FF6347;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        .stat-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
        }

        .energy-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #FFD700;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #FF4500, #FFD700);
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        h1, h2 {
            margin: 10px 0;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        .upgrade-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #228B22;
            margin-top: 5px;
        }

        .upgrade-btn:hover {
            background: #32CD32;
        }

        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 1000;
        }

        #startScreen h1 {
            font-size: 48px;
            color: #FF4500;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .instructions {
            margin: 20px 0;
            font-size: 18px;
            line-height: 1.5;
        }
        
        #titleRanking {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FF4500;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-width: 600px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #titleRanking h3 {
            color: #FFD700;
            margin-top: 0;
            font-size: 24px;
        }
        
        .title-record-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
            padding: 12px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
        }
        
        .title-record-rank {
            font-weight: bold;
            color: #FFD700;
            min-width: 40px;
        }
        
        .title-record-info {
            flex: 1;
            margin-left: 10px;
            text-align: left;
        }
        
        .title-record-depth {
            font-weight: bold;
            color: #FF4500;
            font-size: 18px;
        }
        
        #brazilDistancePage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000428 0%, #004e92 100%);
            overflow: hidden;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 1200px) {
            #brazilDistancePage .flex-container {
                flex-direction: column !important;
                gap: 20px !important;
            }
            
            #brazilDistancePage .earth-container {
                flex: none !important;
                margin-bottom: 20px;
            }
            
            #brazilDistancePage canvas {
                width: 350px !important;
                height: 350px !important;
            }
        }
        
        @media (max-width: 768px) {
            #brazilDistancePage canvas {
                width: 300px !important;
                height: 300px !important;
            }
        }

        .warning {
            color: #FF6347;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* モバイル用タッチコントロール */
        #mobileControls {
            position: absolute;
            bottom: min(20px, 2vh);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: min(15px, 2.5vw);
            z-index: 1000;
        }

        /* デスクトップでは非表示 */
        @media (min-width: 769px) and (min-height: 601px) {
            #mobileControls {
                display: none !important;
            }
        }

        .touch-button {
            width: min(70px, 14vw);
            height: min(70px, 14vw);
            background: rgba(255, 69, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-size: min(20px, 4vw);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            touch-action: manipulation;
        }

        #spaceButton {
            background: rgba(135, 206, 235, 0.8);
            border-color: #87CEEB;
        }

        #spaceButton:active {
            background: rgba(135, 206, 235, 1);
            transform: scale(0.95);
        }

        .touch-button:active {
            background: rgba(255, 69, 0, 1);
            transform: scale(0.95);
        }

        @media (max-width: 768px) or (max-height: 600px) {
            #mobileControls {
                display: flex !important;
            }
            
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
            }
            
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
            }
            
            #gameCanvas {
                width: 100% !important;
                height: 100% !important;
                object-fit: contain;
            }
            
            .info-panel {
                font-size: max(10px, 2.2vw);
                padding: max(6px, 1.2vw);
                min-width: max(150px, 30vw);
                border-radius: max(5px, 1vw);
            }
            
            #stats {
                top: max(5px, 0.5vh);
                left: max(5px, 1vw);
                transform: scale(0.7);
                transform-origin: top left;
                max-width: min(180px, 35vw);
            }
            
            #mobileControls {
                bottom: max(10px, 1vh);
                gap: max(15px, 2vw);
            }
            
            .touch-button {
                width: max(60px, 12vw);
                height: max(60px, 12vw);
                font-size: max(18px, 3.5vw);
                border-width: 2px;
            }
            
            /* 縦向きスマホ用 */
            @media (orientation: portrait) {
                #gameContainer {
                    height: 100vh;
                }
                
                .info-panel {
                    font-size: max(11px, 2.8vw);
                }
                
                .touch-button {
                    width: max(70px, 14vw);
                    height: max(70px, 14vw);
                }
            }
            
            /* 横向きスマホ用 */
            @media (orientation: landscape) {
                #gameContainer {
                    width: 100vw;
                    height: 100vh;
                }
                
                .info-panel {
                    font-size: max(9px, 2vh);
                    padding: max(5px, 1vh);
                }
                
                #stats {
                    transform: scale(0.65);
                    max-width: min(160px, 32vw);
                }

                #gameOver {
                    max-width: 98% !important;
                    max-height: 95% !important;
                    padding: 15px !important;
                    font-size: 12px !important;
                }

                #gameOver h2 {
                    font-size: 20px !important;
                }

                #gameOver h3 {
                    font-size: 16px !important;
                }

                #gameOver button {
                    font-size: 12px !important;
                    padding: 8px 12px !important;
                    margin: 3px !important;
                }

                #playerNameInput {
                    font-size: 12px !important;
                    padding: 6px !important;
                }
                
                .touch-button {
                    width: max(50px, 8vh);
                    height: max(50px, 8vh);
                    font-size: max(16px, 3vh);
                }
                
                #mobileControls {
                    bottom: max(5px, 1vh);
                }
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="1000"></canvas>
        <div id="ui">
            <div id="stats" class="info-panel">
                <h2>掘削状況</h2>
                <div>深度: <span class="stat-value" id="depth">0</span> m</div>
                <div>温度: <span class="stat-value" id="temperature">15</span> ℃</div>
                <div>掘削速度: <span class="stat-value" id="drillSpeed">2.5</span> m/s</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="drillEnergy"></div>
                </div>
                <div style="font-size: 12px;">ドリル耐久度</div>
                
                <div style="margin-top: 10px; font-size: 14px;">💰 オイルマネー: <span class="stat-value" id="oilMoneyCount">0</span></div>
                <div style="margin-top: 5px; font-size: 12px; color: #FFD700;">🔥 コンボ: <span class="stat-value" id="comboCount">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #87CEEB;">
                    <div>🌍 総掘削距離: <span class="stat-value" id="totalDistance">0</span> m</div>
                    <div>📊 今回のプレイ: <span class="stat-value" id="currentPlayDistance">0</span> m</div>
                </div>
                <div class="energy-bar" style="margin-top: 10px;">
                    <div class="energy-fill" id="beamEnergy"></div>
                </div>
                <div style="font-size: 12px;">泥水ビーム <span id="beamStatus">オイルマネーを集めよう！</span></div>
                <div id="warningText" class="warning" style="display: none;">⚠️ 高温注意！</div>
            </div>
            
            <!-- 音声コントロール -->
            <div id="audioControls" style="position: absolute; top: 20px; right: 20px; pointer-events: all;">
                <button id="muteButton" style="font-size: 12px; padding: 5px 10px; background: rgba(0,0,0,0.7); color: white; border: 1px solid #FF4500;">🔊 音声ON</button>
            </div>
        </div>
        
        <div id="startScreen">
            <!-- ブラジルまでの距離ボタン -->
            <div id="brazilDistanceButton" style="position: absolute; top: 20px; right: 20px; z-index: 1000;">
                <button onclick="showBrazilDistance()" style="background: #228B22; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">
                    🌍 ブラジルまでの距離
                </button>
            </div>
            
            <h1>🔥 地熱井戸掘削ゲーム 🔥</h1>
            <div class="instructions">
                <p>自動で地球の深部へ掘り進みます！</p>
                <p>← → キーで掘削機を左右に移動して障害物を避けよう</p>
                <p>岩にぶつかるとドリルが消耗します</p>
                <p>🛢️ オイルポケットでドリル耐久度が回復！</p>
                <p>💧 泥水ビームゲージが溜まったらスペースキーで障害物を破壊！</p>
                <p>より深く掘るほど高温になり、多くのエネルギーを獲得できます</p>
            </div>
            <button onclick="startGame()">ゲームスタート</button>
            <button onclick="showTitleRanking()">ランキング</button>
            
            <!-- タイトル画面のランキング表示 -->
            <div id="titleRanking" style="display: none;">
                <h3>🏆 深度ランキング TOP5</h3>
                <div id="titleRankingList"></div>
                <div id="titleTotalDistance" style="margin-top: 15px;"></div>
                <button onclick="hideTitleRanking()">閉じる</button>
            </div>
        </div>
        
        <div id="gameOver">
            <!-- トップボタン -->
            <div id="topButtons" style="margin-bottom: 20px;">
                <button onclick="resetGame()" style="margin-right: 10px;">🔄 もう一度プレイ</button>
                <button onclick="backToTitle()">🏠 タイトルに戻る</button>
            </div>
            
            <h2>ゲームオーバー</h2>
            <p>最終深度: <span id="finalDepth">0</span> m</p>
            <p>最高温度: <span id="maxTemp">0</span> ℃</p>
            <div id="playerNameSection">
                <input type="text" id="playerNameInput" placeholder="プレイヤー名を入力" maxlength="20">
                <button onclick="updatePlayerName()">名前を設定</button>
            </div>
            <div id="recordsSection">
                <button onclick="showRecords()">ランキングを見る</button>
                <div id="recordsList" style="display: none;">
                    <h3>トップ10</h3>
                    <div id="topRecords"></div>
                    <h3>あなたの記録</h3>
                    <div id="playerRecords"></div>
                </div>
            </div>
        </div>
        
        <!-- ブラジルまでの距離ページ -->
        <div id="brazilDistancePage" style="display: none;">
            <!-- ヘッダー -->
            <div style="position: absolute; top: 20px; left: 20px; z-index: 1002;">
                <button onclick="hideBrazilDistance()" style="background: #FF4500; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                    ← 戻る
                </button>
            </div>
            
            <div style="text-align: center; padding: 20px 0 10px 0; color: white;">
                <h1 style="color: #FF4500; margin: 0; font-size: 28px;">🌍 秋田県からブラジルまでの旅</h1>
            </div>
            
            <!-- メインコンテンツ（2列レイアウト） -->
            <div class="flex-container" style="display: flex; flex: 1; padding: 0 30px 30px 30px; gap: 30px; max-height: calc(100vh - 80px);">
                <!-- 左側：目標情報と地球のグラフィック -->
                <div class="earth-container" style="flex: 1.2; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <!-- 目標情報 -->
                    <div style="background: rgba(0, 0, 0, 0.8); padding: 16px; border-radius: 15px; margin-bottom: 20px; width: 100%; max-width: 450px;">
                        <h3 style="color: #FFD700; margin-top: 0; margin-bottom: 10px; font-size: 18px; text-align: center;">🎯 目標</h3>
                        <p style="font-size: 14px; margin: 0 0 12px 0; text-align: center;">秋田県からブラジル（ブラジリア）まで: <span style="color: #FF4500; font-weight: bold;">18,000 km</span></p>
                        
                        <h3 style="color: #87CEEB; margin: 12px 0 10px 0; font-size: 18px; text-align: center;">📍 現在の進捗</h3>
                        <div style="background: #333; padding: 12px; border-radius: 8px; margin: 10px 0;">
                            <div style="font-size: 18px; color: #FFD700; margin-bottom: 6px; text-align: center;">
                                掘削済み: <span id="currentDistance">0</span> km
                            </div>
                            <div style="font-size: 14px; color: #87CEEB; text-align: center;">
                                残り: <span id="remainingDistance">18,000</span> km
                            </div>
                            <div style="font-size: 14px; color: #90EE90; margin-top: 6px; text-align: center;">
                                達成率: <span id="progressPercentage">0</span>%
                            </div>
                        </div>
                        
                        <!-- プログレスバー -->
                        <div style="background: #333; height: 16px; border-radius: 8px; margin: 10px 0; overflow: hidden;">
                            <div id="progressBar" style="background: linear-gradient(to right, #FF4500, #FFD700); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                    
                    <!-- 地球のグラフィック -->
                    <div id="earthContainer" style="position: relative; display: inline-block;">
                        <canvas id="earthCanvas" width="450" height="450" style="border: 2px solid #FF4500; border-radius: 50%; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);"></canvas>
                        <div id="progressIndicator" style="position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%); font-size: 24px;">🚀</div>
                    </div>
                </div>
                
                <!-- 右側：ランキング表示 -->
                <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                    <!-- ランキング表示 -->
                    <div id="brazilPageRanking" style="background: rgba(0, 0, 0, 0.8); padding: 25px; border-radius: 15px; flex: 1; min-height: 0; display: flex; flex-direction: column;">
                        <h3 style="color: #FFD700; margin: 0 0 20px 0; font-size: 24px; flex-shrink: 0; text-align: center;">🏆 深度ランキング TOP5</h3>
                        <div id="brazilRankingList" style="flex: 1; overflow-y: auto; min-height: 0;">
                            <p>読み込み中...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- モバイル用タッチコントロール -->
        <div id="mobileControls">
            <div class="touch-button" id="leftButton">←</div>
            <div class="touch-button" id="spaceButton">💧</div>
            <div class="touch-button" id="rightButton">→</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // PDCビット画像の読み込み
        const drillBitImage = new Image();
        drillBitImage.src = 'Gemini_Generated_Image_sfxgpisfxgpisfxg.png';
        let imageLoaded = false;
        drillBitImage.onload = function() {
            imageLoaded = true;
        };
        
        // オーディオシステム
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.masterVolume = 0.5;
                this.sfxVolume = 0.7;
                this.musicVolume = 0.3;
                this.muted = false;
                this.sounds = {};
                this.musicLoop = null;
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.warn('Web Audio API not supported:', e);
                }
            }
            
            createSounds() {
                // 掘削音（低い連続音）
                this.sounds.drilling = this.createDrillingSound();
                // 岩石破壊音
                this.sounds.rockBreak = this.createRockBreakSound();
                // オイルマネー獲得音
                this.sounds.oilMoney = this.createOilMoneySound();
                // スター状態開始音
                this.sounds.starMode = this.createStarModeSound();
                // ビーム発射音
                this.sounds.beam = this.createBeamSound();
                // 衝突音
                this.sounds.collision = this.createCollisionSound();
                // 警告音
                this.sounds.warning = this.createWarningSound();
            }
            
            createOscillator(frequency, type = 'sine') {
                if (!this.audioContext) return null;
                const oscillator = this.audioContext.createOscillator();
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                return oscillator;
            }
            
            createGain(volume = 1) {
                if (!this.audioContext) return null;
                const gain = this.audioContext.createGain();
                gain.gain.value = volume * this.masterVolume * (this.muted ? 0 : 1);
                return gain;
            }
            
            createDrillingSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    // 深度に応じた音の変化
                    let baseFreq = 80 + Math.random() * 20;
                    let filterFreq = 200;
                    let volume = 0.3;
                    
                    if (game.depth > 3000) {
                        baseFreq += 20; // 深部では高い音
                        filterFreq += 100;
                        volume = 0.4; // 音量も上がる
                    }
                    if (game.depth > 5000) {
                        baseFreq += 30; // 極深部ではさらに高い音
                        filterFreq += 150;
                        volume = 0.5;
                    }
                    
                    // メイン掘削音
                    const osc = this.createOscillator(baseFreq, 'sawtooth');
                    const gain = this.createGain(volume * this.sfxVolume);
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = filterFreq;
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.12);
                    osc.stop(this.audioContext.currentTime + 0.12);
                    
                    // 追加の金属音（確率的に）
                    if (Math.random() < 0.3) {
                        const metalOsc = this.createOscillator(baseFreq * 3, 'square');
                        const metalGain = this.createGain(0.1 * this.sfxVolume);
                        const metalFilter = this.audioContext.createBiquadFilter();
                        metalFilter.type = 'highpass';
                        metalFilter.frequency.value = 800;
                        
                        metalOsc.connect(metalFilter);
                        metalFilter.connect(metalGain);
                        metalGain.connect(this.audioContext.destination);
                        
                        metalOsc.start();
                        metalGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                        metalOsc.stop(this.audioContext.currentTime + 0.05);
                    }
                };
            }
            
            createRockBreakSound() {
                return () => {
                    if (!this.audioContext) return;
                    const noise = this.audioContext.createBufferSource();
                    const buffer = this.audioContext.createBuffer(1, 4410, 44100);
                    const data = buffer.getChannelData(0);
                    
                    for (let i = 0; i < 4410; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    noise.buffer = buffer;
                    const gain = this.createGain(0.4 * this.sfxVolume);
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 800;
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    noise.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                };
            }
            
            createOilMoneySound() {
                return () => {
                    if (!this.audioContext) return;
                    const notes = [523.25, 659.25, 783.99, 1046.5]; // C5, E5, G5, C6
                    
                    notes.forEach((freq, i) => {
                        const osc = this.createOscillator(freq, 'sine');
                        const gain = this.createGain(0.3 * this.sfxVolume);
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        const startTime = this.audioContext.currentTime + i * 0.1;
                        osc.start(startTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                        osc.stop(startTime + 0.2);
                    });
                };
            }
            
            createStarModeSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc1 = this.createOscillator(440, 'sine');
                    const osc2 = this.createOscillator(880, 'sine');
                    const gain = this.createGain(0.5 * this.sfxVolume);
                    
                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc1.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.5);
                    osc2.frequency.exponentialRampToValueAtTime(1760, this.audioContext.currentTime + 0.5);
                    
                    osc1.start();
                    osc2.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                    osc1.stop(this.audioContext.currentTime + 0.8);
                    osc2.stop(this.audioContext.currentTime + 0.8);
                };
            }
            
            createBeamSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc = this.createOscillator(150, 'sawtooth');
                    const gain = this.createGain(0.4 * this.sfxVolume);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.3);
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    osc.stop(this.audioContext.currentTime + 0.3);
                };
            }
            
            createCollisionSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc = this.createOscillator(200 + Math.random() * 100, 'square');
                    const gain = this.createGain(0.3 * this.sfxVolume);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                    osc.stop(this.audioContext.currentTime + 0.05);
                };
            }
            
            createWarningSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc = this.createOscillator(800, 'sine');
                    const gain = this.createGain(0.3 * this.sfxVolume);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    osc.stop(this.audioContext.currentTime + 0.2);
                };
            }
            
            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }
            
            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
            }
            
            toggleMute() {
                this.muted = !this.muted;
            }
            
            startBackgroundMusic() {
                if (!this.audioContext || this.musicLoop) return;
                
                // 音楽の設定（明るくアップテンポに）
                const tempo = 140; // BPM（120→140に高速化）
                const beatDuration = 60 / tempo; // 1拍の長さ（秒）
                
                // キー: C major（明るいキー）
                const scale = {
                    // C - Am - F - G のコード進行（明るい進行）
                    chords: [
                        [261.63, 329.63, 392.00], // C major (C4, E4, G4)
                        [220.00, 261.63, 329.63], // A minor (A3, C4, E4)
                        [174.61, 220.00, 261.63], // F major (F3, A3, C4)
                        [196.00, 246.94, 293.66]  // G major (G3, B3, D4)
                    ],
                    melody: [
                        [523.25, 659.25, 783.99, 523.25], // 小節1: C5, E5, G5, C5（明るい上昇）
                        [440.00, 523.25, 659.25, 440.00], // 小節2: A4, C5, E5, A4（跳躍）
                        [349.23, 440.00, 523.25, 349.23], // 小節3: F4, A4, C5, F4（安定）
                        [392.00, 493.88, 587.33, 392.00]  // 小節4: G4, B4, D5, G4（解決）
                    ]
                };
                
                let currentMeasure = 0;
                let currentBeat = 0;
                
                const playMusicLoop = () => {
                    if (this.muted) {
                        setTimeout(playMusicLoop, beatDuration * 1000);
                        return;
                    }
                    
                    const currentTime = this.audioContext.currentTime;
                    
                    // ベースライン（明るい低音）
                    const bassFreq = scale.chords[currentMeasure][0];
                    const bassOsc = this.createOscillator(bassFreq * 0.5, 'triangle'); // より暖かい音色
                    const bassGain = this.createGain(0.18 * this.musicVolume); // 少し大きく
                    
                    bassOsc.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    
                    bassOsc.start(currentTime);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 2);
                    bassOsc.stop(currentTime + beatDuration * 2);
                    
                    // コード（和音）- より明るく
                    scale.chords[currentMeasure].forEach((freq, i) => {
                        const chordOsc = this.createOscillator(freq, 'sine'); // 柔らかい音色
                        const chordGain = this.createGain(0.12 * this.musicVolume); // 少し大きく
                        
                        chordOsc.connect(chordGain);
                        chordGain.connect(this.audioContext.destination);
                        
                        chordOsc.start(currentTime + i * 0.01);
                        chordGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 2);
                        chordOsc.stop(currentTime + beatDuration * 2);
                    });
                    
                    // メロディー（1拍ごと）- より明るく目立つ
                    const melodyFreq = scale.melody[currentMeasure][currentBeat];
                    const melodyOsc = this.createOscillator(melodyFreq, 'triangle'); // 温かい音色
                    const melodyGain = this.createGain(0.2 * this.musicVolume); // 大きく
                    
                    melodyOsc.connect(melodyGain);
                    melodyGain.connect(this.audioContext.destination);
                    
                    melodyOsc.start(currentTime);
                    melodyGain.gain.setValueAtTime(0.2 * this.musicVolume, currentTime);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 0.8);
                    melodyOsc.stop(currentTime + beatDuration);
                    
                    // ハーモニー（2拍ごと）- 豊かな響き
                    if (currentBeat % 2 === 0) {
                        const harmonyFreq = melodyFreq * 0.75; // 5度下
                        const harmonyOsc = this.createOscillator(harmonyFreq, 'sine');
                        const harmonyGain = this.createGain(0.1 * this.musicVolume);
                        
                        harmonyOsc.connect(harmonyGain);
                        harmonyGain.connect(this.audioContext.destination);
                        
                        harmonyOsc.start(currentTime);
                        harmonyGain.gain.setValueAtTime(0.1 * this.musicVolume, currentTime);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 0.6);
                        harmonyOsc.stop(currentTime + beatDuration);
                    }
                    
                    // リズム更新
                    currentBeat++;
                    if (currentBeat >= 4) {
                        currentBeat = 0;
                        currentMeasure = (currentMeasure + 1) % 4;
                    }
                    
                    setTimeout(playMusicLoop, beatDuration * 1000);
                };
                
                playMusicLoop();
                this.musicLoop = true;
            }
            
            startStarModeBGM() {
                if (!this.audioContext || this.muted) return;
                
                // マリオのスター状態BGM（正確な再現）
                const tempo = 300; // 非常に高速
                const sixteenthNote = (60 / tempo) / 4; // 16分音符の長さ
                
                // マリオのスター状態の実際のメロディーパターン
                // C major scale での上昇・下降アルペジオ
                const starArpeggio = [
                    523.25, 659.25, 783.99, 1046.5, 1318.5, 1568.0, 1318.5, 1046.5, // 上昇・下降
                    659.25, 783.99, 1046.5, 1318.5, 1568.0, 1318.5, 1046.5, 783.99,  // 変化
                    523.25, 659.25, 783.99, 1046.5, 1318.5, 1568.0, 1318.5, 1046.5, // 繰り返し
                    783.99, 659.25, 523.25, 659.25, 783.99, 1046.5, 1318.5, 1568.0   // 終了
                ];
                
                // ベースライン（シンプルなルート音）
                const bassPattern = [
                    261.63, 261.63, 261.63, 261.63, 329.63, 329.63, 329.63, 329.63,
                    392.00, 392.00, 392.00, 392.00, 261.63, 261.63, 261.63, 261.63,
                    261.63, 261.63, 261.63, 261.63, 329.63, 329.63, 329.63, 329.63,
                    392.00, 392.00, 392.00, 392.00, 261.63, 261.63, 261.63, 261.63
                ];
                
                let noteIndex = 0;
                
                const playStarMusic = () => {
                    if (!game.starMode) return;
                    
                    const currentTime = this.audioContext.currentTime;
                    
                    // メイン・メロディー（高速アルペジオ）
                    const melodyFreq = starArpeggio[noteIndex];
                    const melodyOsc = this.createOscillator(melodyFreq, 'square');
                    const melodyGain = this.createGain(0.35 * this.musicVolume);
                    
                    // エンベロープ（短くクリアな音）
                    melodyOsc.connect(melodyGain);
                    melodyGain.connect(this.audioContext.destination);
                    
                    melodyOsc.start(currentTime);
                    melodyGain.gain.setValueAtTime(0.35 * this.musicVolume, currentTime);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 0.8);
                    melodyOsc.stop(currentTime + sixteenthNote);
                    
                    // ベースライン（2拍ごと）
                    if (noteIndex % 2 === 0) {
                        const bassFreq = bassPattern[noteIndex];
                        const bassOsc = this.createOscillator(bassFreq, 'triangle');
                        const bassGain = this.createGain(0.25 * this.musicVolume);
                        
                        bassOsc.connect(bassGain);
                        bassGain.connect(this.audioContext.destination);
                        
                        bassOsc.start(currentTime);
                        bassGain.gain.setValueAtTime(0.25 * this.musicVolume, currentTime);
                        bassGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 1.5);
                        bassOsc.stop(currentTime + sixteenthNote * 2);
                    }
                    
                    // ハーモニー（4拍ごと）
                    if (noteIndex % 4 === 0) {
                        const harmonyFreq = melodyFreq * 0.75; // 5度下
                        const harmonyOsc = this.createOscillator(harmonyFreq, 'square');
                        const harmonyGain = this.createGain(0.15 * this.musicVolume);
                        
                        harmonyOsc.connect(harmonyGain);
                        harmonyGain.connect(this.audioContext.destination);
                        
                        harmonyOsc.start(currentTime);
                        harmonyGain.gain.setValueAtTime(0.15 * this.musicVolume, currentTime);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 0.6);
                        harmonyOsc.stop(currentTime + sixteenthNote);
                    }
                    
                    // パーカッション（8拍ごと）
                    if (noteIndex % 8 === 0) {
                        const kickOsc = this.createOscillator(80, 'sine');
                        const kickGain = this.createGain(0.4 * this.musicVolume);
                        
                        kickOsc.connect(kickGain);
                        kickGain.connect(this.audioContext.destination);
                        
                        kickOsc.start(currentTime);
                        kickGain.gain.setValueAtTime(0.4 * this.musicVolume, currentTime);
                        kickGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 2);
                        kickOsc.stop(currentTime + sixteenthNote * 2);
                    }
                    
                    // 次の音符へ
                    noteIndex = (noteIndex + 1) % starArpeggio.length;
                    
                    setTimeout(playStarMusic, sixteenthNote * 1000);
                };
                
                playStarMusic();
            }
            
            stopBackgroundMusic() {
                this.musicLoop = false;
            }
            
            stopStarModeBGM() {
                // スター状態のBGMを停止するためのフラグ
                // 実際の停止は各ゲームオブジェクトのstarMode状態で制御される
            }
        }
        
        // グローバルオーディオマネージャー
        const audioManager = new AudioManager();
        
        // レスポンシブ対応
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            const isMobile = window.innerWidth <= 768 || window.innerHeight <= 600;
            
            if (isMobile) {
                // モバイルでは画面全体を使用
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.transform = 'none';
                canvas.style.objectFit = 'contain';
            } else {
                // デスクトップでは適切にスケーリング
                const scaleX = containerRect.width / 1200;
                const scaleY = containerRect.height / 1000;
                const scale = Math.min(scaleX, scaleY);
                
                canvas.style.transform = `scale(${scale})`;
                canvas.style.transformOrigin = 'top left';
                canvas.style.width = '1200px';
                canvas.style.height = '1000px';
                canvas.style.objectFit = 'initial';
            }
            
            // ゲーム内座標も調整
            if (game.drillX === 600) { // 初期位置の場合
                game.drillX = 1200 * 0.5; // 画面中央
            }
        }
        
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeGame, 100);
        });
        
        // Firebase設定
        const firebaseConfig = {
            apiKey: "AIzaSyC_HcHZGly2GijG7Y07oSZSjrxP3CUCMRA",
            authDomain: "abab-3k6tdx.firebaseapp.com",
            projectId: "abab-3k6tdx",
            storageBucket: "abab-3k6tdx.firebasestorage.app",
            messagingSenderId: "5046366384",
            appId: "1:5046366384:web:2ef45b11dfc7add6250b75"
        };
        
        // Firebase初期化
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // ゲーム記録管理クラス
        class GameRecordManager {
            constructor() {
                this.playerName = localStorage.getItem('playerName') || 'Player';
                this.collection = db.collection('gameRecords');
                this.statsCollection = db.collection('gameStats');
            }
            
            async saveRecord(record) {
                try {
                    const docRef = await this.collection.add({
                        playerName: this.playerName,
                        depth: record.depth,
                        temperature: record.temperature,
                        oilMoneyStock: record.oilMoneyStock,
                        comboCount: record.comboCount,
                        score: record.score,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        gameVersion: '1.0.1'
                    });
                    
                    // 総掘削距離を更新
                    await this.updateTotalDistance(record.depth);
                    
                    console.log('記録を保存しました:', docRef.id);
                    return docRef.id;
                } catch (error) {
                    console.error('記録保存エラー:', error);
                    throw error;
                }
            }
            
            async getTopRecordsByDepth(limit = 5) {
                try {
                    const snapshot = await this.collection
                        .orderBy('depth', 'desc')
                        .limit(limit)
                        .get();
                    
                    const records = [];
                    snapshot.forEach(doc => {
                        records.push({
                            id: doc.id,
                            ...doc.data()
                        });
                    });
                    return records;
                } catch (error) {
                    console.error('記録取得エラー:', error);
                    throw error;
                }
            }
            
            async checkIfTopRecord(depth) {
                try {
                    const snapshot = await this.collection
                        .orderBy('depth', 'desc')
                        .limit(5)
                        .get();
                    
                    const records = [];
                    snapshot.forEach(doc => {
                        records.push(doc.data());
                    });
                    
                    // 5位未満の記録数の場合、または新記録が5位以上の場合
                    if (records.length < 5 || depth > records[4].depth) {
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('記録チェックエラー:', error);
                    return false;
                }
            }
            
            async updateTotalDistance(distance) {
                try {
                    const statsRef = this.statsCollection.doc('totalDistance');
                    await statsRef.set({
                        total: firebase.firestore.FieldValue.increment(distance),
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } catch (error) {
                    console.error('総距離更新エラー:', error);
                }
            }
            
            async getTotalDistance() {
                try {
                    const doc = await this.statsCollection.doc('totalDistance').get();
                    if (doc.exists) {
                        return doc.data().total || 0;
                    }
                    return 0;
                } catch (error) {
                    console.error('総距離取得エラー:', error);
                    return 0;
                }
            }
            
            setPlayerName(name) {
                this.playerName = name;
                localStorage.setItem('playerName', name);
            }
        }
        
        // 記録管理のインスタンス作成
        const recordManager = new GameRecordManager();
        
        let game = {
            depth: 0,
            temperature: 15,
            drillX: 600,
            drillY: 0,
            drillSpeed: 4.0, // 初期速度を4.0倍に増加
            drillDurability: 100,
            drillMaxDurability: 100,
            oilMoneyStock: 0, // オイルマネーストック数
            starMode: false, // スター状態フラグ
            starModeTimer: 0, // スター状態残り時間（秒）
            starModeDuration: 5, // スター状態継続時間（秒）
            lastBenchmarkDepth: 0, // 最後に表示したベンチマークの深度
            comboCount: 0, // コンボカウント
            comboTimer: 0, // コンボタイマー（秒）
            comboMaxTime: 3, // コンボの最大持続時間（秒）
            beams: [], // 発射中のビーム
            particles: [],
            rocks: [],
            steamVents: [],
            magmaPools: [],
            faults: [], // 断層
            oilPockets: [], // オイルポケット
            oilMoney: [], // オイルマネー
            moles: [], // もぐら
            pipeSegments: [], // ドリルパイプのセグメント
            maxDepth: 0,
            maxTemp: 15,
            gameRunning: false,
            cameraY: 0
        };
        
        const keys = {};
        
        class Beam {
            constructor(x, y, direction) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.direction = direction; // 角度（ラジアン）
                this.speed = 15; // ビーム速度
                this.width = 8; // ビーム幅
                this.length = 60; // ビーム長さ
                this.life = 1.0; // ビームの生存時間
                this.power = 50; // 破壊力
                this.particles = [];
                this.hasHit = false;
            }
            
            update() {
                // ビームの移動
                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;
                
                // 生存時間の減少
                this.life -= 0.02;
                
                // ビームパーティクルの生成
                if (Math.random() < 0.8) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.width,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 1,
                        size: Math.random() * 3 + 1
                    });
                }
                
                // パーティクル更新
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    p.size *= 0.95;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
                
                // 障害物との衝突チェック
                this.checkCollisions();
            }
            
            checkCollisions() {
                if (this.hasHit) return;
                
                // 岩との衝突
                for (let i = game.rocks.length - 1; i >= 0; i--) {
                    const rock = game.rocks[i];
                    if (!rock.hit && this.isCollidingWithRock(rock)) {
                        this.destroyRock(rock, i);
                        this.hasHit = true;
                        this.life = 0.3; // 短い残存時間
                        break;
                    }
                }
                
                // 断層との衝突
                for (let i = game.faults.length - 1; i >= 0; i--) {
                    const fault = game.faults[i];
                    if (this.isCollidingWithFault(fault)) {
                        this.destroyFault(fault, i);
                        this.hasHit = true;
                        this.life = 0.3;
                        break;
                    }
                }
                
                // もぐらとの衝突
                for (let i = game.moles.length - 1; i >= 0; i--) {
                    const mole = game.moles[i];
                    if (this.isCollidingWithMole(mole)) {
                        this.destroyMole(mole, i);
                        this.hasHit = true;
                        this.life = 0.3;
                        break;
                    }
                }
            }
            
            isCollidingWithRock(rock) {
                const distance = Math.sqrt(
                    Math.pow(this.x - rock.x, 2) + 
                    Math.pow(this.y - rock.y, 2)
                );
                return distance < (Math.max(rock.width, rock.height) / 2 + this.width);
            }
            
            isCollidingWithFault(fault) {
                return fault.checkCrackCollision(this.x, this.y, this.width * 2, this.width * 2);
            }
            
            isCollidingWithMole(mole) {
                const distance = Math.sqrt(
                    Math.pow(this.x - mole.x, 2) + 
                    Math.pow(this.y - mole.y, 2)
                );
                return distance < (Math.max(mole.width, mole.height) / 2 + this.width);
            }
            
            destroyRock(rock, index) {
                // 岩を配列から完全に削除
                game.rocks.splice(index, 1);
                
                // 破壊エフェクト
                for (let i = 0; i < 30; i++) {
                    game.particles.push(new Particle(
                        rock.x + (Math.random() - 0.5) * rock.width,
                        rock.y + (Math.random() - 0.5) * rock.height,
                        Math.random() < 0.6 ? 'rock' : 'spark'
                    ));
                }
                
                // 画面の揺れ効果
                canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                setTimeout(() => canvas.style.transform = '', 250);
                
                console.log(`岩石を破壊！残り岩石数: ${game.rocks.length}`);
            }
            
            destroyFault(fault, index) {
                // 断層を配列から完全に削除
                game.faults.splice(index, 1);
                
                // 断層破壊エフェクト
                for (let i = 0; i < 35; i++) {
                    game.particles.push(new Particle(
                        fault.startX + Math.random() * 100 - 50,
                        fault.y + Math.random() * 100 - 50,
                        Math.random() < 0.5 ? 'spark' : 'rock'
                    ));
                }
                
                // より強い画面揺れ
                canvas.style.transform = `translate(${Math.random() * 25 - 12.5}px, ${Math.random() * 25 - 12.5}px)`;
                setTimeout(() => canvas.style.transform = '', 300);
                
                console.log(`断層を破壊！残り断層数: ${game.faults.length}`);
            }
            
            destroyMole(mole, index) {
                // もぐらを配列から完全に削除
                game.moles.splice(index, 1);
                
                // もぐら破壊エフェクト（土のパーティクル）
                for (let i = 0; i < 20; i++) {
                    game.particles.push(new Particle(
                        mole.x + (Math.random() - 0.5) * mole.width,
                        mole.y + (Math.random() - 0.5) * mole.height,
                        'rock'
                    ));
                }
                
                console.log(`もぐらを除去！残りもぐら数: ${game.moles.length}`);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                const startScreenY = this.startY - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                
                // 泥水ビーム本体（茶色系のグラデーション）
                const beamGradient = ctx.createLinearGradient(
                    this.startX, startScreenY,
                    this.x, screenY
                );
                beamGradient.addColorStop(0, `rgba(139, 69, 19, ${this.life * 0.4})`); // 濃い茶色
                beamGradient.addColorStop(0.5, `rgba(160, 82, 45, ${this.life * 0.8})`); // 中間の茶色
                beamGradient.addColorStop(1, `rgba(210, 180, 140, ${this.life})`); // 明るい茶色
                
                ctx.strokeStyle = beamGradient;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#8B4513';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, startScreenY);
                ctx.lineTo(this.x, screenY);
                ctx.stroke();
                
                // 泥水ビームの中心線（水分を表現）
                ctx.strokeStyle = `rgba(135, 206, 235, ${this.life * 0.6})`; // 水色
                ctx.lineWidth = this.width * 0.2;
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#87CEEB';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, startScreenY);
                ctx.lineTo(this.x, screenY);
                ctx.stroke();
                
                // 泥水パーティクル（茶色と水色の混合）
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life * this.life;
                    // ランダムで泥か水のパーティクル
                    ctx.fillStyle = Math.random() < 0.7 ? '#8B4513' : '#87CEEB';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.type = type;

                if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 12; // 8 → 12に高速化
                    this.vy = (Math.random() * -15) - 8; // より高速な初期速度
                    this.size = Math.random() * 4 + 1;
                    this.gravity = 0.6; // 重力を強化
                } else {
                    this.vx = (Math.random() - 0.5) * 6; // 4 → 6に高速化
                    this.vy = Math.random() * -8 - 3; // より高速な初期速度
                    this.size = Math.random() * 5 + 2;
                    this.gravity = 0.5; // 重力を強化
                }
            }
            
            update() {
                this.x += this.vx * 1.5; // 移動速度を1.5倍に
                this.y += this.vy * 1.5; // 移動速度を1.5倍に
                this.vy += this.gravity;
                this.life -= 0.04; // ライフ減少を少し早く
                this.size *= 0.96; // サイズ減少を少し早く
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'rock') {
                    ctx.fillStyle = '#8B4513';
                } else if (this.type === 'steam') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                } else if (this.type === 'lava') {
                    ctx.fillStyle = '#FF4500';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF4500';
                } else if (this.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFD700';
                }
                
                const screenY = this.y - game.cameraY;
                ctx.beginPath();
                ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Rock {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 100 + 50;
                this.height = Math.random() * 60 + 30;
                this.hardness = Math.random() * 3 + 1;
                this.hit = false;
                this.points = [];
                // Generate irregular shape points
                const numPoints = Math.floor(Math.random() * 5) + 8; // 8-12 points
                const angleStep = (Math.PI * 2) / numPoints;
                for (let i = 0; i < numPoints; i++) {
                    const angle = i * angleStep;
                    const radius = (Math.random() * 0.3 + 0.7) * Math.min(this.width, this.height) / 2;
                    this.points.push({
                        x: radius * Math.cos(angle),
                        y: radius * Math.sin(angle)
                    });
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                if (this.hit) {
                    ctx.globalAlpha = 0.7;
                }
                
                // 硬質岩石の色 - 黒から濃いグレーのグラデーション
                const gradient = ctx.createLinearGradient(0, -this.height / 2, 0, this.height / 2);
                const baseOpacity = 0.9; // より不透明に
                gradient.addColorStop(0, `rgba(64, 64, 64, ${baseOpacity})`); // 濃いグレー
                gradient.addColorStop(0.3, `rgba(32, 32, 32, ${baseOpacity})`); // より暗いグレー
                gradient.addColorStop(0.7, `rgba(16, 16, 16, ${baseOpacity})`); // 非常に暗いグレー
                gradient.addColorStop(1, `rgba(8, 8, 8, ${baseOpacity})`); // ほぼ黒
                ctx.fillStyle = gradient;

                // 不規則な硬質岩石の形状を描画
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();

                // 硬質岩石の結晶構造を表現（小さな明るい点）
                ctx.fillStyle = `rgba(128, 128, 128, 0.4)`;
                for (let i = 0; i < 8; i++) {
                    const x = (Math.random() - 0.5) * this.width * 0.8;
                    const y = (Math.random() - 0.5) * this.height * 0.8;
                    const size = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 鉱物の微細な光沢（非常に控えめ）
                ctx.fillStyle = `rgba(192, 192, 192, 0.1)`;
                for (let i = 0; i < 3; i++) {
                    const x = (Math.random() - 0.5) * this.width * 0.6;
                    const y = (Math.random() - 0.5) * this.height * 0.6;
                    const size = Math.random() * 1.5 + 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 硬質岩石の暗い輪郭線
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#2F2F2F'; // 暗いグレーの輪郭
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 硬度が高い場合の追加的な暗さ
                if (this.hardness > 2) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2 * (this.hardness - 2)})`;
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (let i = 1; i < this.points.length; i++) {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        class SteamVent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = true;
                this.timer = 0;
                this.radius = 20;
            }
            
            update() {
                this.timer++;
                if (this.timer % 3 === 0 && this.active) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 20,
                        this.y,
                        'steam'
                    ));
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);

                // 蒸気孔の穴
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // 蒸気孔の光
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // 蒸気の表現 (パーティクルで描画されるため、ここでは追加の視覚効果のみ)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }
        
        class OilPocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 80 + 60; // 60-140px
                this.height = Math.random() * 60 + 40; // 40-100px
                this.hit = false;
                this.collected = false;
                this.particles = [];
                this.animationTime = 0;
                this.oilLevel = 1.0; // オイルの量（1.0 = 満タン）
                this.healAmount = 30 + Math.random() * 20; // 30-50の回復量
            }
            
            update() {
                this.animationTime++;
                
                // オイルパーティクルの生成
                if (!this.collected && Math.random() < 0.1) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                // パーティクル更新
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.01;
                    p.size *= 0.99;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                if (!this.collected) {
                    // キャップロック（上部の硬い岩盤層）- より自然な形状
                    const capRockHeight = this.height * 0.25;
                    
                    // キャップロックの不規則な形状を作成
                    ctx.fillStyle = '#708090'; // より自然なグレー
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, -this.height/2);
                    
                    // 不規則な上面
                    for (let i = 0; i <= 8; i++) {
                        const x = (-this.width/2) + (this.width * i / 8);
                        const yVariation = (Math.sin(this.x * 0.01 + i * 0.8) + Math.cos(this.y * 0.005 + i * 1.2)) * 3;
                        ctx.lineTo(x, -this.height/2 + yVariation);
                    }
                    
                    // 右側
                    ctx.lineTo(this.width/2, -this.height/2 + capRockHeight);
                    
                    // 不規則な下面（オイル層との境界）
                    for (let i = 8; i >= 0; i--) {
                        const x = (-this.width/2) + (this.width * i / 8);
                        const yVariation = (Math.sin(this.x * 0.008 + i * 1.1) + Math.cos(this.y * 0.006 + i * 0.9)) * 5;
                        ctx.lineTo(x, -this.height/2 + capRockHeight + yVariation);
                    }
                    
                    // 左側
                    ctx.lineTo(-this.width/2, -this.height/2);
                    ctx.fill();
                    
                    // キャップロックの層理構造
                    ctx.strokeStyle = 'rgba(105, 105, 105, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 1; i < 4; i++) {
                        const layerY = -this.height/2 + (capRockHeight * i / 4);
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + 5, layerY);
                        for (let j = 0; j <= 6; j++) {
                            const x = (-this.width/2 + 5) + ((this.width - 10) * j / 6);
                            const variation = Math.sin(this.x * 0.02 + j * 0.5) * 2;
                            ctx.lineTo(x, layerY + variation);
                        }
                        ctx.stroke();
                    }
                    
                    // 多孔質な貯留層（より自然な形状）
                    const reservoirTop = -this.height/2 + capRockHeight;
                    const reservoirHeight = this.height * 0.75;
                    
                    // 背景の岩石層
                    const rockGradient = ctx.createLinearGradient(0, reservoirTop, 0, reservoirTop + reservoirHeight);
                    rockGradient.addColorStop(0, '#D2B48C'); // 砂岩色
                    rockGradient.addColorStop(0.5, '#F4A460'); // より明るい砂岩
                    rockGradient.addColorStop(1, '#CD853F'); // 濃い砂岩
                    ctx.fillStyle = rockGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, reservoirTop);
                    
                    // 不規則な境界線
                    for (let i = 0; i <= 10; i++) {
                        const x = (-this.width/2) + (this.width * i / 10);
                        const topVariation = Math.sin(this.x * 0.01 + i * 0.7) * 3;
                        const bottomVariation = Math.cos(this.x * 0.012 + i * 0.9) * 4;
                        
                        if (i === 0) {
                            ctx.moveTo(x, reservoirTop + topVariation);
                        } else if (i === 10) {
                            ctx.lineTo(x, reservoirTop + topVariation);
                            ctx.lineTo(x, this.height/2 + bottomVariation);
                            
                            // 底面
                            for (let j = 10; j >= 0; j--) {
                                const bottomX = (-this.width/2) + (this.width * j / 10);
                                const bottomVar = Math.cos(this.x * 0.012 + j * 0.9) * 4;
                                ctx.lineTo(bottomX, this.height/2 + bottomVar);
                            }
                            
                            ctx.lineTo(-this.width/2, reservoirTop);
                        } else {
                            ctx.lineTo(x, reservoirTop + topVariation);
                        }
                    }
                    ctx.fill();
                    
                    // オイル（原油）の表現
                    if (this.oilLevel > 0) {
                        const oilHeight = reservoirHeight * 0.8 * this.oilLevel;
                        
                        // オイルのグラデーション
                        const oilGradient = ctx.createLinearGradient(0, this.height/2 - oilHeight, 0, this.height/2);
                        oilGradient.addColorStop(0, 'rgba(139, 69, 19, 0.9)'); // 濃い茶色
                        oilGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.95)'); // 黒
                        oilGradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.9)'); // 濃い茶色
                        oilGradient.addColorStop(1, 'rgba(139, 69, 19, 0.8)'); // やや明るい茶色
                        
                        ctx.fillStyle = oilGradient;
                        ctx.fillRect(-this.width/2 + 8, this.height/2 - oilHeight, this.width - 16, oilHeight);
                        
                        // オイルの表面の波紋効果
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 1;
                        const surfaceY = this.height/2 - oilHeight;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + 8, surfaceY);
                        for (let i = 0; i <= 8; i++) {
                            const x = (-this.width/2 + 8) + ((this.width - 16) * i / 8);
                            const wave = Math.sin(this.animationTime * 0.05 + i * 0.5) * 1.5;
                            ctx.lineTo(x, surfaceY + wave);
                        }
                        ctx.stroke();
                        
                        // オイルの光沢
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        ctx.fillRect(-this.width/2 + 10, surfaceY, this.width - 20, 3);
                    }
                    
                    // 多孔質構造の表現（小さな穴）
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    for (let i = 0; i < 15; i++) {
                        const poreX = (Math.random() - 0.5) * (this.width - 20);
                        const poreY = reservoirTop + Math.random() * reservoirHeight * 0.8;
                        const poreSize = Math.random() * 2 + 1;
                        ctx.beginPath();
                        ctx.arc(poreX, poreY, poreSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 発見マーク（より控えめに）
                    if (Math.abs(this.x - game.drillX) < 80 && Math.abs(this.y - game.drillY) < 80) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillText('⚫', 0, -this.height/2 - 15);
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // 採掘済みの跡（より自然な穴）
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)');
                    gradient.addColorStop(1, 'rgba(139, 69, 19, 0.2)');
                    ctx.fillStyle = gradient;
                    
                    ctx.beginPath();
                    // 不規則な採掘跡
                    for (let i = 0; i <= 16; i++) {
                        const angle = (Math.PI * 2 * i) / 16;
                        const radius = (this.width/2.5) + Math.sin(i * 0.7) * 8;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius * 0.7;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.fill();
                }
                
                // オイルパーティクル（より現実的に）
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life * 0.6;
                    ctx.fillStyle = '#654321'; // より自然な油の色
                    ctx.beginPath();
                    ctx.arc(p.x - this.x, p.y - screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }

        class OilMoney {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 80;
                this.collected = false;
                this.animationTime = 0;
                this.value = 500 + Math.random() * 500; // 500-1000ポイント
                this.image = new Image();
                this.image.src = 'sekiyu_oil_money.png';
                this.imageLoaded = false;
                
                this.image.onload = () => {
                    this.imageLoaded = true;
                };
                
                // 回転アニメーション
                this.rotation = 0;
                this.rotationSpeed = 0.02;
                
                // 浮遊アニメーション
                this.floatOffset = Math.random() * Math.PI * 2;
                this.floatAmplitude = 10;
            }
            
            update() {
                this.animationTime++;
                this.rotation += this.rotationSpeed;
                
                // 浮遊効果
                this.y += Math.sin(this.animationTime * 0.05 + this.floatOffset) * 0.3;
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                if (this.imageLoaded) {
                    // 画像を描画
                    ctx.save();
                    ctx.rotate(this.rotation);
                    
                    // 画像のサイズを調整
                    const imageWidth = this.width;
                    const imageHeight = this.height;
                    
                    ctx.drawImage(
                        this.image,
                        -imageWidth / 2,
                        -imageHeight / 2,
                        imageWidth,
                        imageHeight
                    );
                    
                    ctx.restore();
                    
                    // 光る効果
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(this.animationTime * 0.1) * 0.2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FFD700';
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2 + 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // 画像が読み込まれていない場合のフォールバック
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 3;
                    
                    // オイルドラム
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                    
                    // "OIL" テキスト
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('OIL', 0, 5);
                }
                
                // 価値表示
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(`$${Math.floor(this.value)}`, 0, this.height/2 + 20);
                ctx.fillText(`$${Math.floor(this.value)}`, 0, this.height/2 + 20);
                
                ctx.restore();
            }
        }

        class Mole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4; // 移動速度を2倍に
                this.vy = 0;
                this.width = 40;
                this.height = 30;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.animationTime = 0;
                this.tunnelX = x;
                this.surprised = false;
                this.fleeing = false;
            }
            
            update() {
                this.animationTime++;
                
                // ドリルとの距離を計算
                const distance = Math.sqrt(
                    Math.pow(this.x - game.drillX, 2) + 
                    Math.pow(this.y - game.drillY, 2)
                );
                
                // ドリルが近づいたら驚いて逃げる
                if (distance < 150 && !this.fleeing) {
                    this.surprised = true;
                    this.fleeing = true;
                    this.vx = (this.x - game.drillX) * 0.2; // 逃げる速度を2倍に
                    this.vy = -4; // 垂直移動も2倍に
                }
                
                if (this.fleeing) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.95;
                    this.vy += 0.1;
                } else {
                    // 通常の移動
                    this.x += Math.sin(this.animationTime * 0.05) * 0.5 * this.direction;
                    
                    // 画面端で方向転換
                    if (this.x < 50 || this.x > canvas.width - 50) {
                        this.direction *= -1;
                    }
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                // もぐらの穴
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // もぐらの体 (より有機的な形状と毛並み)
                ctx.fillStyle = '#4B3621';
                ctx.strokeStyle = '#3A2B1A';
                ctx.lineWidth = 1;
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // 毛並みの表現 (簡単な線で)
                for(let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                    ctx.lineTo(radius * Math.cos(angle) * 1.2, radius * Math.sin(angle) * 1.2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.stroke();
                }
                
                // もぐらの頭
                ctx.fillStyle = '#5C4033';
                ctx.beginPath();
                ctx.ellipse(this.direction * 15, -5, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // 鼻 (よりリアルに)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(this.direction * 22, -5, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 目 (表情豊かに)
                if (this.surprised) {
                    // 驚いた目
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 4, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // 通常の目
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 手 (より詳細に)
                ctx.fillStyle = '#4B3621';
                ctx.beginPath();
                ctx.ellipse(-10, 5, 6, 8, -0.3, 0, Math.PI * 2);
                ctx.ellipse(10, 5, 6, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // 土の粒子
                if (!this.fleeing && Math.random() < 0.3) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 30,
                        this.y + 10,
                        'rock'
                    ));
                }
                
                // 驚きマーク
                if (this.surprised && !this.fleeing) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', 0, -25);
                }
                
                ctx.restore();
            }
        }
        
        class Fault {
            constructor(y) {
                this.y = y;
                this.startX = Math.random() * (canvas.width - 400) + 200; // 断層の開始X位置
                this.length = Math.random() * 400 + 300; // 断層の長さ（300-700px）
                this.angle = (Math.random() * 60 - 30) * Math.PI / 180; // -30度から+30度の角度
                this.warningWidth = 60; // 警告範囲の幅
                this.particles = [];
                this.crackPoints = [];
                
                // 斜めの亀裂の形状を生成
                const numPoints = Math.floor(Math.random() * 8) + 12; // 12-19 points
                for (let i = 0; i <= numPoints; i++) {
                    const progress = i / numPoints;
                    
                    // 基本の斜めライン
                    const baseX = Math.cos(this.angle) * this.length * progress;
                    const baseY = Math.sin(this.angle) * this.length * progress;
                    
                    // ランダムなずれを追加（より自然な亀裂に）
                    const randomOffset = (Math.random() - 0.5) * 40;
                    const perpX = -Math.sin(this.angle) * randomOffset;
                    const perpY = Math.cos(this.angle) * randomOffset;
                    
                    this.crackPoints.push({ 
                        x: baseX + perpX, 
                        y: baseY + perpY 
                    });
                }
            }
            
            // 亀裂部分との当たり判定（斜め対応）
            checkCrackCollision(drillX, drillY, drillWidth, drillHeight) {
                const crackThickness = 15; // 亀裂の厚み
                
                for (let i = 0; i < this.crackPoints.length - 1; i++) {
                    const p1 = this.crackPoints[i];
                    const p2 = this.crackPoints[i + 1];
                    
                    // 線分の両端（斜めの亀裂）
                    const x1 = this.startX + p1.x;
                    const y1 = this.y + p1.y;
                    const x2 = this.startX + p2.x;
                    const y2 = this.y + p2.y;
                    
                    // ドリルの矩形と線分の交差判定
                    if (this.lineIntersectsRect(x1, y1, x2, y2, 
                        drillX - drillWidth/2, drillY - drillHeight/2, 
                        drillWidth, drillHeight, crackThickness)) {
                        return true;
                    }
                }
                return false;
            }
            
            // 線分と矩形の交差判定（太い線として扱う）
            lineIntersectsRect(x1, y1, x2, y2, rectX, rectY, rectWidth, rectHeight, thickness) {
                // 太い線を矩形として扱う
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return false;
                
                // 正規化されたベクトル
                const nx = dx / length;
                const ny = dy / length;
                
                // 垂直ベクトル
                const px = -ny * thickness / 2;
                const py = nx * thickness / 2;
                
                // 太い線の4つの角
                const corners = [
                    { x: x1 + px, y: y1 + py },
                    { x: x1 - px, y: y1 - py },
                    { x: x2 + px, y: y2 + py },
                    { x: x2 - px, y: y2 - py }
                ];
                
                // 任意の角がドリルの矩形内にあるかチェック
                for (const corner of corners) {
                    if (corner.x >= rectX && corner.x <= rectX + rectWidth &&
                        corner.y >= rectY && corner.y <= rectY + rectHeight) {
                        return true;
                    }
                }
                
                return false;
            }
            
            update() {
                // 警告パーティクル（斜め断層用）
                if (Math.random() < 0.3) {
                    // 断層線上の任意の点でパーティクル生成
                    const progress = Math.random();
                    const baseX = Math.cos(this.angle) * this.length * progress;
                    const baseY = Math.sin(this.angle) * this.length * progress;
                    
                    this.particles.push({
                        x: this.startX + baseX + (Math.random() - 0.5) * this.warningWidth,
                        y: this.y + baseY + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= 0.02;
                    p.size *= 0.98;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                // 断層の境界を計算（斜め線の場合）
                const endX = this.startX + Math.cos(this.angle) * this.length;
                const endY = this.y + Math.sin(this.angle) * this.length;
                const screenEndY = endY - game.cameraY;
                
                // 画面外の場合は描画しない
                const minY = Math.min(screenY, screenEndY);
                const maxY = Math.max(screenY, screenEndY);
                if (maxY < -50 || minY > canvas.height + 50) return;
                
                // 警告ゾーン（断層の両側に沿って）
                if (minY < canvas.height && maxY > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.4;
                    
                    // 断層に沿った警告エリアを描画
                    const perpX = -Math.sin(this.angle) * this.warningWidth;
                    const perpY = Math.cos(this.angle) * this.warningWidth;
                    
                    // 警告ゾーンの四角形
                    const warningPoints = [
                        { x: this.startX + perpX, y: screenY + perpY },
                        { x: this.startX - perpX, y: screenY - perpY },
                        { x: endX - perpX, y: screenEndY - perpY },
                        { x: endX + perpX, y: screenEndY + perpY }
                    ];
                    
                    // グラデーション警告ゾーン
                    const gradient = ctx.createLinearGradient(
                        this.startX - perpX, screenY - perpY,
                        this.startX + perpX, screenY + perpY
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                    gradient.addColorStop(0.4, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(0.6, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(warningPoints[0].x, warningPoints[0].y);
                    for (let i = 1; i < warningPoints.length; i++) {
                        ctx.lineTo(warningPoints[i].x, warningPoints[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                
                // 断層本体（斜めの亀裂として描画）
                ctx.save();
                ctx.strokeStyle = '#333333'; // 亀裂の色
                ctx.lineWidth = 12; // 亀裂の太さを少し太く
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#000';

                ctx.beginPath();
                if (this.crackPoints.length > 0) {
                    const firstPoint = this.crackPoints[0];
                    ctx.moveTo(this.startX + firstPoint.x, this.y + firstPoint.y - game.cameraY);
                    for (let i = 1; i < this.crackPoints.length; i++) {
                        const point = this.crackPoints[i];
                        ctx.lineTo(this.startX + point.x, this.y + point.y - game.cameraY);
                    }
                }
                ctx.stroke();

                // 亀裂の光る縁
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#FF0000';
                ctx.beginPath();
                if (this.crackPoints.length > 0) {
                    const firstPoint = this.crackPoints[0];
                    ctx.moveTo(this.startX + firstPoint.x, this.y + firstPoint.y - game.cameraY);
                    for (let i = 1; i < this.crackPoints.length; i++) {
                        const point = this.crackPoints[i];
                        ctx.lineTo(this.startX + point.x, this.y + point.y - game.cameraY);
                    }
                }
                ctx.stroke();
                
                // 警告パーティクル
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                
                // 警告テキスト（断層の中央に表示）
                const centerX = this.startX + Math.cos(this.angle) * this.length / 2;
                const centerY = this.y + Math.sin(this.angle) * this.length / 2;
                const screenCenterY = centerY - game.cameraY;
                
                if (screenCenterY > 40 && screenCenterY < canvas.height - 40 && 
                    centerX > 0 && centerX < canvas.width) {
                    ctx.save();
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF0000';
                    
                    // テキストを断層の角度に合わせて回転
                    ctx.translate(centerX, screenCenterY - 30);
                    ctx.rotate(this.angle);
                    ctx.fillText('⚠ 断層 ⚠', 0, 0);
                    ctx.restore();
                }
            }
        }
        
        function generateTerrain() {
            // 画面下端から少し先の位置で障害物を生成
            const spawnY = game.cameraY + canvas.height + 200;
            const spawnCheck = Math.floor(spawnY / 100) * 100;
            
            if (!game.generatedSpawns) game.generatedSpawns = new Set();
            
            if (!game.generatedSpawns.has(spawnCheck)) {
                game.generatedSpawns.add(spawnCheck);
                
                // もぐら（500-2000mの部分） - 画面下から出現
                if (game.depth >= 500 && game.depth < 2000) {
                    if (Math.random() < 0.3) {
                        game.moles.push(new Mole(
                            Math.random() * (canvas.width - 100) + 50,
                            spawnY
                        ));
                    }
                }
                
                // 岩の生成 - 画面下から出現
                const rockCount = Math.floor(Math.random() * 2) + 1 + Math.floor(game.depth / 2000);
                for (let i = 0; i < rockCount; i++) {
                    const rock = new Rock(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    );
                    rock.hardness += game.depth / 3000;
                    game.rocks.push(rock);
                }
                
                // 蒸気孔（1500m以降） - 画面下から出現
                if (game.depth > 1500 && Math.random() < 0.2 + game.depth / 8000) {
                    game.steamVents.push(new SteamVent(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // オイルポケット（800m以降、2000m未満） - 比較的浅い層に配置
                if (game.depth >= 800 && game.depth < 2000 && Math.random() < 0.15) {
                    game.oilPockets.push(new OilPocket(
                        Math.random() * (canvas.width - 200) + 100,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // オイルマネー（序盤から出現） - レアアイテム
                if (game.depth >= 200 && Math.random() < 0.05) {
                    game.oilMoney.push(new OilMoney(
                        Math.random() * (canvas.width - 120) + 60,
                        spawnY + Math.random() * 150
                    ));
                }
                
                // 断層（2500m以降） - 画面下から出現
                if (game.depth > 2500) {
                    const faultChance = 0.1 + (game.depth - 2500) / 15000;
                    if (Math.random() < faultChance) {
                        game.faults.push(new Fault(spawnY + Math.random() * 100));
                    }
                }
            }
        }
        
        function updateGame() {
            if (!game.gameRunning) return;

            // スター状態のタイマー更新
            if (game.starMode) {
                game.starModeTimer -= 1/60; // 60FPSを想定
                if (game.starModeTimer <= 0) {
                    game.starMode = false;
                    game.starModeTimer = 0;
                    console.log('⭐ スター状態終了');
                }
            }
            
            // コンボシステムの更新
            if (game.comboTimer > 0) {
                game.comboTimer -= 1/60; // 60FPSを想定
                if (game.comboTimer <= 0) {
                    game.comboCount = 0; // コンボリセット
                }
            }

            // --- START OF NEW EFFECTS ---

            // 1. Continuous screen shake for drilling vibration（強化版）
            let shakeIntensity = Math.min(game.drillSpeed / 5, 3.0); // 基本強度を2倍に
            
            // 深度に応じてシェイク強度を増加
            if (game.depth > 3000) {
                shakeIntensity *= 1.5; // 深部では1.5倍
            }
            if (game.depth > 5000) {
                shakeIntensity *= 1.8; // 極深部では1.8倍
            }
            
            // より動的なシェイクパターン
            const shakeX = (Math.random() - 0.5) * shakeIntensity + Math.sin(Date.now() * 0.01) * (shakeIntensity * 0.3);
            const shakeY = (Math.random() - 0.5) * shakeIntensity + Math.cos(Date.now() * 0.008) * (shakeIntensity * 0.3);
            canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;

            // 2. Continuous drilling particle generation（強化版）
            const particleCount = Math.ceil(game.drillSpeed * 2); // パーティクル数を2倍に増加
            for (let i = 0; i < particleCount; i++) {
                let particleType = 'rock';
                if (game.depth > 5000) {
                    particleType = Math.random() < 0.7 ? 'lava' : 'spark'; // 深部では溶岩と火花
                } else if (game.depth > 3000) {
                    if (Math.random() < 0.5) particleType = 'lava';
                    if (Math.random() < 0.3) particleType = 'spark'; // 火花も追加
                } else if (game.depth > 1000) {
                    if (Math.random() < 0.2) particleType = 'spark'; // 中深度でも火花
                }
                
                // より広範囲にパーティクルを散らす
                game.particles.push(new Particle(
                    game.drillX + (Math.random() - 0.5) * 50, // 範囲を拡大
                    game.drillY + 60 + (Math.random() - 0.5) * 20, // 縦方向にも散らす
                    particleType
                ));
            }
            
            // 追加の爆発的パーティクル（確率的に）
            if (Math.random() < 0.15) {
                for (let i = 0; i < 8; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 80,
                        game.drillY + 40 + (Math.random() - 0.5) * 40,
                        Math.random() < 0.5 ? 'spark' : 'rock'
                    ));
                }
            }
            
            // 掘削音を再生（確率的に）- 頻度を上げて爽快感向上
            if (Math.random() < 0.25) { // 10% → 25%に増加
                audioManager.playSound('drilling');
            }

            // 3. Spark generation at high temperatures + 深度効果
            if (game.temperature > 800) {
                if (Math.random() < (game.temperature - 800) / 1000) {
                    game.particles.push(new Particle(game.drillX, game.drillY + 40, 'spark'));
                }
            }
            
            // 4. 深度に応じた特殊効果
            if (game.depth > 2000) {
                // 深度2000m以上：地熱の影響でより多くの火花
                if (Math.random() < 0.08) {
                    for (let i = 0; i < 3; i++) {
                        game.particles.push(new Particle(
                            game.drillX + (Math.random() - 0.5) * 60,
                            game.drillY + 30 + Math.random() * 40,
                            'spark'
                        ));
                    }
                }
            }
            
            if (game.depth > 4000) {
                // 深度4000m以上：溶岩の影響でオレンジ色の光る効果
                if (Math.random() < 0.05) {
                    canvas.style.filter = 'brightness(1.2) sepia(0.3) hue-rotate(20deg)';
                    setTimeout(() => canvas.style.filter = '', 100);
                }
            }
            
            if (game.depth > 6000) {
                // 深度6000m以上：極限状態で赤い光る効果
                if (Math.random() < 0.03) {
                    canvas.style.filter = 'brightness(1.4) sepia(0.8) hue-rotate(0deg) saturate(2)';
                    setTimeout(() => canvas.style.filter = '', 200);
                }
            }

            // --- END OF NEW EFFECTS ---
            
            // パイプセグメントの追加（10ピクセルごと）
            if (game.pipeSegments.length === 0 || 
                game.drillY - game.pipeSegments[game.pipeSegments.length - 1].y > 10) {
                game.pipeSegments.push({
                    x: game.drillX,
                    y: game.drillY,
                    angle: Math.atan2(
                        game.drillX - (game.pipeSegments.length > 0 ? 
                            game.pipeSegments[game.pipeSegments.length - 1].x : game.drillX),
                        10
                    )
                });
            }
            
            // 自動掘削（下方向への移動）
            game.drillY += game.drillSpeed;
            game.depth = Math.floor(game.drillY / 10);
            game.maxDepth = Math.max(game.maxDepth, game.depth);
            
            // カメラの追従
            game.cameraY = game.drillY - 100;
            
            // 左右移動（速度制限）
            const baseMoveSpeed = 3.0; // 基本移動速度を高速化
            const moveSpeed = baseMoveSpeed + (game.drillSpeed * 0.15); // 掘削速度の影響を増加
            const maxMoveSpeed = 5.0; // 最大移動速度を高速化
            const actualMoveSpeed = Math.min(moveSpeed, maxMoveSpeed);
            
            if (keys['ArrowLeft'] && game.drillX > 50) {
                game.drillX -= actualMoveSpeed;
            }
            if (keys['ArrowRight'] && game.drillX < canvas.width - 50) {
                game.drillX += actualMoveSpeed;
            }
            
            // デバッグ用：キー入力の確認
            // console.log('Keys:', keys, 'DrillX:', game.drillX);
            
            // 温度上昇
            game.temperature = 15 + game.depth * 0.035;
            if (game.depth > 3000) {
                game.temperature += (game.depth - 3000) * 0.05; // 3000m以降は急激に温度上昇
            }
            game.maxTemp = Math.max(game.maxTemp, game.temperature);
            
            // 衝突フラグをリセット
            let hitObstacle = false;
            
            // 警告表示
            const shouldShowWarning = game.temperature > 1000;
            document.getElementById('warningText').style.display = shouldShowWarning ? 'block' : 'none';
            
            // 高温警告音（たまに再生）
            if (shouldShowWarning && Math.random() < 0.02) {
                audioManager.playSound('warning');
            }
            
            // 地形生成
            generateTerrain();
            
            // もぐらの更新と衝突チェック
            game.moles.forEach(mole => {
                mole.update();
                
                // もぐらとの衝突（先端ビットのみ、ダメージは少ない）
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ドリル全体の最下端
                
                if (!mole.fleeing &&
                    Math.abs(mole.x - bitTipX) < 20 &&
                    Math.abs(mole.y - bitTipY) < 20) {
                    
                    game.drillDurability -= 5;
                    hitObstacle = true;
                    mole.surprised = true;
                    mole.fleeing = true;
                    
                    // かわいい衝突エフェクト
                    for (let i = 0; i < 5; i++) {
                        game.particles.push(new Particle(mole.x, mole.y, 'rock'));
                    }
                    
                    // 衝突音を再生
                    audioManager.playSound('collision');
                }
            });
            
            // 岩との衝突チェック（先端ビットのみ）
            game.rocks.forEach(rock => {
                // ビット先端位置（ドリルの最下端）
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ドリル全体の最下端
                const bitTipRadius = 25; // ビット先端の小さな範囲
                
                if (!rock.hit &&
                    Math.abs(rock.x - bitTipX) < (rock.width/2 + bitTipRadius) &&
                    Math.abs(rock.y - bitTipY) < (rock.height/2 + bitTipRadius)) {
                    
                    rock.hit = true;
                    game.drillDurability -= rock.hardness * 3;
                    hitObstacle = true;
                    
                    // コンボシステム
                    game.comboCount++;
                    game.comboTimer = game.comboMaxTime;
                    
                    // コンボに応じて効果を強化
                    const comboMultiplier = Math.min(game.comboCount / 5, 2.0); // 最大2倍
                    const baseParticles = 15;
                    const comboParticles = Math.floor(baseParticles * (1 + comboMultiplier));
                    
                    // 衝突エフェクト (岩と火花) - コンボで強化
                    for (let i = 0; i < comboParticles; i++) {
                        game.particles.push(new Particle(
                            game.drillX + (Math.random() - 0.5) * 60 * (1 + comboMultiplier * 0.5),
                            game.drillY + 40 + (Math.random() - 0.5) * 30,
                            i < comboParticles * 0.7 ? 'rock' : 'spark'
                        ));
                    }
                    
                    // 岩石破壊音を再生
                    audioManager.playSound('rockBreak');
                    
                    // コンボが高い場合の特別エフェクト
                    if (game.comboCount >= 5) {
                        canvas.style.filter = 'brightness(1.3) saturate(1.5) hue-rotate(60deg)';
                        setTimeout(() => canvas.style.filter = '', 200);
                    }
                    if (game.comboCount >= 10) {
                        // 超コンボ時のエフェクト
                        for (let i = 0; i < 20; i++) {
                            game.particles.push(new Particle(
                                game.drillX + (Math.random() - 0.5) * 100,
                                game.drillY + (Math.random() - 0.5) * 100,
                                'spark'
                            ));
                        }
                    }
                    
                    // 画面の揺れ効果（強化）
                    canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    setTimeout(() => canvas.style.transform = '', 150);
                }
            });
            
            // オイルポケットとの衝突チェック
            game.oilPockets.forEach(oilPocket => {
                oilPocket.update();
                
                if (!oilPocket.collected &&
                    Math.abs(oilPocket.x - game.drillX) < (oilPocket.width/2 + 20) &&
                    Math.abs(oilPocket.y - game.drillY) < (oilPocket.height/2 + 30)) {
                    
                    oilPocket.collected = true;
                    
                    // ドリル耐久度回復
                    const oldDurability = game.drillDurability;
                    game.drillDurability += oilPocket.healAmount;
                    game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
                    
                    // 回復エフェクト
                    for (let i = 0; i < 20; i++) {
                        game.particles.push(new Particle(
                            oilPocket.x + (Math.random() - 0.5) * 60,
                            oilPocket.y + (Math.random() - 0.5) * 40,
                            'steam'
                        ));
                    }
                    
                    // 画面の光る効果
                    canvas.style.filter = 'brightness(1.3) sepia(0.3)';
                    setTimeout(() => canvas.style.filter = '', 500);
                    
                    console.log(`オイル採掘！耐久度 ${Math.floor(oldDurability)} → ${Math.floor(game.drillDurability)} (+${Math.floor(oilPocket.healAmount)})`);
                }
            });
            
            // オイルマネーとの衝突チェック
            game.oilMoney.forEach(oilMoney => {
                oilMoney.update();
                
                if (!oilMoney.collected &&
                    Math.abs(oilMoney.x - game.drillX) < (oilMoney.width/2 + 20) &&
                    Math.abs(oilMoney.y - game.drillY) < (oilMoney.height/2 + 30)) {
                    
                    oilMoney.collected = true;
                    
                    // オイルマネーストックに追加
                    game.oilMoneyStock += 1;
                    
                    // 豪華な獲得エフェクト
                    for (let i = 0; i < 30; i++) {
                        game.particles.push(new Particle(
                            oilMoney.x + (Math.random() - 0.5) * 80,
                            oilMoney.y + (Math.random() - 0.5) * 60,
                            Math.random() < 0.5 ? 'spark' : 'steam'
                        ));
                    }
                    
                    // 画面の豪華なフラッシュ効果
                    canvas.style.filter = 'brightness(1.5) saturate(1.5) hue-rotate(30deg)';
                    setTimeout(() => canvas.style.filter = '', 800);
                    
                    // オイルマネー獲得音を再生
                    audioManager.playSound('oilMoney');
                    
                    console.log(`オイルマネー獲得！ストック数: ${game.oilMoneyStock}`);
                }
            });

            // 蒸気孔ボーナス
            game.steamVents.forEach(vent => {
                vent.update();
                const distance = Math.sqrt(
                    Math.pow(vent.x - game.drillX, 2) + 
                    Math.pow(vent.y - game.drillY, 2)
                );
                if (distance < 50) {
                    // 近くにいるとパーティクル増加
                    if (Math.random() < 0.3) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'steam'));
                    }
                }
            });
            
            // マグマ溜まりのダメージ（先端ビットのみ）
            game.magmaPools.forEach(pool => {
                pool.update();
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ドリル全体の最下端
                
                if (Math.abs(pool.x - bitTipX) < pool.width/2 &&
                    Math.abs(pool.y - bitTipY) < 30) {
                    game.drillDurability -= 0.5;
                    hitObstacle = true;
                    
                    if (Math.random() < 0.2) {
                        game.particles.push(new Particle(bitTipX, bitTipY, 'lava'));
                    }
                }
            });
            
            
            // ビーム更新
            game.beams.forEach(beam => beam.update());
            game.beams = game.beams.filter(beam => beam.life > 0);
            
            // パーティクル更新
            game.particles.forEach(p => p.update());
            game.particles = game.particles.filter(p => p.life > 0);
            
            // ドリル耐久度の回復機能を無効化（より挑戦的なゲームバランス）
            // if (!hitObstacle && game.drillDurability < game.drillMaxDurability) {
            //     game.drillDurability += 0.1; // 回復速度を上げる
            //     game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
            // }
            
            // 掘削速度の自動増加（緩やかに調整）
            if (game.depth % 500 === 0 && game.depth > 0) {  // 500mごとに加速
                game.drillSpeed += 0.15;  // より緩やかな増加
            }
            
            // 3000m以降さらに加速（より緩やか）
            if (game.depth > 3000) {
                game.drillSpeed += 0.001 * (game.depth - 3000) / 200;  // 加速度を半分に
            }
            
            // 最大速度制限を追加
            game.drillSpeed = Math.min(game.drillSpeed, 8.0); // 最大速度を8.0に制限
            
            // 断層との衝突チェック（先端ビットのみ）
            game.faults.forEach(fault => {
                fault.update();
                
                // ビット先端位置とサイズ
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ドリル全体の最下端
                const bitTipWidth = 50; // ビット先端の幅
                const bitTipHeight = 30; // ビット先端の高さ
                
                // 亀裂との衝突判定（先端ビットのみ）
                if (fault.checkCrackCollision(bitTipX, bitTipY, bitTipWidth, bitTipHeight)) {
                    // 亀裂に直接衝突：重いダメージ
                    game.drillDurability -= 3;
                    hitObstacle = true;
                    
                    // 衝突エフェクト
                    for (let i = 0; i < 10; i++) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                    }
                    
                    // 画面揺れ
                    canvas.style.transform = `translate(${Math.random() * 15 - 7.5}px, ${Math.random() * 15 - 7.5}px)`;
                    setTimeout(() => canvas.style.transform = '', 120);
                }
            });
            
            // ゲームオーバー判定
            if (game.drillDurability <= 0) {
                gameOver();
            }
            
            // オブジェクトのクリーンアップ（画面外のオブジェクトを削除）
            game.rocks = game.rocks.filter(rock => rock.y > game.cameraY - 200);
            game.steamVents = game.steamVents.filter(vent => vent.y > game.cameraY - 200);
            game.magmaPools = game.magmaPools.filter(pool => pool.y > game.cameraY - 200);
            game.faults = game.faults.filter(fault => fault.y > game.cameraY - 200);
            game.oilPockets = game.oilPockets.filter(oilPocket => oilPocket.y > game.cameraY - 200);
            game.moles = game.moles.filter(mole => mole.y > game.cameraY - 200 && mole.y < game.cameraY + canvas.height + 200);
            game.pipeSegments = game.pipeSegments.filter(segment => segment.y > game.cameraY - 100);
            
            updateUI();
        }
        
        function drawGame() {
            // --- START OF NEW BACKGROUND LOGIC ---

            // 1. Define colors for different geological layers
            const layers = [
                { depth: 0,    colors: ['#87CEEB', '#A0522D'] }, // Surface: Sky to Soil
                { depth: 500,  colors: ['#A0522D', '#8B4513'] }, // Soil to Sediment
                { depth: 1500, colors: ['#696969', '#505050'] }, // Sedimentary/Metamorphic Rock (Greys)
                { depth: 3000, colors: ['#3E2723', '#2E1F1A'] }, // Igneous Rock (Dark Browns)
                { depth: 5000, colors: ['#2E1F1A', '#8B0000'] }, // Close to Mantle (Dark Red)
                { depth: 7000, colors: ['#8B0000', '#FF4500'] }  // Magma (Red to Orange)
            ];

            // 2. Determine the current and next layer based on depth
            let currentLayer = layers[0];
            let nextLayer = layers[1];
            for (let i = 0; i < layers.length - 1; i++) {
                if (game.depth >= layers[i].depth) {
                    currentLayer = layers[i];
                    nextLayer = layers[i+1];
                }
            }
            
            // 3. Calculate the transition progress between the two layers
            const layerDepthSpan = nextLayer.depth - currentLayer.depth;
            const progressInLayer = (game.depth - currentLayer.depth) / layerDepthSpan;
            
            // 4. Interpolate colors based on progress
            const r1 = parseInt(currentLayer.colors[0].slice(1, 3), 16);
            const g1 = parseInt(currentLayer.colors[0].slice(3, 5), 16);
            const b1 = parseInt(currentLayer.colors[0].slice(5, 7), 16);
            
            const r2 = parseInt(nextLayer.colors[0].slice(1, 3), 16);
            const g2 = parseInt(nextLayer.colors[0].slice(3, 5), 16);
            const b2 = parseInt(nextLayer.colors[0].slice(5, 7), 16);

            const r3 = parseInt(currentLayer.colors[1].slice(1, 3), 16);
            const g3 = parseInt(currentLayer.colors[1].slice(3, 5), 16);
            const b3 = parseInt(currentLayer.colors[1].slice(5, 7), 16);

            const r4 = parseInt(nextLayer.colors[1].slice(1, 3), 16);
            const g4 = parseInt(nextLayer.colors[1].slice(3, 5), 16);
            const b4 = parseInt(nextLayer.colors[1].slice(5, 7), 16);

            const topR = Math.round(r1 + (r2 - r1) * progressInLayer);
            const topG = Math.round(g1 + (g2 - g1) * progressInLayer);
            const topB = Math.round(b1 + (b2 - b1) * progressInLayer);

            const bottomR = Math.round(r3 + (r4 - r3) * progressInLayer);
            const bottomG = Math.round(g3 + (g4 - g3) * progressInLayer);
            const bottomB = Math.round(b3 + (b4 - b3) * progressInLayer);

            const topColor = `rgb(${topR}, ${topG}, ${topB})`;
            const bottomColor = `rgb(${bottomR}, ${bottomG}, ${bottomB})`;

            // 5. Create and apply the gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 6. Add procedural strata patterns based on depth
            ctx.save();
            for (let d = Math.floor(game.cameraY / 50) * 50; d < game.cameraY + canvas.height + 50; d += 50) {
                const y = d - game.cameraY;
                const currentDepthInMeters = d / 10;

                if (y > 0 && y < canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);

                    if (currentDepthInMeters < 1500) {
                        // Sedimentary layers: relatively straight lines
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.lineWidth = Math.random() * 2 + 1;
                        ctx.lineTo(canvas.width, y + (Math.random() - 0.5) * 5);
                    } else if (currentDepthInMeters < 3000) {
                        // Metamorphic layers: wavy, distorted lines
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                        ctx.lineWidth = Math.random() * 2.5 + 1;
                        ctx.quadraticCurveTo(
                            canvas.width / 2 + Math.sin(d / 100) * 50,
                            y + (Math.random() - 0.5) * 15,
                            canvas.width, 
                            y + (Math.random() - 0.5) * 10
                        );
                    } else {
                        // Igneous/Deeper layers: sharp, crystalline patterns
                        ctx.strokeStyle = 'rgba(255, 220, 180, 0.1)';
                        ctx.lineWidth = Math.random() * 1.5 + 0.5;
                        ctx.moveTo(Math.random() * 50, y);
                        for(let x = 50; x < canvas.width; x += Math.random() * 100 + 50) {
                            ctx.lineTo(x, y + (Math.random() - 0.5) * 25);
                        }
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();

            // 7. Add heat/magma effect for deep sections
            if (game.depth > 3000) {
                const heatIntensity = Math.min((game.depth - 3000) / 4000, 0.4);
                ctx.fillStyle = `rgba(255, 69, 0, ${heatIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Glowing cracks for very deep sections
                if (game.depth > 5000) {
                    ctx.save();
                    const crackCount = Math.min(10, Math.floor((game.depth - 5000) / 200));
                    ctx.globalAlpha = Math.min((game.depth - 5000) / 3000, 0.7);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500';
                    for (let i = 0; i < crackCount; i++) {
                        const y = Math.random() * canvas.height;
                        const x_start = Math.random() * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(x_start, y);
                        ctx.bezierCurveTo(
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 400, y + (Math.random() - 0.5) * 200
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            // --- END OF NEW BACKGROUND LOGIC ---

            // --- START BOREHOLE DRAWING ---
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Dark, semi-transparent for the tunnel
            ctx.lineWidth = 50; // Width of the borehole, wider than the drill
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            let firstVisibleSegment = true;
            game.pipeSegments.forEach(segment => {
                const screenY = segment.y - game.cameraY;
                // Only draw segments visible on screen
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisibleSegment) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisibleSegment = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });

            // Extend the tunnel to the current drill position
            if (game.pipeSegments.length > 0 && !firstVisibleSegment) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }

            ctx.stroke();
            ctx.restore();
            // --- END BOREHOLE DRAWING ---
            
            // ドリルパイプの描画
            ctx.save();
            ctx.strokeStyle = '#708090';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // パイプの本体
            ctx.beginPath();
            let firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });
            
            // 最後のセグメントから掘削機まで
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }
            
            ctx.stroke();
            
            // パイプのハイライト
            ctx.strokeStyle = '#A9A9A9';
            ctx.lineWidth = 10;
            ctx.beginPath();
            firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x - 5, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x - 5, screenY);
                    }
                }
            });
            
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX - 5, drillScreenY);
            }
            
            ctx.stroke();
            
            // パイプの継ぎ目
            ctx.fillStyle = '#606060';
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50 && index % 50 === 0) {
                    ctx.beginPath();
                    ctx.arc(segment.x, screenY, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 継ぎ目のボルト
                    ctx.fillStyle = '#404040';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i;
                        const boltX = segment.x + Math.cos(angle) * 10;
                        const boltY = screenY + Math.sin(angle) * 10;
                        ctx.beginPath();
                        ctx.arc(boltX, boltY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#606060';
                }
            });
            
            ctx.restore();
            
            // もぐら
            game.moles.forEach(mole => mole.draw());
            
            // 断層
            game.faults.forEach(fault => fault.draw());
            
            // オイルポケット
            game.oilPockets.forEach(oilPocket => oilPocket.draw());
            
            // オイルマネー
            game.oilMoney.forEach(oilMoney => {
                if (!oilMoney.collected) {
                    oilMoney.draw();
                }
            });
            
            // マグマ溜まり
            game.magmaPools.forEach(pool => pool.draw());
            
            // 岩
            game.rocks.forEach(rock => rock.draw());
            
            // 蒸気孔
            game.steamVents.forEach(vent => vent.draw());
            
            // ビーム
            game.beams.forEach(beam => beam.draw());
            
            // パーティクル
            game.particles.forEach(p => p.draw());
            
            // 掘削機
            const drillScreenY = game.drillY - game.cameraY;
            ctx.save();
            ctx.translate(game.drillX, drillScreenY);

            // ドリルの傾きを適用
            let tiltAngle = 0;
            const maxTilt = Math.PI / 16; // 傾きの最大角度（ラジアン）
            if (keys['ArrowLeft']) {
                tiltAngle = maxTilt; // 左キーで右に傾ける
            } else if (keys['ArrowRight']) {
                tiltAngle = -maxTilt; // 右キーで左に傾ける
            }
            ctx.rotate(tiltAngle);
            
            // PDCドリルビット（実際の画像を使用、回転アニメーション）- ドリル本体の後ろに配置
            ctx.save();
            ctx.translate(0, 70); // ドリル本体から少し下に配置（50から70に変更）
            
            // 画像を90度回転させて、さらに上下に180度回転、最後に30度回転させて正しい向きにする
            ctx.rotate(Math.PI / 2); // 90度回転
            ctx.rotate(Math.PI); // 上下に180度回転
            ctx.rotate(Math.PI / 6); // さらに30度回転
            ctx.rotate(Math.PI / 8); // さらに30度回転
            ctx.rotate(Math.PI / 8); // さらに30度回転
            ctx.rotate(Math.PI / 9); // さらに30度回転
             
        
        
           
            
            if (imageLoaded) {
                // 画像のサイズ調整（より大きなサイズに）
                const bitWidth = 100; // 60から100に拡大
                const bitHeight = 120; // 80から120に拡大
                
                // 高温時の効果
                if (game.temperature > 500) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = game.temperature > 800 ? '#FF4500' : '#FFD700';
                }
                
                // 高温時の色調変更
                if (game.temperature > 800) {
                    ctx.filter = 'hue-rotate(30deg) saturate(1.5) brightness(1.2)';
                } else if (game.temperature > 500) {
                    ctx.filter = 'saturate(1.2) brightness(1.1)';
                } else {
                    ctx.filter = 'none';
                }
                
                // PDCビット画像を描画（90度回転後の位置調整）
                ctx.drawImage(
                    drillBitImage, 
                    -bitWidth / 2, 
                    -bitHeight / 2, // 中央に配置
                    bitWidth, 
                    bitHeight
                );
                
                // フィルターをリセット
                ctx.filter = 'none';
                
                // 高温時の追加効果（オーバーレイ）
                if (game.temperature > 800) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bitWidth/2 + 8, bitHeight/2 + 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            } else {
                // 画像が読み込まれるまでの代替表示
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(-40, -50, 80, 100); // より大きなサイズ
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', 0, 0);
            }
            
            ctx.restore();
            
            // ドリル本体（PDCビットの上に描画）
            const gradient2 = ctx.createLinearGradient(-20, -30, 20, 30);
            gradient2.addColorStop(0, '#E0E0E0');
            gradient2.addColorStop(1, '#808080');
            ctx.fillStyle = gradient2;
            ctx.fillRect(-25, -40, 50, 80);
            
            // 排気
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = -50 - i * 10;
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, 5 + i * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // 深度マーカー
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 14px Arial';
            for (let d = Math.floor(game.cameraY / 100) * 100; d <= game.cameraY + canvas.height + 100; d += 100) {
                const y = d - game.cameraY;
                if (y > 0 && y < canvas.height) {
                    ctx.fillText(`${Math.floor(d / 10)}m`, 10, y);
                    ctx.fillRect(0, y, 40, 2);
                }
            }
            
            // 画面端の警告
            if (game.drillX < 100 || game.drillX > canvas.width - 100) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (game.drillX < 100) {
                    ctx.fillRect(0, 0, 50, canvas.height);
                } else {
                    ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);
                }
            }
        }
        
        // 深度ベンチマークデータ
        const depthBenchmarks = [
            { depth: 100, name: "🏢 10階建てビル", description: "一般的なオフィスビルの高さ" },
            { depth: 143, name: "🗼 セリオン", description: "秋田県で最も高いタワー" },
            { depth: 333, name: "🗼 東京タワー", description: "逆さまにした東京タワーの高さ" },
            { depth: 450, name: "🏢 エンパイアステートビル", description: "ニューヨークの象徴的な高層ビル" },
            { depth: 634, name: "🗼 東京スカイツリー", description: "日本最高の電波塔" },
            { depth: 828, name: "🏢 ブルジュ・ハリファ", description: "世界一高い超高層ビル" },
            { depth: 1000, name: "🚇 地下鉄道の深い駅", description: "都市部の深い地下駅レベル" },
            { depth: 1642, name: "🏔️ ツインタワーズ", description: "マレーシアの象徴的な超高層ビル" },
            { depth: 2000, name: "⛰️ 富士山の半分", description: "日本最高峰の約半分の高さ" },
            { depth: 3000, name: "🏄 深海用潜水艦", description: "深海探査用潜水艦の到達深度" },
            { depth: 4000, name: "🌊 太平洋の平均深度", description: "世界の海の平均深度" },
            { depth: 5000, name: "🕳️ ソビエトのコラ半島最深部", description: "人類最深の科学掘削プロジェクト開始" },
            { depth: 6000, name: "🌋 地殻下部", description: "大陸地殻の下部領域" },
            { depth: 7000, name: "🌊 日本海溝の深い部分", description: "日本近海の深海溝" },
            { depth: 8000, name: "🏔️ エベレスト山頂", description: "世界最高峰の高さ" },
            { depth: 9000, name: "🌊 海洋深層", description: "深海の本格的な領域" },
            { depth: 10000, name: "🌊 マリアナ海溝付近", description: "世界最深の海溝に近づく" },
            { depth: 11000, name: "🌊 チャレンジャー深淵", description: "地球上最深の場所" },
            { depth: 12262, name: "🕳️ コラ半島超深度掘削", description: "ソビエトの人類最深掘削記録" },
            { depth: 15000, name: "🌋 地殻・マントル境界付近", description: "地球内部構造の境界領域" },
            { depth: 18000, name: "🌍 ブラジルまでの直線距離", description: "秋田からブラジルまでの直線距離" }
        ];

        function showBenchmarkNotification(benchmark) {
            // ベンチマーク通知を表示
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                color: #FFD700;
                padding: 20px;
                border-radius: 15px;
                border: 3px solid #FF4500;
                text-align: center;
                z-index: 2000;
                box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
                animation: fadeInOut 4s ease-in-out;
                max-width: 80%;
                font-size: 16px;
            `;
            
            notification.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #FF4500; font-size: 20px;">🎉 深度 ${benchmark.depth}m 達成！</h3>
                <div style="font-size: 18px; margin: 10px 0; color: #FFD700;">${benchmark.name}</div>
                <div style="font-size: 14px; color: #87CEEB;">${benchmark.description}</div>
            `;
            
            // CSSアニメーションを追加
            if (!document.getElementById('benchmarkAnimationStyle')) {
                const style = document.createElement('style');
                style.id = 'benchmarkAnimationStyle';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // 4秒後に除去
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 4000);
        }

        function updateUI() {
            document.getElementById('depth').textContent = game.depth;
            document.getElementById('temperature').textContent = Math.floor(game.temperature);
            document.getElementById('drillSpeed').textContent = game.drillSpeed.toFixed(1);
            document.getElementById('drillEnergy').style.width = `${Math.max(0, (game.drillDurability / game.drillMaxDurability) * 100)}%`;
            
            // ベンチマークチェック
            const currentBenchmark = depthBenchmarks.find(b => 
                game.depth >= b.depth && game.lastBenchmarkDepth < b.depth
            );
            
            if (currentBenchmark) {
                showBenchmarkNotification(currentBenchmark);
                game.lastBenchmarkDepth = currentBenchmark.depth;
            }
            
            // 耐久度による色変更
            const durabilityRatio = game.drillDurability / game.drillMaxDurability;
            if (durabilityRatio < 0.3) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #8B0000, #FF0000)';
            } else if (durabilityRatio < 0.6) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF8C00, #FFD700)';
            } else {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF4500, #FFD700)';
            }
            
            // オイルマネーストック数とスター状態の表示
            document.getElementById('oilMoneyCount').textContent = game.oilMoneyStock;
            
            // コンボ数の表示
            document.getElementById('comboCount').textContent = game.comboCount;
            
            // 今回のプレイ距離表示
            document.getElementById('currentPlayDistance').textContent = Math.floor(game.maxDepth);
            
            // スター状態の表示更新
            if (game.starMode) {
                document.getElementById('beamStatus').textContent = `⭐ スター状態 ⭐ (${Math.ceil(game.starModeTimer)}秒)`;
                document.getElementById('beamStatus').style.color = '#FFD700';
                document.getElementById('beamEnergy').style.width = `${(game.starModeTimer / game.starModeDuration) * 100}%`;
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #FFD700, #FFA500)';
            } else if (game.oilMoneyStock > 0) {
                document.getElementById('beamStatus').textContent = 'スペースキーでスター状態開始！';
                document.getElementById('beamStatus').style.color = '#90EE90';
                document.getElementById('beamEnergy').style.width = '100%';
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #32CD32, #90EE90)';
            } else {
                document.getElementById('beamStatus').textContent = 'オイルマネーを集めよう！';
                document.getElementById('beamStatus').style.color = '#FFFFFF';
                document.getElementById('beamEnergy').style.width = '0%';
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #654321, #8B4513)';
            }
        }
        
        function gameLoop() {
            if (!game.gameRunning) return;
            
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }
        
        
        async function gameOver(reason = null) {
            game.gameRunning = false;
            document.getElementById('finalDepth').textContent = game.maxDepth;
            document.getElementById('maxTemp').textContent = Math.floor(game.maxTemp);
            
            // ゲームオーバーの理由を表示
            const gameOverDiv = document.getElementById('gameOver');
            const h2 = gameOverDiv.querySelector('h2');
            if (reason) {
                h2.textContent = reason;
            } else {
                h2.textContent = 'ゲームオーバー';
            }
            
            // スコア計算
            const score = Math.floor(game.maxDepth * 10 + game.maxTemp * 5 + game.oilMoneyStock * 100 + game.comboCount * 50);
            
            // 上位5位に入るかチェック
            const isTopRecord = await recordManager.checkIfTopRecord(game.maxDepth);
            
            // 名前入力セクションの表示制御
            const playerNameSection = document.getElementById('playerNameSection');
            if (isTopRecord) {
                playerNameSection.style.display = 'block';
                const saveMessage = document.createElement('div');
                saveMessage.textContent = '🎉 上位5位に入りました！名前を入力してください';
                saveMessage.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    background: rgba(255, 215, 0, 0.9);
                    color: black;
                    padding: 10px;
                    border-radius: 5px;
                    font-size: 14px;
                    font-weight: bold;
                `;
                gameOverDiv.appendChild(saveMessage);
                
                setTimeout(() => {
                    if (saveMessage.parentNode) {
                        saveMessage.parentNode.removeChild(saveMessage);
                    }
                }, 5000);
            } else {
                playerNameSection.style.display = 'none';
            }
            
            // 記録を保存
            try {
                await recordManager.saveRecord({
                    depth: game.maxDepth,
                    temperature: game.maxTemp,
                    oilMoneyStock: game.oilMoneyStock,
                    comboCount: game.comboCount,
                    score: score
                });
                
                // 保存完了メッセージを表示
                if (!isTopRecord) {
                    const saveMessage = document.createElement('div');
                    saveMessage.textContent = '記録を保存しました！';
                    saveMessage.style.cssText = `
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: rgba(0, 255, 0, 0.8);
                        color: white;
                        padding: 10px;
                        border-radius: 5px;
                        font-size: 14px;
                    `;
                    gameOverDiv.appendChild(saveMessage);
                    
                    setTimeout(() => {
                        if (saveMessage.parentNode) {
                            saveMessage.parentNode.removeChild(saveMessage);
                        }
                    }, 3000);
                }
                
            } catch (error) {
                console.error('記録保存に失敗:', error);
                const errorMessage = document.createElement('div');
                errorMessage.textContent = '記録保存に失敗しました';
                errorMessage.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    background: rgba(255, 0, 0, 0.8);
                    color: white;
                    padding: 10px;
                    border-radius: 5px;
                    font-size: 14px;
                `;
                gameOverDiv.appendChild(errorMessage);
                
                setTimeout(() => {
                    if (errorMessage.parentNode) {
                        errorMessage.parentNode.removeChild(errorMessage);
                    }
                }, 3000);
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        function resetGame() {
            // 既存のゲームを完全に停止
            game.gameRunning = false;
            
            // 既存の音楽とアニメーションを停止
            if (audioManager.musicLoop) {
                audioManager.stopBackgroundMusic();
            }
            if (game.starMode) {
                audioManager.stopStarModeBGM();
            }
            
            // 少し待ってから新しいゲームを開始（既存のループを確実に停止）
            setTimeout(() => {
                // ゲーム状態を完全にリセット
                game = {
                    depth: 0,
                    energy: 0,
                    temperature: 15,
                    drillX: 600,
                    drillY: 0,
                    drillSpeed: 4.0, // 初期速度を4.0倍に増加
                    drillDurability: 100,
                    drillMaxDurability: 100,
                    oilMoneyStock: 0,
                    starMode: false,
                    starModeTimer: 0,
                    starModeDuration: 5,
                    lastBenchmarkDepth: 0,
                    comboCount: 0,
                    comboTimer: 0,
                    comboMaxTime: 3,
                    cooling: 1,
                    particles: [],
                    rocks: [],
                    steamVents: [],
                    magmaPools: [],
                    faults: [], // 断層
                    oilPockets: [], // オイルポケット
                    oilMoney: [], // オイルマネー
                    beams: [], // ビーム
                    moles: [], // もぐら
                    pipeSegments: [], // ドリルパイプのセグメント
                    maxDepth: 0,
                    maxTemp: 15,
                    gameRunning: true,
                    cameraY: 0,
                    generatedSpawns: new Set(),
                    upgrades: {
                        speed: { level: 1, cost: 10 },
                        durability: { level: 1, cost: 15 },
                        cooling: { level: 1, cost: 20 }
                    }
                };
                
                // UI要素を隠す
                document.getElementById('gameOver').style.display = 'none';
                
                // ランキング画面が表示されていたら隠す
                const recordsList = document.getElementById('recordsList');
                if (recordsList) {
                    recordsList.style.display = 'none';
                }
                
                // 新しいBGMを開始
                if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
                    audioManager.audioContext.resume();
                }
                audioManager.startBackgroundMusic();
                
                // UIを更新
                updateUI();
                
                // 新しいゲームループを開始
                gameLoop();
            }, 50);
        }
        
        // アップグレード機能は現在UIにないため、一旦コメントアウトします。
        /*
        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (game.energy >= game.upgrades.speed.cost) {
                game.energy -= game.upgrades.speed.cost;
                game.drillSpeed += 0.8;  // 0.3 → 0.8に増加
                game.upgrades.speed.level++;
                game.upgrades.speed.cost = Math.floor(game.upgrades.speed.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeDurability').addEventListener('click', () => {
            if (game.energy >= game.upgrades.durability.cost) {
                game.energy -= game.upgrades.durability.cost;
                game.drillMaxDurability += 50;
                game.drillDurability += 50;
                game.upgrades.durability.level++;
                game.upgrades.durability.cost = Math.floor(game.upgrades.durability.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeCooling').addEventListener('click', () => {
            if (game.energy >= game.upgrades.cooling.cost) {
                game.energy -= game.upgrades.cooling.cost;
                game.cooling += 0.5;
                game.upgrades.cooling.level++;
                game.upgrades.cooling.cost = Math.floor(game.upgrades.cooling.cost * 2);
                updateUI();
            }
        });
        */
        
        // スター状態開始/ビーム発射関数
        function handleSpaceKey() {
            if (!game.gameRunning) return;
            
            if (game.starMode) {
                // スター状態中：ビーム発射
                const beam = new Beam(game.drillX, game.drillY + 60, Math.PI / 2);
                game.beams.push(beam);
                
                // 泥水発射エフェクト
                for (let i = 0; i < 15; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 25,
                        game.drillY + 50 + (Math.random() - 0.5) * 25,
                        Math.random() < 0.7 ? 'rock' : 'steam'
                    ));
                }
                
                // 画面効果
                canvas.style.filter = 'brightness(1.3) sepia(0.5) saturate(1.5)';
                setTimeout(() => canvas.style.filter = '', 150);
                
                // ビーム発射音を再生
                audioManager.playSound('beam');
                
                console.log('⭐ スター状態ビーム発射！');
            } else if (game.oilMoneyStock > 0) {
                // スター状態開始
                game.starMode = true;
                game.starModeTimer = game.starModeDuration;
                game.oilMoneyStock -= 1;
                
                // スター状態開始エフェクト
                for (let i = 0; i < 50; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 100,
                        game.drillY + (Math.random() - 0.5) * 100,
                        'spark'
                    ));
                }
                
                // 豪華な画面効果
                canvas.style.filter = 'brightness(1.8) saturate(2) hue-rotate(45deg)';
                setTimeout(() => canvas.style.filter = '', 1000);
                
                // スター状態開始音を再生
                audioManager.playSound('starMode');
                
                // スター状態専用BGMを開始
                audioManager.startStarModeBGM();
                
                console.log('⭐ スター状態開始！ 5秒間無制限ビーム！');
            }
        }

        // キー入力
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            
            // スペースキーでスター状態開始/ビーム発射
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                handleSpaceKey();
            }
            
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = false;
        });
        
        // タッチ操作対応
        let touchStartX = null;
        let touchStartTime = null;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartTime = Date.now();
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (touchStartX !== null) {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                
                if (diff < -30) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else if (diff > 30) {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }
            }
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', (e) => {
            // タップ判定（短時間で移動距離が少ない場合）
            if (touchStartX !== null && touchStartTime !== null) {
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                const touchEndX = e.changedTouches[0].clientX;
                const touchDistance = Math.abs(touchEndX - touchStartX);
                
                // タップ判定: 300ms以下かつ移動距離30px以下
                if (touchDuration < 300 && touchDistance < 30 && game.gameRunning) {
                    handleSpaceKey();
                }
            }
            
            touchStartX = null;
            touchStartTime = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });
        
        // モバイル用タッチボタン
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const spaceButton = document.getElementById('spaceButton');
        
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        
        // スペースボタン（泥水ビーム）
        spaceButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleSpaceKey();
        });
        
        spaceButton.addEventListener('click', (e) => {
            e.preventDefault();
            handleSpaceKey();
        });
        
        // マウスでも動作するように
        leftButton.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
        leftButton.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
        rightButton.addEventListener('mousedown', () => keys['ArrowRight'] = true);
        rightButton.addEventListener('mouseup', () => keys['ArrowRight'] = false);
        
        // 音声コントロール
        document.getElementById('muteButton').addEventListener('click', () => {
            audioManager.toggleMute();
            const button = document.getElementById('muteButton');
            button.textContent = audioManager.muted ? '🔇 音声OFF' : '🔊 音声ON';
        });
        
        // ゲーム開始時にリサイズ
        async function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game.gameRunning = true;
            
            // AudioContextを開始（ユーザーインタラクション後に必要）
            if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
                audioManager.audioContext.resume();
            }
            
            // 総掘削距離を読み込んで表示
            try {
                const totalDistance = await recordManager.getTotalDistance();
                document.getElementById('totalDistance').textContent = totalDistance.toLocaleString();
            } catch (error) {
                console.error('総掘削距離の読み込みエラー:', error);
                document.getElementById('totalDistance').textContent = '0';
            }
            
            // バックグラウンドミュージック開始
            audioManager.startBackgroundMusic();
            
            resizeGame(); // リサイズを実行
            gameLoop();
        }
        
        // プレイヤー名更新機能
        function updatePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            if (name) {
                recordManager.setPlayerName(name);
                alert('プレイヤー名を「' + name + '」に設定しました');
                nameInput.value = '';
            }
        }
        
        // ランキング表示機能
        async function showRecords() {
            const recordsList = document.getElementById('recordsList');
            const topRecordsDiv = document.getElementById('topRecords');
            const playerRecordsDiv = document.getElementById('playerRecords');
            
            // 表示切り替え
            recordsList.style.display = recordsList.style.display === 'none' ? 'block' : 'none';
            
            if (recordsList.style.display === 'block') {
                try {
                    // トップ5の記録を取得（深度ベース）
                    const topRecords = await recordManager.getTopRecordsByDepth(5);
                    displayDepthRecords(topRecords, topRecordsDiv, true);
                    
                    // 総掘削距離を取得
                    const totalDistance = await recordManager.getTotalDistance();
                    
                    // 総掘削距離表示を追加
                    const totalDistanceDiv = document.createElement('div');
                    totalDistanceDiv.innerHTML = `
                        <div style="background: rgba(135, 206, 235, 0.2); padding: 10px; margin: 10px 0; border-radius: 5px; text-align: center;">
                            <h4 style="margin: 0; color: #87CEEB;">🌍 全プレイヤー総掘削距離</h4>
                            <div style="font-size: 18px; font-weight: bold; color: #FFD700;">${totalDistance.toLocaleString()} m</div>
                        </div>
                    `;
                    
                    // 既存の総距離表示を削除してから追加
                    const existingTotal = topRecordsDiv.querySelector('.total-distance');
                    if (existingTotal) {
                        existingTotal.remove();
                    }
                    totalDistanceDiv.classList.add('total-distance');
                    topRecordsDiv.appendChild(totalDistanceDiv);
                    
                    // プレイヤーの記録メッセージ
                    playerRecordsDiv.innerHTML = '<p>個人記録はランキング上位5位のみ表示されます</p>';
                    
                } catch (error) {
                    console.error('記録取得エラー:', error);
                    topRecordsDiv.innerHTML = '<p>記録の読み込みに失敗しました</p>';
                    playerRecordsDiv.innerHTML = '<p>記録の読み込みに失敗しました</p>';
                }
            }
        }
        
        // 深度ベースの記録表示ヘルパー関数
        function displayDepthRecords(records, container, showRank) {
            if (!records || records.length === 0) {
                container.innerHTML = '<p>記録がありません</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div class="record-item">
                        ${showRank ? `<div class="record-rank">${index + 1}位</div>` : ''}
                        <div class="record-info">
                            <div><strong>${record.playerName}</strong></div>
                            <div>🏆 深度: ${record.depth}m</div>
                            <div>💰 オイルマネー: ${record.oilMoneyStock} | 🔥 コンボ: ${record.comboCount}</div>
                            <div>📅 日時: ${date}</div>
                        </div>
                        <div class="record-score">${record.depth}m</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // 記録表示ヘルパー関数（旧版・互換性のため残存）
        function displayRecords(records, container, showRank) {
            if (!records || records.length === 0) {
                container.innerHTML = '<p>記録がありません</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div class="record-item">
                        ${showRank ? `<div class="record-rank">${index + 1}位</div>` : ''}
                        <div class="record-info">
                            <div><strong>${record.playerName}</strong></div>
                            <div>深度: ${record.depth}m</div>
                            <div>オイルマネー: ${record.oilMoneyStock} | コンボ: ${record.comboCount}</div>
                            <div>日時: ${date}</div>
                        </div>
                        <div class="record-score">${record.score}pt</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // タイトル画面のランキング表示機能
        async function showTitleRanking() {
            const titleRanking = document.getElementById('titleRanking');
            const titleRankingList = document.getElementById('titleRankingList');
            const titleTotalDistance = document.getElementById('titleTotalDistance');
            
            titleRanking.style.display = 'block';
            titleRankingList.innerHTML = '<p>読み込み中...</p>';
            
            try {
                // トップ5の記録を取得
                const topRecords = await recordManager.getTopRecordsByDepth(5);
                displayTitleRanking(topRecords, titleRankingList);
                
                // 総掘削距離を取得
                const totalDistance = await recordManager.getTotalDistance();
                titleTotalDistance.innerHTML = `
                    <div style="background: rgba(135, 206, 235, 0.2); padding: 10px; border-radius: 5px; text-align: center;">
                        <div style="color: #87CEEB; font-size: 14px;">🌍 全プレイヤー総掘削距離</div>
                        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">${totalDistance.toLocaleString()} m</div>
                    </div>
                `;
                
            } catch (error) {
                console.error('タイトル画面ランキング取得エラー:', error);
                titleRankingList.innerHTML = '<p>ランキングの読み込みに失敗しました</p>';
                titleTotalDistance.innerHTML = '';
            }
        }
        
        function hideTitleRanking() {
            document.getElementById('titleRanking').style.display = 'none';
        }
        
        // タイトル画面専用のランキング表示関数
        function displayTitleRanking(records, container) {
            if (!records || records.length === 0) {
                container.innerHTML = '<p>まだ記録がありません</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div class="title-record-item">
                        <div class="title-record-rank">${index + 1}位</div>
                        <div class="title-record-info">
                            <div><strong>${record.playerName}</strong></div>
                            <div style="font-size: 14px; color: #ccc;">
                                日時: ${date}
                            </div>
                        </div>
                        <div class="title-record-depth">${record.depth}m</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // タイトルに戻る機能
        function backToTitle() {
            // ゲームオーバー画面を隠す
            document.getElementById('gameOver').style.display = 'none';
            
            // タイトル画面を表示
            document.getElementById('startScreen').style.display = 'flex';
            
            // ランキング画面が表示されていたら隠す
            document.getElementById('titleRanking').style.display = 'none';
            
            // ゲーム記録画面が表示されていたら隠す
            const recordsList = document.getElementById('recordsList');
            if (recordsList) {
                recordsList.style.display = 'none';
            }
            
            // BGMを停止
            if (audioManager.musicLoop) {
                audioManager.stopBackgroundMusic();
            }
            
            // スター状態BGMを停止
            if (game.starMode) {
                audioManager.stopStarModeBGM();
            }
        }
        
        // ブラジルまでの距離ページ関連の定数
        const TOTAL_DISTANCE_TO_BRAZIL = 18000000; // 18,000 km in meters
        
        // ブラジルまでの距離ページ表示
        async function showBrazilDistance() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('brazilDistancePage').style.display = 'block';
            
            // 地球のグラフィックを描画
            drawEarthGraphic();
            
            // 距離情報を更新
            await updateBrazilDistanceInfo();
            
            // ランキングを読み込み
            await loadBrazilPageRanking();
        }
        
        // ブラジルまでの距離ページを隠す
        function hideBrazilDistance() {
            document.getElementById('brazilDistancePage').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        // 地球のグラフィックを描画（半分に割って掘削の様子を表現）
        function drawEarthGraphic() {
            const canvas = document.getElementById('earthCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 200;
            
            // 地球を描画
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 地球の影
            ctx.beginPath();
            ctx.arc(centerX + 5, centerY + 5, radius, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();
            
            // 地球の外側（海）
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#2196F3';
            ctx.fill();
            
            // 地球の大陸（簡略化）
            ctx.fillStyle = '#4CAF50';
            
            // 日本周辺（上部）
            ctx.beginPath();
            ctx.arc(centerX, centerY - 120, 20, 0, 2 * Math.PI);
            ctx.fill();
            
            // 南米（下部）
            ctx.beginPath();
            ctx.arc(centerX, centerY + 120, 25, 0, 2 * Math.PI);
            ctx.fill();
            
            // アジア大陸（上部）
            ctx.beginPath();
            ctx.arc(centerX - 30, centerY - 80, 35, 0, 2 * Math.PI);
            ctx.fill();
            
            // 地球の内部構造を表現（半分に切った断面）
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI, false); // 上半分のみ
            ctx.clip();
            
            // 地殻（茶色）
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#8B4513';
            ctx.fill();
            
            // マントル（オレンジ）
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 30, 0, 2 * Math.PI);
            ctx.fillStyle = '#FF4500';
            ctx.fill();
            
            // 外核（赤）
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 80, 0, 2 * Math.PI);
            ctx.fillStyle = '#DC143C';
            ctx.fill();
            
            // 内核（黄色）
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 120, 0, 2 * Math.PI);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
            
            ctx.restore();
            
            // 掘削トンネルの描画
            drawDrillingTunnel(ctx, centerX, centerY, radius);
            
            // 分離線（地球を半分に割った線）
            ctx.beginPath();
            ctx.moveTo(centerX - radius, centerY);
            ctx.lineTo(centerX + radius, centerY);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 秋田県の位置（地球の上）
            ctx.beginPath();
            ctx.arc(centerX, centerY - radius - 10, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#FF4500';
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ブラジルの位置（地球の下）
            ctx.beginPath();
            ctx.arc(centerX, centerY + radius + 10, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#32CD32';
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ラベル
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('秋田県', centerX, centerY - radius - 20);
            ctx.fillText('ブラジル', centerX, centerY + radius + 30);
            
            // 内部構造のラベル
            ctx.fillStyle = '#FFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('地殻', centerX - 170, centerY + 10);
            ctx.fillText('マントル', centerX - 140, centerY + 10);
            ctx.fillText('外核', centerX - 100, centerY + 10);
            ctx.fillText('内核', centerX - 60, centerY + 10);
        }
        
        // 掘削トンネルの描画
        async function drawDrillingTunnel(ctx, centerX, centerY, radius) {
            try {
                const totalDistance = await recordManager.getTotalDistance();
                const progressKm = Math.floor(totalDistance / 1000);
                const maxDistance = 18000; // 18,000 km
                
                // 掘削の進捗を計算
                const progress = Math.min(progressKm / maxDistance, 1.0);
                
                // 秋田県からブラジルまでの垂直な掘削経路
                const startX = centerX;
                const startY = centerY - radius - 10; // 秋田県の位置
                const endX = centerX;
                const endY = centerY + radius + 10; // ブラジルの位置
                
                const totalPathLength = endY - startY;
                const currentPathLength = progress * totalPathLength;
                const currentX = startX;
                const currentY = startY + currentPathLength;
                
                // 掘削トンネルの描画
                if (currentPathLength > 0) {
                    ctx.save();
                    
                    // 掘削トンネルの外縁（太い暗い線）
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.strokeStyle = '#8B0000';
                    ctx.lineWidth = 8;
                    ctx.stroke();
                    
                    // 掘削トンネル（細い赤線）
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.strokeStyle = '#FF6B6B';
                    ctx.lineWidth = 6;
                    ctx.stroke();
                    
                    // 現在地を星で表示
                    if (currentPathLength > 5) {
                        drawStar(ctx, currentX, currentY, 8, '#FFD700', '#FF4500');
                    }
                    
                    ctx.restore();
                }
                
            } catch (error) {
                console.error('掘削トンネル描画エラー:', error);
            }
        }
        
        // 星を描画する関数
        function drawStar(ctx, x, y, size, fillColor, strokeColor) {
            ctx.save();
            ctx.translate(x, y);
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5;
                const outerRadius = size;
                const innerRadius = size * 0.4;
                
                if (i === 0) {
                    ctx.moveTo(0, -outerRadius);
                } else {
                    ctx.lineTo(Math.sin(angle) * outerRadius, -Math.cos(angle) * outerRadius);
                }
                
                const innerAngle = angle + (2 * Math.PI) / 5;
                ctx.lineTo(Math.sin(innerAngle) * innerRadius, -Math.cos(innerAngle) * innerRadius);
            }
            ctx.closePath();
            
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }
        
        // 距離情報を更新
        async function updateBrazilDistanceInfo() {
            try {
                const totalDistance = await recordManager.getTotalDistance();
                const progressKm = Math.floor(totalDistance / 1000);
                const remainingKm = Math.max(0, 18000 - progressKm);
                const progressPercentage = Math.min(100, (progressKm / 18000) * 100);
                
                document.getElementById('currentDistance').textContent = progressKm.toLocaleString();
                document.getElementById('remainingDistance').textContent = remainingKm.toLocaleString();
                document.getElementById('progressPercentage').textContent = progressPercentage.toFixed(2);
                document.getElementById('progressBar').style.width = progressPercentage + '%';
                
                // 地球のグラフィックを再描画（掘削進捗を反映）
                drawEarthGraphic();
                
            } catch (error) {
                console.error('距離情報の更新エラー:', error);
                document.getElementById('currentDistance').textContent = '0';
                document.getElementById('remainingDistance').textContent = '18,000';
                document.getElementById('progressPercentage').textContent = '0';
            }
        }
        
        
        // ブラジルページのランキング読み込み
        async function loadBrazilPageRanking() {
            try {
                const topRecords = await recordManager.getTopRecordsByDepth(5);
                displayBrazilPageRanking(topRecords);
            } catch (error) {
                console.error('ブラジルページランキング読み込みエラー:', error);
                document.getElementById('brazilRankingList').innerHTML = '<p>ランキングの読み込みに失敗しました</p>';
            }
        }
        
        // ブラジルページのランキング表示
        function displayBrazilPageRanking(records) {
            const container = document.getElementById('brazilRankingList');
            
            if (!records || records.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #ccc; margin: 20px 0;">まだ記録がありません</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div style="background: rgba(255, 255, 255, 0.1); margin: 8px 0; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; min-height: 60px;">
                        <div style="font-weight: bold; color: #FFD700; min-width: 40px; font-size: 16px;">${index + 1}位</div>
                        <div style="flex: 1; margin-left: 12px; text-align: left;">
                            <div style="font-size: 16px; font-weight: bold; margin-bottom: 4px; color: #FFFFFF;">${record.playerName}</div>
                            <div style="font-size: 14px; color: #ccc; line-height: 1.3;">
                                ${date}
                            </div>
                        </div>
                        <div style="font-weight: bold; color: #FF4500; font-size: 18px; text-align: right;">${record.depth}m</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // ページ読み込み時にプレイヤー名を設定
        window.addEventListener('load', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.value = recordManager.playerName;
        });
    </script>
</body>
</html>