<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœ°ç†±äº•æˆ¸æ˜å‰Šã‚²ãƒ¼ãƒ </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #8B4513 20%, #654321 40%, #3E2723 60%, #D2691E 80%, #FF4500 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1200px, 95vw);
            height: min(800px, 85vh);
            max-width: 100%;
            max-height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: min(20px, 2vw);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: min(15px, 2vw);
            border-radius: min(10px, 1.5vw);
            border: 2px solid #FF4500;
            font-size: min(14px, 3vw);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #stats {
            top: min(20px, 2vh);
            left: min(20px, 2vw);
            min-width: min(200px, 40vw);
        }

        #controls {
            top: 20px;
            right: 20px;
            pointer-events: all;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #FF4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
        }

        button {
            background: #FF4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            background: #FF6347;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        .stat-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
        }

        .energy-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #FFD700;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #FF4500, #FFD700);
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        h1, h2 {
            margin: 10px 0;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        .upgrade-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #228B22;
            margin-top: 5px;
        }

        .upgrade-btn:hover {
            background: #32CD32;
        }

        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 1000;
        }

        #startScreen h1 {
            font-size: 48px;
            color: #FF4500;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .instructions {
            margin: 20px 0;
            font-size: 18px;
            line-height: 1.5;
        }

        .warning {
            color: #FF6347;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #mobileControls {
            position: absolute;
            bottom: min(20px, 2vh);
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: min(20px, 3vw);
            z-index: 1000;
        }

        .touch-button {
            width: min(80px, 15vw);
            height: min(80px, 15vw);
            background: rgba(255, 69, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-size: min(24px, 4vw);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            touch-action: manipulation;
        }

        .touch-button:active {
            background: rgba(255, 69, 0, 1);
            transform: scale(0.95);
        }

        @media (max-width: 768px) or (max-height: 600px) {
            #mobileControls {
                display: flex;
            }
            
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
            }
            
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
            }
            
            #gameCanvas {
                width: 100% !important;
                height: 100% !important;
                object-fit: contain;
            }
            
            .info-panel {
                font-size: max(10px, 2.2vw);
                padding: max(6px, 1.2vw);
                min-width: max(150px, 30vw);
                border-radius: max(5px, 1vw);
            }
            
            #stats {
                top: max(10px, 1vh);
                left: max(10px, 1vw);
                transform: scale(0.9);
                transform-origin: top left;
            }
            
            #mobileControls {
                bottom: max(10px, 1vh);
                gap: max(15px, 2vw);
            }
            
            .touch-button {
                width: max(60px, 12vw);
                height: max(60px, 12vw);
                font-size: max(18px, 3.5vw);
                border-width: 2px;
            }
            
            /* ç¸¦å‘ãã‚¹ãƒãƒ›ç”¨ */
            @media (orientation: portrait) {
                #gameContainer {
                    height: 100vh;
                }
                
                .info-panel {
                    font-size: max(11px, 2.8vw);
                }
                
                .touch-button {
                    width: max(70px, 14vw);
                    height: max(70px, 14vw);
                }
            }
            
            /* æ¨ªå‘ãã‚¹ãƒãƒ›ç”¨ */
            @media (orientation: landscape) {
                #gameContainer {
                    width: 100vw;
                    height: 100vh;
                }
                
                .info-panel {
                    font-size: max(9px, 2vh);
                    padding: max(5px, 1vh);
                }
                
                #stats {
                    transform: scale(0.8);
                }
                
                .touch-button {
                    width: max(50px, 8vh);
                    height: max(50px, 8vh);
                    font-size: max(16px, 3vh);
                }
                
                #mobileControls {
                    bottom: max(5px, 1vh);
                }
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="1000"></canvas>
        <div id="ui">
            <div id="stats" class="info-panel">
                <h2>æ˜å‰ŠçŠ¶æ³</h2>
                <div>æ·±åº¦: <span class="stat-value" id="depth">0</span> m</div>
                <div>æ¸©åº¦: <span class="stat-value" id="temperature">15</span> â„ƒ</div>
                <div>æ˜å‰Šé€Ÿåº¦: <span class="stat-value" id="drillSpeed">2.5</span> m/s</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="drillEnergy"></div>
                </div>
                <div style="font-size: 12px;">ãƒ‰ãƒªãƒ«è€ä¹…åº¦</div>
                
                <div class="energy-bar" style="margin-top: 10px;">
                    <div class="energy-fill" id="beamEnergy"></div>
                </div>
                <div style="font-size: 12px;">æ³¥æ°´ãƒ“ãƒ¼ãƒ  <span id="beamStatus">å……é›»ä¸­...</span></div>
                <div id="warningText" class="warning" style="display: none;">âš ï¸ é«˜æ¸©æ³¨æ„ï¼</div>
            </div>
        </div>
        
        <div id="startScreen">
            <h1>ğŸ”¥ åœ°ç†±äº•æˆ¸æ˜å‰Šã‚²ãƒ¼ãƒ  ğŸ”¥</h1>
            <div class="instructions">
                <p>è‡ªå‹•ã§åœ°çƒã®æ·±éƒ¨ã¸æ˜ã‚Šé€²ã¿ã¾ã™ï¼</p>
                <p>â† â†’ ã‚­ãƒ¼ã§æ˜å‰Šæ©Ÿã‚’å·¦å³ã«ç§»å‹•ã—ã¦éšœå®³ç‰©ã‚’é¿ã‘ã‚ˆã†</p>
                <p>å²©ã«ã¶ã¤ã‹ã‚‹ã¨ãƒ‰ãƒªãƒ«ãŒæ¶ˆè€—ã—ã¾ã™</p>
                <p>ğŸ›¢ï¸ ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆã§ãƒ‰ãƒªãƒ«è€ä¹…åº¦ãŒå›å¾©ï¼</p>
                <p>ğŸ’§ æ³¥æ°´ãƒ“ãƒ¼ãƒ ã‚²ãƒ¼ã‚¸ãŒæºœã¾ã£ãŸã‚‰ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§éšœå®³ç‰©ã‚’ç ´å£Šï¼</p>
                <p>ã‚ˆã‚Šæ·±ãæ˜ã‚‹ã»ã©é«˜æ¸©ã«ãªã‚Šã€å¤šãã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’ç²å¾—ã§ãã¾ã™</p>
            </div>
            <button onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        </div>
        
        <div id="gameOver">
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <p>æœ€çµ‚æ·±åº¦: <span id="finalDepth">0</span> m</p>
            <p>æœ€é«˜æ¸©åº¦: <span id="maxTemp">0</span> â„ƒ</p>
            <button onclick="resetGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
        </div>
        
        <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div id="mobileControls">
            <div class="touch-button" id="leftButton">â†</div>
            <div class="touch-button" id="rightButton">â†’</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // PDCãƒ“ãƒƒãƒˆç”»åƒã®èª­ã¿è¾¼ã¿
        const drillBitImage = new Image();
        drillBitImage.src = 'Gemini_Generated_Image_sfxgpisfxgpisfxg.png';
        let imageLoaded = false;
        drillBitImage.onload = function() {
            imageLoaded = true;
        };
        
        // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            const isMobile = window.innerWidth <= 768 || window.innerHeight <= 600;
            
            if (isMobile) {
                // ãƒ¢ãƒã‚¤ãƒ«ã§ã¯ç”»é¢å…¨ä½“ã‚’ä½¿ç”¨
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.transform = 'none';
                canvas.style.objectFit = 'contain';
            } else {
                // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã¯é©åˆ‡ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                const scaleX = containerRect.width / 1200;
                const scaleY = containerRect.height / 1000;
                const scale = Math.min(scaleX, scaleY);
                
                canvas.style.transform = `scale(${scale})`;
                canvas.style.transformOrigin = 'top left';
                canvas.style.width = '1200px';
                canvas.style.height = '1000px';
                canvas.style.objectFit = 'initial';
            }
            
            // ã‚²ãƒ¼ãƒ å†…åº§æ¨™ã‚‚èª¿æ•´
            if (game.drillX === 600) { // åˆæœŸä½ç½®ã®å ´åˆ
                game.drillX = 1200 * 0.5; // ç”»é¢ä¸­å¤®
            }
        }
        
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeGame, 100);
        });
        
        let game = {
            depth: 0,
            temperature: 15,
            drillX: 600,
            drillY: 0,
            drillSpeed: 2.5, // åˆæœŸé€Ÿåº¦ã‚’2.5å€ã«å¢—åŠ 
            drillDurability: 100,
            drillMaxDurability: 100,
            beamEnergy: 0, // ãƒ“ãƒ¼ãƒ ã‚¨ãƒãƒ«ã‚®ãƒ¼
            beamMaxEnergy: 100, // æœ€å¤§ãƒ“ãƒ¼ãƒ ã‚¨ãƒãƒ«ã‚®ãƒ¼
            beamChargeRate: 0.15, // ãƒ“ãƒ¼ãƒ å……é›»é€Ÿåº¦
            beams: [], // ç™ºå°„ä¸­ã®ãƒ“ãƒ¼ãƒ 
            particles: [],
            rocks: [],
            steamVents: [],
            magmaPools: [],
            faults: [], // æ–­å±¤
            oilPockets: [], // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆ
            moles: [], // ã‚‚ãã‚‰
            pipeSegments: [], // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
            maxDepth: 0,
            maxTemp: 15,
            gameRunning: false,
            cameraY: 0
        };
        
        const keys = {};
        
        class Beam {
            constructor(x, y, direction) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.direction = direction; // è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
                this.speed = 15; // ãƒ“ãƒ¼ãƒ é€Ÿåº¦
                this.width = 8; // ãƒ“ãƒ¼ãƒ å¹…
                this.length = 60; // ãƒ“ãƒ¼ãƒ é•·ã•
                this.life = 1.0; // ãƒ“ãƒ¼ãƒ ã®ç”Ÿå­˜æ™‚é–“
                this.power = 50; // ç ´å£ŠåŠ›
                this.particles = [];
                this.hasHit = false;
            }
            
            update() {
                // ãƒ“ãƒ¼ãƒ ã®ç§»å‹•
                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;
                
                // ç”Ÿå­˜æ™‚é–“ã®æ¸›å°‘
                this.life -= 0.02;
                
                // ãƒ“ãƒ¼ãƒ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç”Ÿæˆ
                if (Math.random() < 0.8) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.width,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 1,
                        size: Math.random() * 3 + 1
                    });
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    p.size *= 0.95;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
                
                // éšœå®³ç‰©ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
                this.checkCollisions();
            }
            
            checkCollisions() {
                if (this.hasHit) return;
                
                // å²©ã¨ã®è¡çª
                for (let i = game.rocks.length - 1; i >= 0; i--) {
                    const rock = game.rocks[i];
                    if (!rock.hit && this.isCollidingWithRock(rock)) {
                        this.destroyRock(rock, i);
                        this.hasHit = true;
                        this.life = 0.3; // çŸ­ã„æ®‹å­˜æ™‚é–“
                        break;
                    }
                }
                
                // æ–­å±¤ã¨ã®è¡çª
                for (let i = game.faults.length - 1; i >= 0; i--) {
                    const fault = game.faults[i];
                    if (this.isCollidingWithFault(fault)) {
                        this.destroyFault(fault, i);
                        this.hasHit = true;
                        this.life = 0.3;
                        break;
                    }
                }
                
                // ã‚‚ãã‚‰ã¨ã®è¡çª
                for (let i = game.moles.length - 1; i >= 0; i--) {
                    const mole = game.moles[i];
                    if (this.isCollidingWithMole(mole)) {
                        this.destroyMole(mole, i);
                        this.hasHit = true;
                        this.life = 0.3;
                        break;
                    }
                }
            }
            
            isCollidingWithRock(rock) {
                const distance = Math.sqrt(
                    Math.pow(this.x - rock.x, 2) + 
                    Math.pow(this.y - rock.y, 2)
                );
                return distance < (Math.max(rock.width, rock.height) / 2 + this.width);
            }
            
            isCollidingWithFault(fault) {
                return fault.checkCrackCollision(this.x, this.y, this.width * 2, this.width * 2);
            }
            
            isCollidingWithMole(mole) {
                const distance = Math.sqrt(
                    Math.pow(this.x - mole.x, 2) + 
                    Math.pow(this.y - mole.y, 2)
                );
                return distance < (Math.max(mole.width, mole.height) / 2 + this.width);
            }
            
            destroyRock(rock, index) {
                // å²©ã‚’é…åˆ—ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
                game.rocks.splice(index, 1);
                
                // ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 30; i++) {
                    game.particles.push(new Particle(
                        rock.x + (Math.random() - 0.5) * rock.width,
                        rock.y + (Math.random() - 0.5) * rock.height,
                        Math.random() < 0.6 ? 'rock' : 'spark'
                    ));
                }
                
                // ç”»é¢ã®æºã‚ŒåŠ¹æœ
                canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                setTimeout(() => canvas.style.transform = '', 250);
                
                console.log(`å²©çŸ³ã‚’ç ´å£Šï¼æ®‹ã‚Šå²©çŸ³æ•°: ${game.rocks.length}`);
            }
            
            destroyFault(fault, index) {
                // æ–­å±¤ã‚’é…åˆ—ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
                game.faults.splice(index, 1);
                
                // æ–­å±¤ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 35; i++) {
                    game.particles.push(new Particle(
                        fault.startX + Math.random() * 100 - 50,
                        fault.y + Math.random() * 100 - 50,
                        Math.random() < 0.5 ? 'spark' : 'rock'
                    ));
                }
                
                // ã‚ˆã‚Šå¼·ã„ç”»é¢æºã‚Œ
                canvas.style.transform = `translate(${Math.random() * 25 - 12.5}px, ${Math.random() * 25 - 12.5}px)`;
                setTimeout(() => canvas.style.transform = '', 300);
                
                console.log(`æ–­å±¤ã‚’ç ´å£Šï¼æ®‹ã‚Šæ–­å±¤æ•°: ${game.faults.length}`);
            }
            
            destroyMole(mole, index) {
                // ã‚‚ãã‚‰ã‚’é…åˆ—ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
                game.moles.splice(index, 1);
                
                // ã‚‚ãã‚‰ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆåœŸã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
                for (let i = 0; i < 20; i++) {
                    game.particles.push(new Particle(
                        mole.x + (Math.random() - 0.5) * mole.width,
                        mole.y + (Math.random() - 0.5) * mole.height,
                        'rock'
                    ));
                }
                
                console.log(`ã‚‚ãã‚‰ã‚’é™¤å»ï¼æ®‹ã‚Šã‚‚ãã‚‰æ•°: ${game.moles.length}`);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                const startScreenY = this.startY - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                
                // æ³¥æ°´ãƒ“ãƒ¼ãƒ æœ¬ä½“ï¼ˆèŒ¶è‰²ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                const beamGradient = ctx.createLinearGradient(
                    this.startX, startScreenY,
                    this.x, screenY
                );
                beamGradient.addColorStop(0, `rgba(139, 69, 19, ${this.life * 0.4})`); // æ¿ƒã„èŒ¶è‰²
                beamGradient.addColorStop(0.5, `rgba(160, 82, 45, ${this.life * 0.8})`); // ä¸­é–“ã®èŒ¶è‰²
                beamGradient.addColorStop(1, `rgba(210, 180, 140, ${this.life})`); // æ˜ã‚‹ã„èŒ¶è‰²
                
                ctx.strokeStyle = beamGradient;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#8B4513';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, startScreenY);
                ctx.lineTo(this.x, screenY);
                ctx.stroke();
                
                // æ³¥æ°´ãƒ“ãƒ¼ãƒ ã®ä¸­å¿ƒç·šï¼ˆæ°´åˆ†ã‚’è¡¨ç¾ï¼‰
                ctx.strokeStyle = `rgba(135, 206, 235, ${this.life * 0.6})`; // æ°´è‰²
                ctx.lineWidth = this.width * 0.2;
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#87CEEB';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, startScreenY);
                ctx.lineTo(this.x, screenY);
                ctx.stroke();
                
                // æ³¥æ°´ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆèŒ¶è‰²ã¨æ°´è‰²ã®æ··åˆï¼‰
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life * this.life;
                    // ãƒ©ãƒ³ãƒ€ãƒ ã§æ³¥ã‹æ°´ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                    ctx.fillStyle = Math.random() < 0.7 ? '#8B4513' : '#87CEEB';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.type = type;

                if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() * -10) - 5;
                    this.size = Math.random() * 4 + 1;
                    this.gravity = 0.4;
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = Math.random() * -5 - 2;
                    this.size = Math.random() * 5 + 2;
                    this.gravity = 0.3;
                }
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= 0.03;
                this.size *= 0.97;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'rock') {
                    ctx.fillStyle = '#8B4513';
                } else if (this.type === 'steam') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                } else if (this.type === 'lava') {
                    ctx.fillStyle = '#FF4500';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF4500';
                } else if (this.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFD700';
                }
                
                const screenY = this.y - game.cameraY;
                ctx.beginPath();
                ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Rock {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 100 + 50;
                this.height = Math.random() * 60 + 30;
                this.hardness = Math.random() * 3 + 1;
                this.hit = false;
                this.points = [];
                // Generate irregular shape points
                const numPoints = Math.floor(Math.random() * 5) + 8; // 8-12 points
                const angleStep = (Math.PI * 2) / numPoints;
                for (let i = 0; i < numPoints; i++) {
                    const angle = i * angleStep;
                    const radius = (Math.random() * 0.3 + 0.7) * Math.min(this.width, this.height) / 2;
                    this.points.push({
                        x: radius * Math.cos(angle),
                        y: radius * Math.sin(angle)
                    });
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                if (this.hit) {
                    ctx.globalAlpha = 0.7;
                }
                
                // ç¡¬è³ªå²©çŸ³ã®è‰² - é»’ã‹ã‚‰æ¿ƒã„ã‚°ãƒ¬ãƒ¼ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const gradient = ctx.createLinearGradient(0, -this.height / 2, 0, this.height / 2);
                const baseOpacity = 0.9; // ã‚ˆã‚Šä¸é€æ˜ã«
                gradient.addColorStop(0, `rgba(64, 64, 64, ${baseOpacity})`); // æ¿ƒã„ã‚°ãƒ¬ãƒ¼
                gradient.addColorStop(0.3, `rgba(32, 32, 32, ${baseOpacity})`); // ã‚ˆã‚Šæš—ã„ã‚°ãƒ¬ãƒ¼
                gradient.addColorStop(0.7, `rgba(16, 16, 16, ${baseOpacity})`); // éå¸¸ã«æš—ã„ã‚°ãƒ¬ãƒ¼
                gradient.addColorStop(1, `rgba(8, 8, 8, ${baseOpacity})`); // ã»ã¼é»’
                ctx.fillStyle = gradient;

                // ä¸è¦å‰‡ãªç¡¬è³ªå²©çŸ³ã®å½¢çŠ¶ã‚’æç”»
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();

                // ç¡¬è³ªå²©çŸ³ã®çµæ™¶æ§‹é€ ã‚’è¡¨ç¾ï¼ˆå°ã•ãªæ˜ã‚‹ã„ç‚¹ï¼‰
                ctx.fillStyle = `rgba(128, 128, 128, 0.4)`;
                for (let i = 0; i < 8; i++) {
                    const x = (Math.random() - 0.5) * this.width * 0.8;
                    const y = (Math.random() - 0.5) * this.height * 0.8;
                    const size = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // é‰±ç‰©ã®å¾®ç´°ãªå…‰æ²¢ï¼ˆéå¸¸ã«æ§ãˆã‚ï¼‰
                ctx.fillStyle = `rgba(192, 192, 192, 0.1)`;
                for (let i = 0; i < 3; i++) {
                    const x = (Math.random() - 0.5) * this.width * 0.6;
                    const y = (Math.random() - 0.5) * this.height * 0.6;
                    const size = Math.random() * 1.5 + 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ç¡¬è³ªå²©çŸ³ã®æš—ã„è¼ªéƒ­ç·š
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#2F2F2F'; // æš—ã„ã‚°ãƒ¬ãƒ¼ã®è¼ªéƒ­
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç¡¬åº¦ãŒé«˜ã„å ´åˆã®è¿½åŠ çš„ãªæš—ã•
                if (this.hardness > 2) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2 * (this.hardness - 2)})`;
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (let i = 1; i < this.points.length; i++) {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        class SteamVent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = true;
                this.timer = 0;
                this.radius = 20;
            }
            
            update() {
                this.timer++;
                if (this.timer % 3 === 0 && this.active) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 20,
                        this.y,
                        'steam'
                    ));
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);

                // è’¸æ°—å­”ã®ç©´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // è’¸æ°—å­”ã®å…‰
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // è’¸æ°—ã®è¡¨ç¾ (ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã§æç”»ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯è¿½åŠ ã®è¦–è¦šåŠ¹æœã®ã¿)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }
        
        class OilPocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 80 + 60; // 60-140px
                this.height = Math.random() * 60 + 40; // 40-100px
                this.hit = false;
                this.collected = false;
                this.particles = [];
                this.animationTime = 0;
                this.oilLevel = 1.0; // ã‚ªã‚¤ãƒ«ã®é‡ï¼ˆ1.0 = æº€ã‚¿ãƒ³ï¼‰
                this.healAmount = 30 + Math.random() * 20; // 30-50ã®å›å¾©é‡
            }
            
            update() {
                this.animationTime++;
                
                // ã‚ªã‚¤ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç”Ÿæˆ
                if (!this.collected && Math.random() < 0.1) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.01;
                    p.size *= 0.99;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                if (!this.collected) {
                    // ã‚­ãƒ£ãƒƒãƒ—ãƒ­ãƒƒã‚¯ï¼ˆä¸Šéƒ¨ã®ç¡¬ã„å²©ç›¤å±¤ï¼‰- ã‚ˆã‚Šè‡ªç„¶ãªå½¢çŠ¶
                    const capRockHeight = this.height * 0.25;
                    
                    // ã‚­ãƒ£ãƒƒãƒ—ãƒ­ãƒƒã‚¯ã®ä¸è¦å‰‡ãªå½¢çŠ¶ã‚’ä½œæˆ
                    ctx.fillStyle = '#708090'; // ã‚ˆã‚Šè‡ªç„¶ãªã‚°ãƒ¬ãƒ¼
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, -this.height/2);
                    
                    // ä¸è¦å‰‡ãªä¸Šé¢
                    for (let i = 0; i <= 8; i++) {
                        const x = (-this.width/2) + (this.width * i / 8);
                        const yVariation = (Math.sin(this.x * 0.01 + i * 0.8) + Math.cos(this.y * 0.005 + i * 1.2)) * 3;
                        ctx.lineTo(x, -this.height/2 + yVariation);
                    }
                    
                    // å³å´
                    ctx.lineTo(this.width/2, -this.height/2 + capRockHeight);
                    
                    // ä¸è¦å‰‡ãªä¸‹é¢ï¼ˆã‚ªã‚¤ãƒ«å±¤ã¨ã®å¢ƒç•Œï¼‰
                    for (let i = 8; i >= 0; i--) {
                        const x = (-this.width/2) + (this.width * i / 8);
                        const yVariation = (Math.sin(this.x * 0.008 + i * 1.1) + Math.cos(this.y * 0.006 + i * 0.9)) * 5;
                        ctx.lineTo(x, -this.height/2 + capRockHeight + yVariation);
                    }
                    
                    // å·¦å´
                    ctx.lineTo(-this.width/2, -this.height/2);
                    ctx.fill();
                    
                    // ã‚­ãƒ£ãƒƒãƒ—ãƒ­ãƒƒã‚¯ã®å±¤ç†æ§‹é€ 
                    ctx.strokeStyle = 'rgba(105, 105, 105, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 1; i < 4; i++) {
                        const layerY = -this.height/2 + (capRockHeight * i / 4);
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + 5, layerY);
                        for (let j = 0; j <= 6; j++) {
                            const x = (-this.width/2 + 5) + ((this.width - 10) * j / 6);
                            const variation = Math.sin(this.x * 0.02 + j * 0.5) * 2;
                            ctx.lineTo(x, layerY + variation);
                        }
                        ctx.stroke();
                    }
                    
                    // å¤šå­”è³ªãªè²¯ç•™å±¤ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªå½¢çŠ¶ï¼‰
                    const reservoirTop = -this.height/2 + capRockHeight;
                    const reservoirHeight = this.height * 0.75;
                    
                    // èƒŒæ™¯ã®å²©çŸ³å±¤
                    const rockGradient = ctx.createLinearGradient(0, reservoirTop, 0, reservoirTop + reservoirHeight);
                    rockGradient.addColorStop(0, '#D2B48C'); // ç ‚å²©è‰²
                    rockGradient.addColorStop(0.5, '#F4A460'); // ã‚ˆã‚Šæ˜ã‚‹ã„ç ‚å²©
                    rockGradient.addColorStop(1, '#CD853F'); // æ¿ƒã„ç ‚å²©
                    ctx.fillStyle = rockGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, reservoirTop);
                    
                    // ä¸è¦å‰‡ãªå¢ƒç•Œç·š
                    for (let i = 0; i <= 10; i++) {
                        const x = (-this.width/2) + (this.width * i / 10);
                        const topVariation = Math.sin(this.x * 0.01 + i * 0.7) * 3;
                        const bottomVariation = Math.cos(this.x * 0.012 + i * 0.9) * 4;
                        
                        if (i === 0) {
                            ctx.moveTo(x, reservoirTop + topVariation);
                        } else if (i === 10) {
                            ctx.lineTo(x, reservoirTop + topVariation);
                            ctx.lineTo(x, this.height/2 + bottomVariation);
                            
                            // åº•é¢
                            for (let j = 10; j >= 0; j--) {
                                const bottomX = (-this.width/2) + (this.width * j / 10);
                                const bottomVar = Math.cos(this.x * 0.012 + j * 0.9) * 4;
                                ctx.lineTo(bottomX, this.height/2 + bottomVar);
                            }
                            
                            ctx.lineTo(-this.width/2, reservoirTop);
                        } else {
                            ctx.lineTo(x, reservoirTop + topVariation);
                        }
                    }
                    ctx.fill();
                    
                    // ã‚ªã‚¤ãƒ«ï¼ˆåŸæ²¹ï¼‰ã®è¡¨ç¾
                    if (this.oilLevel > 0) {
                        const oilHeight = reservoirHeight * 0.8 * this.oilLevel;
                        
                        // ã‚ªã‚¤ãƒ«ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                        const oilGradient = ctx.createLinearGradient(0, this.height/2 - oilHeight, 0, this.height/2);
                        oilGradient.addColorStop(0, 'rgba(139, 69, 19, 0.9)'); // æ¿ƒã„èŒ¶è‰²
                        oilGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.95)'); // é»’
                        oilGradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.9)'); // æ¿ƒã„èŒ¶è‰²
                        oilGradient.addColorStop(1, 'rgba(139, 69, 19, 0.8)'); // ã‚„ã‚„æ˜ã‚‹ã„èŒ¶è‰²
                        
                        ctx.fillStyle = oilGradient;
                        ctx.fillRect(-this.width/2 + 8, this.height/2 - oilHeight, this.width - 16, oilHeight);
                        
                        // ã‚ªã‚¤ãƒ«ã®è¡¨é¢ã®æ³¢ç´‹åŠ¹æœ
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 1;
                        const surfaceY = this.height/2 - oilHeight;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + 8, surfaceY);
                        for (let i = 0; i <= 8; i++) {
                            const x = (-this.width/2 + 8) + ((this.width - 16) * i / 8);
                            const wave = Math.sin(this.animationTime * 0.05 + i * 0.5) * 1.5;
                            ctx.lineTo(x, surfaceY + wave);
                        }
                        ctx.stroke();
                        
                        // ã‚ªã‚¤ãƒ«ã®å…‰æ²¢
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        ctx.fillRect(-this.width/2 + 10, surfaceY, this.width - 20, 3);
                    }
                    
                    // å¤šå­”è³ªæ§‹é€ ã®è¡¨ç¾ï¼ˆå°ã•ãªç©´ï¼‰
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    for (let i = 0; i < 15; i++) {
                        const poreX = (Math.random() - 0.5) * (this.width - 20);
                        const poreY = reservoirTop + Math.random() * reservoirHeight * 0.8;
                        const poreSize = Math.random() * 2 + 1;
                        ctx.beginPath();
                        ctx.arc(poreX, poreY, poreSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // ç™ºè¦‹ãƒãƒ¼ã‚¯ï¼ˆã‚ˆã‚Šæ§ãˆã‚ã«ï¼‰
                    if (Math.abs(this.x - game.drillX) < 80 && Math.abs(this.y - game.drillY) < 80) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillText('âš«', 0, -this.height/2 - 15);
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // æ¡æ˜æ¸ˆã¿ã®è·¡ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªç©´ï¼‰
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)');
                    gradient.addColorStop(1, 'rgba(139, 69, 19, 0.2)');
                    ctx.fillStyle = gradient;
                    
                    ctx.beginPath();
                    // ä¸è¦å‰‡ãªæ¡æ˜è·¡
                    for (let i = 0; i <= 16; i++) {
                        const angle = (Math.PI * 2 * i) / 16;
                        const radius = (this.width/2.5) + Math.sin(i * 0.7) * 8;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius * 0.7;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.fill();
                }
                
                // ã‚ªã‚¤ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆã‚ˆã‚Šç¾å®Ÿçš„ã«ï¼‰
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life * 0.6;
                    ctx.fillStyle = '#654321'; // ã‚ˆã‚Šè‡ªç„¶ãªæ²¹ã®è‰²
                    ctx.beginPath();
                    ctx.arc(p.x - this.x, p.y - screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }

        class Mole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.width = 40;
                this.height = 30;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.animationTime = 0;
                this.tunnelX = x;
                this.surprised = false;
                this.fleeing = false;
            }
            
            update() {
                this.animationTime++;
                
                // ãƒ‰ãƒªãƒ«ã¨ã®è·é›¢ã‚’è¨ˆç®—
                const distance = Math.sqrt(
                    Math.pow(this.x - game.drillX, 2) + 
                    Math.pow(this.y - game.drillY, 2)
                );
                
                // ãƒ‰ãƒªãƒ«ãŒè¿‘ã¥ã„ãŸã‚‰é©šã„ã¦é€ƒã’ã‚‹
                if (distance < 150 && !this.fleeing) {
                    this.surprised = true;
                    this.fleeing = true;
                    this.vx = (this.x - game.drillX) * 0.1;
                    this.vy = -2;
                }
                
                if (this.fleeing) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.95;
                    this.vy += 0.1;
                } else {
                    // é€šå¸¸ã®ç§»å‹•
                    this.x += Math.sin(this.animationTime * 0.05) * 0.5 * this.direction;
                    
                    // ç”»é¢ç«¯ã§æ–¹å‘è»¢æ›
                    if (this.x < 50 || this.x > canvas.width - 50) {
                        this.direction *= -1;
                    }
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                // ã‚‚ãã‚‰ã®ç©´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ã‚‚ãã‚‰ã®ä½“ (ã‚ˆã‚Šæœ‰æ©Ÿçš„ãªå½¢çŠ¶ã¨æ¯›ä¸¦ã¿)
                ctx.fillStyle = '#4B3621';
                ctx.strokeStyle = '#3A2B1A';
                ctx.lineWidth = 1;
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // æ¯›ä¸¦ã¿ã®è¡¨ç¾ (ç°¡å˜ãªç·šã§)
                for(let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                    ctx.lineTo(radius * Math.cos(angle) * 1.2, radius * Math.sin(angle) * 1.2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.stroke();
                }
                
                // ã‚‚ãã‚‰ã®é ­
                ctx.fillStyle = '#5C4033';
                ctx.beginPath();
                ctx.ellipse(this.direction * 15, -5, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // é¼» (ã‚ˆã‚Šãƒªã‚¢ãƒ«ã«)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(this.direction * 22, -5, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç›® (è¡¨æƒ…è±Šã‹ã«)
                if (this.surprised) {
                    // é©šã„ãŸç›®
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 4, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // é€šå¸¸ã®ç›®
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // æ‰‹ (ã‚ˆã‚Šè©³ç´°ã«)
                ctx.fillStyle = '#4B3621';
                ctx.beginPath();
                ctx.ellipse(-10, 5, 6, 8, -0.3, 0, Math.PI * 2);
                ctx.ellipse(10, 5, 6, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // åœŸã®ç²’å­
                if (!this.fleeing && Math.random() < 0.3) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 30,
                        this.y + 10,
                        'rock'
                    ));
                }
                
                // é©šããƒãƒ¼ã‚¯
                if (this.surprised && !this.fleeing) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', 0, -25);
                }
                
                ctx.restore();
            }
        }
        
        class Fault {
            constructor(y) {
                this.y = y;
                this.startX = Math.random() * (canvas.width - 400) + 200; // æ–­å±¤ã®é–‹å§‹Xä½ç½®
                this.length = Math.random() * 400 + 300; // æ–­å±¤ã®é•·ã•ï¼ˆ300-700pxï¼‰
                this.angle = (Math.random() * 60 - 30) * Math.PI / 180; // -30åº¦ã‹ã‚‰+30åº¦ã®è§’åº¦
                this.warningWidth = 60; // è­¦å‘Šç¯„å›²ã®å¹…
                this.particles = [];
                this.crackPoints = [];
                
                // æ–œã‚ã®äº€è£‚ã®å½¢çŠ¶ã‚’ç”Ÿæˆ
                const numPoints = Math.floor(Math.random() * 8) + 12; // 12-19 points
                for (let i = 0; i <= numPoints; i++) {
                    const progress = i / numPoints;
                    
                    // åŸºæœ¬ã®æ–œã‚ãƒ©ã‚¤ãƒ³
                    const baseX = Math.cos(this.angle) * this.length * progress;
                    const baseY = Math.sin(this.angle) * this.length * progress;
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªãšã‚Œã‚’è¿½åŠ ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªäº€è£‚ã«ï¼‰
                    const randomOffset = (Math.random() - 0.5) * 40;
                    const perpX = -Math.sin(this.angle) * randomOffset;
                    const perpY = Math.cos(this.angle) * randomOffset;
                    
                    this.crackPoints.push({ 
                        x: baseX + perpX, 
                        y: baseY + perpY 
                    });
                }
            }
            
            // äº€è£‚éƒ¨åˆ†ã¨ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆæ–œã‚å¯¾å¿œï¼‰
            checkCrackCollision(drillX, drillY, drillWidth, drillHeight) {
                const crackThickness = 15; // äº€è£‚ã®åšã¿
                
                for (let i = 0; i < this.crackPoints.length - 1; i++) {
                    const p1 = this.crackPoints[i];
                    const p2 = this.crackPoints[i + 1];
                    
                    // ç·šåˆ†ã®ä¸¡ç«¯ï¼ˆæ–œã‚ã®äº€è£‚ï¼‰
                    const x1 = this.startX + p1.x;
                    const y1 = this.y + p1.y;
                    const x2 = this.startX + p2.x;
                    const y2 = this.y + p2.y;
                    
                    // ãƒ‰ãƒªãƒ«ã®çŸ©å½¢ã¨ç·šåˆ†ã®äº¤å·®åˆ¤å®š
                    if (this.lineIntersectsRect(x1, y1, x2, y2, 
                        drillX - drillWidth/2, drillY - drillHeight/2, 
                        drillWidth, drillHeight, crackThickness)) {
                        return true;
                    }
                }
                return false;
            }
            
            // ç·šåˆ†ã¨çŸ©å½¢ã®äº¤å·®åˆ¤å®šï¼ˆå¤ªã„ç·šã¨ã—ã¦æ‰±ã†ï¼‰
            lineIntersectsRect(x1, y1, x2, y2, rectX, rectY, rectWidth, rectHeight, thickness) {
                // å¤ªã„ç·šã‚’çŸ©å½¢ã¨ã—ã¦æ‰±ã†
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return false;
                
                // æ­£è¦åŒ–ã•ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«
                const nx = dx / length;
                const ny = dy / length;
                
                // å‚ç›´ãƒ™ã‚¯ãƒˆãƒ«
                const px = -ny * thickness / 2;
                const py = nx * thickness / 2;
                
                // å¤ªã„ç·šã®4ã¤ã®è§’
                const corners = [
                    { x: x1 + px, y: y1 + py },
                    { x: x1 - px, y: y1 - py },
                    { x: x2 + px, y: y2 + py },
                    { x: x2 - px, y: y2 - py }
                ];
                
                // ä»»æ„ã®è§’ãŒãƒ‰ãƒªãƒ«ã®çŸ©å½¢å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                for (const corner of corners) {
                    if (corner.x >= rectX && corner.x <= rectX + rectWidth &&
                        corner.y >= rectY && corner.y <= rectY + rectHeight) {
                        return true;
                    }
                }
                
                return false;
            }
            
            update() {
                // è­¦å‘Šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆæ–œã‚æ–­å±¤ç”¨ï¼‰
                if (Math.random() < 0.3) {
                    // æ–­å±¤ç·šä¸Šã®ä»»æ„ã®ç‚¹ã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
                    const progress = Math.random();
                    const baseX = Math.cos(this.angle) * this.length * progress;
                    const baseY = Math.sin(this.angle) * this.length * progress;
                    
                    this.particles.push({
                        x: this.startX + baseX + (Math.random() - 0.5) * this.warningWidth,
                        y: this.y + baseY + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= 0.02;
                    p.size *= 0.98;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                // æ–­å±¤ã®å¢ƒç•Œã‚’è¨ˆç®—ï¼ˆæ–œã‚ç·šã®å ´åˆï¼‰
                const endX = this.startX + Math.cos(this.angle) * this.length;
                const endY = this.y + Math.sin(this.angle) * this.length;
                const screenEndY = endY - game.cameraY;
                
                // ç”»é¢å¤–ã®å ´åˆã¯æç”»ã—ãªã„
                const minY = Math.min(screenY, screenEndY);
                const maxY = Math.max(screenY, screenEndY);
                if (maxY < -50 || minY > canvas.height + 50) return;
                
                // è­¦å‘Šã‚¾ãƒ¼ãƒ³ï¼ˆæ–­å±¤ã®ä¸¡å´ã«æ²¿ã£ã¦ï¼‰
                if (minY < canvas.height && maxY > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.4;
                    
                    // æ–­å±¤ã«æ²¿ã£ãŸè­¦å‘Šã‚¨ãƒªã‚¢ã‚’æç”»
                    const perpX = -Math.sin(this.angle) * this.warningWidth;
                    const perpY = Math.cos(this.angle) * this.warningWidth;
                    
                    // è­¦å‘Šã‚¾ãƒ¼ãƒ³ã®å››è§’å½¢
                    const warningPoints = [
                        { x: this.startX + perpX, y: screenY + perpY },
                        { x: this.startX - perpX, y: screenY - perpY },
                        { x: endX - perpX, y: screenEndY - perpY },
                        { x: endX + perpX, y: screenEndY + perpY }
                    ];
                    
                    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è­¦å‘Šã‚¾ãƒ¼ãƒ³
                    const gradient = ctx.createLinearGradient(
                        this.startX - perpX, screenY - perpY,
                        this.startX + perpX, screenY + perpY
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                    gradient.addColorStop(0.4, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(0.6, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(warningPoints[0].x, warningPoints[0].y);
                    for (let i = 1; i < warningPoints.length; i++) {
                        ctx.lineTo(warningPoints[i].x, warningPoints[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                
                // æ–­å±¤æœ¬ä½“ï¼ˆæ–œã‚ã®äº€è£‚ã¨ã—ã¦æç”»ï¼‰
                ctx.save();
                ctx.strokeStyle = '#333333'; // äº€è£‚ã®è‰²
                ctx.lineWidth = 12; // äº€è£‚ã®å¤ªã•ã‚’å°‘ã—å¤ªã
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#000';

                ctx.beginPath();
                if (this.crackPoints.length > 0) {
                    const firstPoint = this.crackPoints[0];
                    ctx.moveTo(this.startX + firstPoint.x, this.y + firstPoint.y - game.cameraY);
                    for (let i = 1; i < this.crackPoints.length; i++) {
                        const point = this.crackPoints[i];
                        ctx.lineTo(this.startX + point.x, this.y + point.y - game.cameraY);
                    }
                }
                ctx.stroke();

                // äº€è£‚ã®å…‰ã‚‹ç¸
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#FF0000';
                ctx.beginPath();
                if (this.crackPoints.length > 0) {
                    const firstPoint = this.crackPoints[0];
                    ctx.moveTo(this.startX + firstPoint.x, this.y + firstPoint.y - game.cameraY);
                    for (let i = 1; i < this.crackPoints.length; i++) {
                        const point = this.crackPoints[i];
                        ctx.lineTo(this.startX + point.x, this.y + point.y - game.cameraY);
                    }
                }
                ctx.stroke();
                
                // è­¦å‘Šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                
                // è­¦å‘Šãƒ†ã‚­ã‚¹ãƒˆï¼ˆæ–­å±¤ã®ä¸­å¤®ã«è¡¨ç¤ºï¼‰
                const centerX = this.startX + Math.cos(this.angle) * this.length / 2;
                const centerY = this.y + Math.sin(this.angle) * this.length / 2;
                const screenCenterY = centerY - game.cameraY;
                
                if (screenCenterY > 40 && screenCenterY < canvas.height - 40 && 
                    centerX > 0 && centerX < canvas.width) {
                    ctx.save();
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF0000';
                    
                    // ãƒ†ã‚­ã‚¹ãƒˆã‚’æ–­å±¤ã®è§’åº¦ã«åˆã‚ã›ã¦å›è»¢
                    ctx.translate(centerX, screenCenterY - 30);
                    ctx.rotate(this.angle);
                    ctx.fillText('âš  æ–­å±¤ âš ', 0, 0);
                    ctx.restore();
                }
            }
        }
        
        function generateTerrain() {
            // ç”»é¢ä¸‹ç«¯ã‹ã‚‰å°‘ã—å…ˆã®ä½ç½®ã§éšœå®³ç‰©ã‚’ç”Ÿæˆ
            const spawnY = game.cameraY + canvas.height + 200;
            const spawnCheck = Math.floor(spawnY / 100) * 100;
            
            if (!game.generatedSpawns) game.generatedSpawns = new Set();
            
            if (!game.generatedSpawns.has(spawnCheck)) {
                game.generatedSpawns.add(spawnCheck);
                
                // ã‚‚ãã‚‰ï¼ˆ500-2000mã®éƒ¨åˆ†ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth >= 500 && game.depth < 2000) {
                    if (Math.random() < 0.3) {
                        game.moles.push(new Mole(
                            Math.random() * (canvas.width - 100) + 50,
                            spawnY
                        ));
                    }
                }
                
                // å²©ã®ç”Ÿæˆ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                const rockCount = Math.floor(Math.random() * 2) + 1 + Math.floor(game.depth / 2000);
                for (let i = 0; i < rockCount; i++) {
                    const rock = new Rock(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    );
                    rock.hardness += game.depth / 3000;
                    game.rocks.push(rock);
                }
                
                // è’¸æ°—å­”ï¼ˆ1500mä»¥é™ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth > 1500 && Math.random() < 0.2 + game.depth / 8000) {
                    game.steamVents.push(new SteamVent(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆï¼ˆ800mä»¥é™ã€2000mæœªæº€ï¼‰ - æ¯”è¼ƒçš„æµ…ã„å±¤ã«é…ç½®
                if (game.depth >= 800 && game.depth < 2000 && Math.random() < 0.15) {
                    game.oilPockets.push(new OilPocket(
                        Math.random() * (canvas.width - 200) + 100,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // æ–­å±¤ï¼ˆ2500mä»¥é™ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth > 2500) {
                    const faultChance = 0.1 + (game.depth - 2500) / 15000;
                    if (Math.random() < faultChance) {
                        game.faults.push(new Fault(spawnY + Math.random() * 100));
                    }
                }
            }
        }
        
        function updateGame() {
            if (!game.gameRunning) return;

            // --- START OF NEW EFFECTS ---

            // 1. Continuous screen shake for drilling vibration
            const shakeIntensity = Math.min(game.drillSpeed / 10, 1.5);
            const shakeX = (Math.random() - 0.5) * shakeIntensity;
            const shakeY = (Math.random() - 0.5) * shakeIntensity;
            canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;

            // 2. Continuous drilling particle generation
            const particleCount = Math.ceil(game.drillSpeed); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å¢—åŠ 
            for (let i = 0; i < particleCount; i++) {
                let particleType = 'rock';
                if (game.depth > 5000) {
                    particleType = 'lava';
                } else if (game.depth > 3000) {
                    if (Math.random() < 0.5) particleType = 'lava';
                }
                game.particles.push(new Particle(
                    game.drillX + (Math.random() - 0.5) * 30,
                    game.drillY + 60, // ãƒ‰ãƒªãƒ«ã®å…ˆç«¯ã‚ˆã‚Šå°‘ã—ä¸‹ã‹ã‚‰ç™ºç”Ÿ
                    particleType
                ));
            }

            // 3. Spark generation at high temperatures
            if (game.temperature > 800) {
                if (Math.random() < (game.temperature - 800) / 1000) {
                    game.particles.push(new Particle(game.drillX, game.drillY + 40, 'spark'));
                }
            }

            // --- END OF NEW EFFECTS ---
            
            // ãƒ‘ã‚¤ãƒ—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¿½åŠ ï¼ˆ10ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ï¼‰
            if (game.pipeSegments.length === 0 || 
                game.drillY - game.pipeSegments[game.pipeSegments.length - 1].y > 10) {
                game.pipeSegments.push({
                    x: game.drillX,
                    y: game.drillY,
                    angle: Math.atan2(
                        game.drillX - (game.pipeSegments.length > 0 ? 
                            game.pipeSegments[game.pipeSegments.length - 1].x : game.drillX),
                        10
                    )
                });
            }
            
            // è‡ªå‹•æ˜å‰Šï¼ˆä¸‹æ–¹å‘ã¸ã®ç§»å‹•ï¼‰
            game.drillY += game.drillSpeed;
            game.depth = Math.floor(game.drillY / 10);
            game.maxDepth = Math.max(game.maxDepth, game.depth);
            
            // ã‚«ãƒ¡ãƒ©ã®è¿½å¾“
            game.cameraY = game.drillY - 100;
            
            // å·¦å³ç§»å‹•ï¼ˆé€Ÿåº¦åˆ¶é™ï¼‰
            const baseMoveSpeed = 1.5; // åŸºæœ¬ç§»å‹•é€Ÿåº¦ã‚’ã•ã‚‰ã«ä½ãè¨­å®š
            const moveSpeed = baseMoveSpeed + (game.drillSpeed * 0.1); // æ˜å‰Šé€Ÿåº¦ã®å½±éŸ¿ã‚’æœ€å°é™ã«
            const maxMoveSpeed = 2.5; // æœ€å¤§ç§»å‹•é€Ÿåº¦ã‚’ã•ã‚‰ã«åˆ¶é™
            const actualMoveSpeed = Math.min(moveSpeed, maxMoveSpeed);
            
            if (keys['ArrowLeft'] && game.drillX > 50) {
                game.drillX -= actualMoveSpeed;
            }
            if (keys['ArrowRight'] && game.drillX < canvas.width - 50) {
                game.drillX += actualMoveSpeed;
            }
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚­ãƒ¼å…¥åŠ›ã®ç¢ºèª
            // console.log('Keys:', keys, 'DrillX:', game.drillX);
            
            // æ¸©åº¦ä¸Šæ˜‡
            game.temperature = 15 + game.depth * 0.035;
            if (game.depth > 3000) {
                game.temperature += (game.depth - 3000) * 0.05; // 3000mä»¥é™ã¯æ€¥æ¿€ã«æ¸©åº¦ä¸Šæ˜‡
            }
            game.maxTemp = Math.max(game.maxTemp, game.temperature);
            
            // è¡çªãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            let hitObstacle = false;
            
            // è­¦å‘Šè¡¨ç¤º
            document.getElementById('warningText').style.display = 
                game.temperature > 1000 ? 'block' : 'none';
            
            // åœ°å½¢ç”Ÿæˆ
            generateTerrain();
            
            // ã‚‚ãã‚‰ã®æ›´æ–°ã¨è¡çªãƒã‚§ãƒƒã‚¯
            game.moles.forEach(mole => {
                mole.update();
                
                // ã‚‚ãã‚‰ã¨ã®è¡çªï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ã¯å°‘ãªã„ï¼‰
                if (!mole.fleeing &&
                    Math.abs(mole.x - game.drillX) < 30 &&
                    Math.abs(mole.y - game.drillY) < 30) {
                    
                    game.drillDurability -= 5;
                    hitObstacle = true;
                    mole.surprised = true;
                    mole.fleeing = true;
                    
                    // ã‹ã‚ã„ã„è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 5; i++) {
                        game.particles.push(new Particle(mole.x, mole.y, 'rock'));
                    }
                }
            });
            
            // å²©ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
            game.rocks.forEach(rock => {
                if (!rock.hit &&
                    Math.abs(rock.x - game.drillX) < (rock.width/2 + 20) &&
                    Math.abs(rock.y - game.drillY) < (rock.height/2 + 30)) {
                    
                    rock.hit = true;
                    game.drillDurability -= rock.hardness * 3;
                    hitObstacle = true;
                    
                    // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (å²©ã¨ç«èŠ±)
                    for (let i = 0; i < 15; i++) {
                        game.particles.push(new Particle(game.drillX, game.drillY + 40, i < 10 ? 'rock' : 'spark'));
                    }
                    
                    // ç”»é¢ã®æºã‚ŒåŠ¹æœï¼ˆå¼·åŒ–ï¼‰
                    canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    setTimeout(() => canvas.style.transform = '', 150);
                }
            });
            
            // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
            game.oilPockets.forEach(oilPocket => {
                oilPocket.update();
                
                if (!oilPocket.collected &&
                    Math.abs(oilPocket.x - game.drillX) < (oilPocket.width/2 + 20) &&
                    Math.abs(oilPocket.y - game.drillY) < (oilPocket.height/2 + 30)) {
                    
                    oilPocket.collected = true;
                    
                    // ãƒ‰ãƒªãƒ«è€ä¹…åº¦å›å¾©
                    const oldDurability = game.drillDurability;
                    game.drillDurability += oilPocket.healAmount;
                    game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
                    
                    // å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 20; i++) {
                        game.particles.push(new Particle(
                            oilPocket.x + (Math.random() - 0.5) * 60,
                            oilPocket.y + (Math.random() - 0.5) * 40,
                            'steam'
                        ));
                    }
                    
                    // ç”»é¢ã®å…‰ã‚‹åŠ¹æœ
                    canvas.style.filter = 'brightness(1.3) sepia(0.3)';
                    setTimeout(() => canvas.style.filter = '', 500);
                    
                    console.log(`ã‚ªã‚¤ãƒ«æ¡æ˜ï¼è€ä¹…åº¦ ${Math.floor(oldDurability)} â†’ ${Math.floor(game.drillDurability)} (+${Math.floor(oilPocket.healAmount)})`);
                }
            });

            // è’¸æ°—å­”ãƒœãƒ¼ãƒŠã‚¹
            game.steamVents.forEach(vent => {
                vent.update();
                const distance = Math.sqrt(
                    Math.pow(vent.x - game.drillX, 2) + 
                    Math.pow(vent.y - game.drillY, 2)
                );
                if (distance < 50) {
                    // è¿‘ãã«ã„ã‚‹ã¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¢—åŠ 
                    if (Math.random() < 0.3) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'steam'));
                    }
                }
            });
            
            // ãƒã‚°ãƒæºœã¾ã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸
            game.magmaPools.forEach(pool => {
                pool.update();
                if (Math.abs(pool.x - game.drillX) < pool.width/2 &&
                    Math.abs(pool.y - game.drillY) < 50) {
                    game.drillDurability -= 0.5;
                    hitObstacle = true;
                    
                    if (Math.random() < 0.2) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'lava'));
                    }
                }
            });
            
            // ãƒ“ãƒ¼ãƒ ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®å……é›»
            if (game.beamEnergy < game.beamMaxEnergy) {
                game.beamEnergy += game.beamChargeRate;
                game.beamEnergy = Math.min(game.beamEnergy, game.beamMaxEnergy);
            }
            
            // ãƒ“ãƒ¼ãƒ æ›´æ–°
            game.beams.forEach(beam => beam.update());
            game.beams = game.beams.filter(beam => beam.life > 0);
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            game.particles.forEach(p => p.update());
            game.particles = game.particles.filter(p => p.life > 0);
            
            // ãƒ‰ãƒªãƒ«è€ä¹…åº¦ã®å›å¾©æ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–ï¼ˆã‚ˆã‚ŠæŒ‘æˆ¦çš„ãªã‚²ãƒ¼ãƒ ãƒãƒ©ãƒ³ã‚¹ï¼‰
            // if (!hitObstacle && game.drillDurability < game.drillMaxDurability) {
            //     game.drillDurability += 0.1; // å›å¾©é€Ÿåº¦ã‚’ä¸Šã’ã‚‹
            //     game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
            // }
            
            // æ˜å‰Šé€Ÿåº¦ã®è‡ªå‹•å¢—åŠ ï¼ˆç·©ã‚„ã‹ã«èª¿æ•´ï¼‰
            if (game.depth % 500 === 0 && game.depth > 0) {  // 500mã”ã¨ã«åŠ é€Ÿ
                game.drillSpeed += 0.15;  // ã‚ˆã‚Šç·©ã‚„ã‹ãªå¢—åŠ 
            }
            
            // 3000mä»¥é™ã•ã‚‰ã«åŠ é€Ÿï¼ˆã‚ˆã‚Šç·©ã‚„ã‹ï¼‰
            if (game.depth > 3000) {
                game.drillSpeed += 0.001 * (game.depth - 3000) / 200;  // åŠ é€Ÿåº¦ã‚’åŠåˆ†ã«
            }
            
            // æœ€å¤§é€Ÿåº¦åˆ¶é™ã‚’è¿½åŠ 
            game.drillSpeed = Math.min(game.drillSpeed, 8.0); // æœ€å¤§é€Ÿåº¦ã‚’8.0ã«åˆ¶é™
            
            // æ–­å±¤ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆäº€è£‚ã®ã¿ï¼‰
            game.faults.forEach(fault => {
                fault.update();
                
                // ãƒ‰ãƒªãƒ«ã®ã‚µã‚¤ã‚º
                const drillWidth = 60;
                const drillHeight = 110; // ãƒ‰ãƒªãƒ«å…¨ä½“ã®é«˜ã•
                
                // äº€è£‚ã¨ã®è¡çªåˆ¤å®š
                if (fault.checkCrackCollision(game.drillX, game.drillY, drillWidth, drillHeight)) {
                    // äº€è£‚ã«ç›´æ¥è¡çªï¼šé‡ã„ãƒ€ãƒ¡ãƒ¼ã‚¸
                    game.drillDurability -= 3;
                    hitObstacle = true;
                    
                    // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 10; i++) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                    }
                    
                    // ç”»é¢æºã‚Œ
                    canvas.style.transform = `translate(${Math.random() * 15 - 7.5}px, ${Math.random() * 15 - 7.5}px)`;
                    setTimeout(() => canvas.style.transform = '', 120);
                }
            });
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
            if (game.drillDurability <= 0) {
                gameOver();
            }
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆç”»é¢å¤–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ï¼‰
            game.rocks = game.rocks.filter(rock => rock.y > game.cameraY - 200);
            game.steamVents = game.steamVents.filter(vent => vent.y > game.cameraY - 200);
            game.magmaPools = game.magmaPools.filter(pool => pool.y > game.cameraY - 200);
            game.faults = game.faults.filter(fault => fault.y > game.cameraY - 200);
            game.oilPockets = game.oilPockets.filter(oilPocket => oilPocket.y > game.cameraY - 200);
            game.moles = game.moles.filter(mole => mole.y > game.cameraY - 200 && mole.y < game.cameraY + canvas.height + 200);
            game.pipeSegments = game.pipeSegments.filter(segment => segment.y > game.cameraY - 100);
            
            updateUI();
        }
        
        function drawGame() {
            // --- START OF NEW BACKGROUND LOGIC ---

            // 1. Define colors for different geological layers
            const layers = [
                { depth: 0,    colors: ['#87CEEB', '#A0522D'] }, // Surface: Sky to Soil
                { depth: 500,  colors: ['#A0522D', '#8B4513'] }, // Soil to Sediment
                { depth: 1500, colors: ['#696969', '#505050'] }, // Sedimentary/Metamorphic Rock (Greys)
                { depth: 3000, colors: ['#3E2723', '#2E1F1A'] }, // Igneous Rock (Dark Browns)
                { depth: 5000, colors: ['#2E1F1A', '#8B0000'] }, // Close to Mantle (Dark Red)
                { depth: 7000, colors: ['#8B0000', '#FF4500'] }  // Magma (Red to Orange)
            ];

            // 2. Determine the current and next layer based on depth
            let currentLayer = layers[0];
            let nextLayer = layers[1];
            for (let i = 0; i < layers.length - 1; i++) {
                if (game.depth >= layers[i].depth) {
                    currentLayer = layers[i];
                    nextLayer = layers[i+1];
                }
            }
            
            // 3. Calculate the transition progress between the two layers
            const layerDepthSpan = nextLayer.depth - currentLayer.depth;
            const progressInLayer = (game.depth - currentLayer.depth) / layerDepthSpan;
            
            // 4. Interpolate colors based on progress
            const r1 = parseInt(currentLayer.colors[0].slice(1, 3), 16);
            const g1 = parseInt(currentLayer.colors[0].slice(3, 5), 16);
            const b1 = parseInt(currentLayer.colors[0].slice(5, 7), 16);
            
            const r2 = parseInt(nextLayer.colors[0].slice(1, 3), 16);
            const g2 = parseInt(nextLayer.colors[0].slice(3, 5), 16);
            const b2 = parseInt(nextLayer.colors[0].slice(5, 7), 16);

            const r3 = parseInt(currentLayer.colors[1].slice(1, 3), 16);
            const g3 = parseInt(currentLayer.colors[1].slice(3, 5), 16);
            const b3 = parseInt(currentLayer.colors[1].slice(5, 7), 16);

            const r4 = parseInt(nextLayer.colors[1].slice(1, 3), 16);
            const g4 = parseInt(nextLayer.colors[1].slice(3, 5), 16);
            const b4 = parseInt(nextLayer.colors[1].slice(5, 7), 16);

            const topR = Math.round(r1 + (r2 - r1) * progressInLayer);
            const topG = Math.round(g1 + (g2 - g1) * progressInLayer);
            const topB = Math.round(b1 + (b2 - b1) * progressInLayer);

            const bottomR = Math.round(r3 + (r4 - r3) * progressInLayer);
            const bottomG = Math.round(g3 + (g4 - g3) * progressInLayer);
            const bottomB = Math.round(b3 + (b4 - b3) * progressInLayer);

            const topColor = `rgb(${topR}, ${topG}, ${topB})`;
            const bottomColor = `rgb(${bottomR}, ${bottomG}, ${bottomB})`;

            // 5. Create and apply the gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 6. Add procedural strata patterns based on depth
            ctx.save();
            for (let d = Math.floor(game.cameraY / 50) * 50; d < game.cameraY + canvas.height + 50; d += 50) {
                const y = d - game.cameraY;
                const currentDepthInMeters = d / 10;

                if (y > 0 && y < canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);

                    if (currentDepthInMeters < 1500) {
                        // Sedimentary layers: relatively straight lines
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.lineWidth = Math.random() * 2 + 1;
                        ctx.lineTo(canvas.width, y + (Math.random() - 0.5) * 5);
                    } else if (currentDepthInMeters < 3000) {
                        // Metamorphic layers: wavy, distorted lines
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                        ctx.lineWidth = Math.random() * 2.5 + 1;
                        ctx.quadraticCurveTo(
                            canvas.width / 2 + Math.sin(d / 100) * 50,
                            y + (Math.random() - 0.5) * 15,
                            canvas.width, 
                            y + (Math.random() - 0.5) * 10
                        );
                    } else {
                        // Igneous/Deeper layers: sharp, crystalline patterns
                        ctx.strokeStyle = 'rgba(255, 220, 180, 0.1)';
                        ctx.lineWidth = Math.random() * 1.5 + 0.5;
                        ctx.moveTo(Math.random() * 50, y);
                        for(let x = 50; x < canvas.width; x += Math.random() * 100 + 50) {
                            ctx.lineTo(x, y + (Math.random() - 0.5) * 25);
                        }
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();

            // 7. Add heat/magma effect for deep sections
            if (game.depth > 3000) {
                const heatIntensity = Math.min((game.depth - 3000) / 4000, 0.4);
                ctx.fillStyle = `rgba(255, 69, 0, ${heatIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Glowing cracks for very deep sections
                if (game.depth > 5000) {
                    ctx.save();
                    const crackCount = Math.min(10, Math.floor((game.depth - 5000) / 200));
                    ctx.globalAlpha = Math.min((game.depth - 5000) / 3000, 0.7);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500';
                    for (let i = 0; i < crackCount; i++) {
                        const y = Math.random() * canvas.height;
                        const x_start = Math.random() * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(x_start, y);
                        ctx.bezierCurveTo(
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 400, y + (Math.random() - 0.5) * 200
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            // --- END OF NEW BACKGROUND LOGIC ---

            // --- START BOREHOLE DRAWING ---
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Dark, semi-transparent for the tunnel
            ctx.lineWidth = 50; // Width of the borehole, wider than the drill
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            let firstVisibleSegment = true;
            game.pipeSegments.forEach(segment => {
                const screenY = segment.y - game.cameraY;
                // Only draw segments visible on screen
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisibleSegment) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisibleSegment = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });

            // Extend the tunnel to the current drill position
            if (game.pipeSegments.length > 0 && !firstVisibleSegment) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }

            ctx.stroke();
            ctx.restore();
            // --- END BOREHOLE DRAWING ---
            
            // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®æç”»
            ctx.save();
            ctx.strokeStyle = '#708090';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // ãƒ‘ã‚¤ãƒ—ã®æœ¬ä½“
            ctx.beginPath();
            let firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });
            
            // æœ€å¾Œã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‹ã‚‰æ˜å‰Šæ©Ÿã¾ã§
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }
            
            ctx.stroke();
            
            // ãƒ‘ã‚¤ãƒ—ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.strokeStyle = '#A9A9A9';
            ctx.lineWidth = 10;
            ctx.beginPath();
            firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x - 5, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x - 5, screenY);
                    }
                }
            });
            
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX - 5, drillScreenY);
            }
            
            ctx.stroke();
            
            // ãƒ‘ã‚¤ãƒ—ã®ç¶™ãç›®
            ctx.fillStyle = '#606060';
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50 && index % 50 === 0) {
                    ctx.beginPath();
                    ctx.arc(segment.x, screenY, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç¶™ãç›®ã®ãƒœãƒ«ãƒˆ
                    ctx.fillStyle = '#404040';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i;
                        const boltX = segment.x + Math.cos(angle) * 10;
                        const boltY = screenY + Math.sin(angle) * 10;
                        ctx.beginPath();
                        ctx.arc(boltX, boltY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#606060';
                }
            });
            
            ctx.restore();
            
            // ã‚‚ãã‚‰
            game.moles.forEach(mole => mole.draw());
            
            // æ–­å±¤
            game.faults.forEach(fault => fault.draw());
            
            // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆ
            game.oilPockets.forEach(oilPocket => oilPocket.draw());
            
            // ãƒã‚°ãƒæºœã¾ã‚Š
            game.magmaPools.forEach(pool => pool.draw());
            
            // å²©
            game.rocks.forEach(rock => rock.draw());
            
            // è’¸æ°—å­”
            game.steamVents.forEach(vent => vent.draw());
            
            // ãƒ“ãƒ¼ãƒ 
            game.beams.forEach(beam => beam.draw());
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            game.particles.forEach(p => p.draw());
            
            // æ˜å‰Šæ©Ÿ
            const drillScreenY = game.drillY - game.cameraY;
            ctx.save();
            ctx.translate(game.drillX, drillScreenY);

            // ãƒ‰ãƒªãƒ«ã®å‚¾ãã‚’é©ç”¨
            let tiltAngle = 0;
            const maxTilt = Math.PI / 16; // å‚¾ãã®æœ€å¤§è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
            if (keys['ArrowLeft']) {
                tiltAngle = maxTilt; // å·¦ã‚­ãƒ¼ã§å³ã«å‚¾ã‘ã‚‹
            } else if (keys['ArrowRight']) {
                tiltAngle = -maxTilt; // å³ã‚­ãƒ¼ã§å·¦ã«å‚¾ã‘ã‚‹
            }
            ctx.rotate(tiltAngle);
            
            // PDCãƒ‰ãƒªãƒ«ãƒ“ãƒƒãƒˆï¼ˆå®Ÿéš›ã®ç”»åƒã‚’ä½¿ç”¨ã€å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰- ãƒ‰ãƒªãƒ«æœ¬ä½“ã®å¾Œã‚ã«é…ç½®
            ctx.save();
            ctx.translate(0, 70); // ãƒ‰ãƒªãƒ«æœ¬ä½“ã‹ã‚‰å°‘ã—ä¸‹ã«é…ç½®ï¼ˆ50ã‹ã‚‰70ã«å¤‰æ›´ï¼‰
            
            // ç”»åƒã‚’90åº¦å›è»¢ã•ã›ã¦ã€ã•ã‚‰ã«ä¸Šä¸‹ã«180åº¦å›è»¢ã€æœ€å¾Œã«30åº¦å›è»¢ã•ã›ã¦æ­£ã—ã„å‘ãã«ã™ã‚‹
            ctx.rotate(Math.PI / 2); // 90åº¦å›è»¢
            ctx.rotate(Math.PI); // ä¸Šä¸‹ã«180åº¦å›è»¢
            ctx.rotate(Math.PI / 6); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 8); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 8); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 9); // ã•ã‚‰ã«30åº¦å›è»¢
             
        
        
           
            
            if (imageLoaded) {
                // ç”»åƒã®ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚ºã«ï¼‰
                const bitWidth = 100; // 60ã‹ã‚‰100ã«æ‹¡å¤§
                const bitHeight = 120; // 80ã‹ã‚‰120ã«æ‹¡å¤§
                
                // é«˜æ¸©æ™‚ã®åŠ¹æœ
                if (game.temperature > 500) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = game.temperature > 800 ? '#FF4500' : '#FFD700';
                }
                
                // é«˜æ¸©æ™‚ã®è‰²èª¿å¤‰æ›´
                if (game.temperature > 800) {
                    ctx.filter = 'hue-rotate(30deg) saturate(1.5) brightness(1.2)';
                } else if (game.temperature > 500) {
                    ctx.filter = 'saturate(1.2) brightness(1.1)';
                } else {
                    ctx.filter = 'none';
                }
                
                // PDCãƒ“ãƒƒãƒˆç”»åƒã‚’æç”»ï¼ˆ90åº¦å›è»¢å¾Œã®ä½ç½®èª¿æ•´ï¼‰
                ctx.drawImage(
                    drillBitImage, 
                    -bitWidth / 2, 
                    -bitHeight / 2, // ä¸­å¤®ã«é…ç½®
                    bitWidth, 
                    bitHeight
                );
                
                // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
                ctx.filter = 'none';
                
                // é«˜æ¸©æ™‚ã®è¿½åŠ åŠ¹æœï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰
                if (game.temperature > 800) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bitWidth/2 + 8, bitHeight/2 + 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            } else {
                // ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§ã®ä»£æ›¿è¡¨ç¤º
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(-40, -50, 80, 100); // ã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚º
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', 0, 0);
            }
            
            ctx.restore();
            
            // ãƒ‰ãƒªãƒ«æœ¬ä½“ï¼ˆPDCãƒ“ãƒƒãƒˆã®ä¸Šã«æç”»ï¼‰
            const gradient2 = ctx.createLinearGradient(-20, -30, 20, 30);
            gradient2.addColorStop(0, '#E0E0E0');
            gradient2.addColorStop(1, '#808080');
            ctx.fillStyle = gradient2;
            ctx.fillRect(-25, -40, 50, 80);
            
            // æ’æ°—
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = -50 - i * 10;
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, 5 + i * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // æ·±åº¦ãƒãƒ¼ã‚«ãƒ¼
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 14px Arial';
            for (let d = Math.floor(game.cameraY / 100) * 100; d <= game.cameraY + canvas.height + 100; d += 100) {
                const y = d - game.cameraY;
                if (y > 0 && y < canvas.height) {
                    ctx.fillText(`${Math.floor(d / 10)}m`, 10, y);
                    ctx.fillRect(0, y, 40, 2);
                }
            }
            
            // ç”»é¢ç«¯ã®è­¦å‘Š
            if (game.drillX < 100 || game.drillX > canvas.width - 100) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (game.drillX < 100) {
                    ctx.fillRect(0, 0, 50, canvas.height);
                } else {
                    ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);
                }
            }
        }
        
        function updateUI() {
            document.getElementById('depth').textContent = game.depth;
            document.getElementById('temperature').textContent = Math.floor(game.temperature);
            document.getElementById('drillSpeed').textContent = game.drillSpeed.toFixed(1);
            document.getElementById('drillEnergy').style.width = `${Math.max(0, (game.drillDurability / game.drillMaxDurability) * 100)}%`;
            
            // è€ä¹…åº¦ã«ã‚ˆã‚‹è‰²å¤‰æ›´
            const durabilityRatio = game.drillDurability / game.drillMaxDurability;
            if (durabilityRatio < 0.3) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #8B0000, #FF0000)';
            } else if (durabilityRatio < 0.6) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF8C00, #FFD700)';
            } else {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF4500, #FFD700)';
            }
            
            // ãƒ“ãƒ¼ãƒ ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚²ãƒ¼ã‚¸ã®æ›´æ–°
            const beamRatio = game.beamEnergy / game.beamMaxEnergy;
            document.getElementById('beamEnergy').style.width = `${beamRatio * 100}%`;
            
            // æ³¥æ°´ãƒ“ãƒ¼ãƒ ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®è‰²ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
            if (beamRatio >= 1.0) {
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #8B4513, #A0522D)';
                document.getElementById('beamStatus').textContent = 'ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ç™ºå°„ï¼';
                document.getElementById('beamStatus').style.color = '#D2B48C';
            } else {
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #654321, #8B4513)';
                document.getElementById('beamStatus').textContent = `å……é›»ä¸­... ${Math.floor(beamRatio * 100)}%`;
                document.getElementById('beamStatus').style.color = '#FFFFFF';
            }
        }
        
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }
        
        
        function gameOver(reason = null) {
            game.gameRunning = false;
            document.getElementById('finalDepth').textContent = game.maxDepth;
            document.getElementById('maxTemp').textContent = Math.floor(game.maxTemp);
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ç†ç”±ã‚’è¡¨ç¤º
            const gameOverDiv = document.getElementById('gameOver');
            const h2 = gameOverDiv.querySelector('h2');
            if (reason) {
                h2.textContent = reason;
            } else {
                h2.textContent = 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        function resetGame() {
            game = {
                depth: 0,
                energy: 0,
                temperature: 15,
                drillX: 600,
                drillY: 0,
                drillSpeed: 2.5, // åˆæœŸé€Ÿåº¦ã‚’2.5å€ã«å¢—åŠ 
                drillDurability: 100,
                drillMaxDurability: 100,
                beamEnergy: 0,
                beamMaxEnergy: 100,
                beamChargeRate: 0.15,
                cooling: 1,
                particles: [],
                rocks: [],
                steamVents: [],
                magmaPools: [],
                faults: [], // æ–­å±¤
                oilPockets: [], // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆ
                beams: [], // ãƒ“ãƒ¼ãƒ 
                moles: [], // ã‚‚ãã‚‰
                pipeSegments: [], // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
                maxDepth: 0,
                maxTemp: 15,
                gameRunning: true,
                cameraY: 0,
                generatedSpawns: new Set(),
                upgrades: {
                    speed: { level: 1, cost: 10 },
                    durability: { level: 1, cost: 15 },
                    cooling: { level: 1, cost: 20 }
                }
            };
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }
        
        // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰æ©Ÿèƒ½ã¯ç¾åœ¨UIã«ãªã„ãŸã‚ã€ä¸€æ—¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
        /*
        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (game.energy >= game.upgrades.speed.cost) {
                game.energy -= game.upgrades.speed.cost;
                game.drillSpeed += 0.8;  // 0.3 â†’ 0.8ã«å¢—åŠ 
                game.upgrades.speed.level++;
                game.upgrades.speed.cost = Math.floor(game.upgrades.speed.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeDurability').addEventListener('click', () => {
            if (game.energy >= game.upgrades.durability.cost) {
                game.energy -= game.upgrades.durability.cost;
                game.drillMaxDurability += 50;
                game.drillDurability += 50;
                game.upgrades.durability.level++;
                game.upgrades.durability.cost = Math.floor(game.upgrades.durability.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeCooling').addEventListener('click', () => {
            if (game.energy >= game.upgrades.cooling.cost) {
                game.energy -= game.upgrades.cooling.cost;
                game.cooling += 0.5;
                game.upgrades.cooling.level++;
                game.upgrades.cooling.cost = Math.floor(game.upgrades.cooling.cost * 2);
                updateUI();
            }
        });
        */
        
        // æ³¥æ°´ãƒ“ãƒ¼ãƒ ç™ºå°„é–¢æ•°
        function fireBeam() {
            if (game.beamEnergy >= game.beamMaxEnergy && game.gameRunning) {
                // ãƒ‰ãƒªãƒ«ã‹ã‚‰ä¸‹æ–¹å‘ã«æ³¥æ°´ãƒ“ãƒ¼ãƒ ç™ºå°„
                const beam = new Beam(game.drillX, game.drillY + 60, Math.PI / 2); // ä¸‹å‘ãï¼ˆ90åº¦ï¼‰
                game.beams.push(beam);
                
                // ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»
                game.beamEnergy = 0;
                
                // æ³¥æ°´ç™ºå°„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆèŒ¶è‰²ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
                for (let i = 0; i < 15; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 25,
                        game.drillY + 50 + (Math.random() - 0.5) * 25,
                        Math.random() < 0.7 ? 'rock' : 'steam' // æ³¥ã¨æ°´è’¸æ°—ã®æ··åˆ
                    ));
                }
                
                // ç”»é¢åŠ¹æœï¼ˆèŒ¶è‰²ãŒã‹ã£ãŸãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼‰
                canvas.style.filter = 'brightness(1.3) sepia(0.5) saturate(1.5)';
                setTimeout(() => canvas.style.filter = '', 150);
                
                console.log('æ³¥æ°´ãƒ“ãƒ¼ãƒ ç™ºå°„ï¼');
            }
        }

        // ã‚­ãƒ¼å…¥åŠ›
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            
            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§æ³¥æ°´ãƒ“ãƒ¼ãƒ ç™ºå°„
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                fireBeam();
            }
            
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = false;
        });
        
        // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œ
        let touchStartX = null;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (touchStartX !== null) {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                
                if (diff < -30) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else if (diff > 30) {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }
            }
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', () => {
            touchStartX = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });
        
        // ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        
        // ãƒã‚¦ã‚¹ã§ã‚‚å‹•ä½œã™ã‚‹ã‚ˆã†ã«
        leftButton.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
        leftButton.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
        rightButton.addEventListener('mousedown', () => keys['ArrowRight'] = true);
        rightButton.addEventListener('mouseup', () => keys['ArrowRight'] = false);
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ãƒªã‚µã‚¤ã‚º
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game.gameRunning = true;
            resizeGame(); // ãƒªã‚µã‚¤ã‚ºã‚’å®Ÿè¡Œ
            gameLoop();
        }
    </script>
</body>
</html>