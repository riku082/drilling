<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>地熱井戸掘削ゲーム</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #8B4513 20%, #654321 40%, #3E2723 60%, #D2691E 80%, #FF4500 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1200px, 95vw);
            height: min(800px, 85vh);
            max-width: 100%;
            max-height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: min(20px, 2vw);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: min(15px, 2vw);
            border-radius: min(10px, 1.5vw);
            border: 2px solid #FF4500;
            font-size: min(14px, 3vw);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #stats {
            top: min(20px, 2vh);
            left: min(20px, 2vw);
            min-width: min(200px, 40vw);
        }

        #controls {
            top: 20px;
            right: 20px;
            pointer-events: all;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #FF4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
        }

        button {
            background: #FF4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            background: #FF6347;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        .stat-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
        }

        .energy-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #FFD700;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #FF4500, #FFD700);
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        h1, h2 {
            margin: 10px 0;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        .upgrade-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #228B22;
            margin-top: 5px;
        }

        .upgrade-btn:hover {
            background: #32CD32;
        }

        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 1000;
        }

        #startScreen h1 {
            font-size: 48px;
            color: #FF4500;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .instructions {
            margin: 20px 0;
            font-size: 18px;
            line-height: 1.5;
        }

        .warning {
            color: #FF6347;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* モバイル用タッチコントロール */
        #mobileControls {
            position: absolute;
            bottom: min(20px, 2vh);
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: min(20px, 3vw);
            z-index: 1000;
        }

        .touch-button {
            width: min(80px, 15vw);
            height: min(80px, 15vw);
            background: rgba(255, 69, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-size: min(24px, 4vw);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            touch-action: manipulation;
        }

        .touch-button:active {
            background: rgba(255, 69, 0, 1);
            transform: scale(0.95);
        }

        @media (max-width: 768px) or (max-height: 600px) {
            #mobileControls {
                display: flex;
            }
            
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }
            
            .info-panel {
                font-size: max(12px, 2.5vw);
                padding: max(8px, 1.5vw);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="1000"></canvas>
        <div id="ui">
            <div id="stats" class="info-panel">
                <h2>掘削状況</h2>
                <div>深度: <span class="stat-value" id="depth">0</span> m</div>
                <div>温度: <span class="stat-value" id="temperature">15</span> ℃</div>
                <div>掘削速度: <span class="stat-value" id="drillSpeed">2.5</span> m/s</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="drillEnergy"></div>
                </div>
                <div style="font-size: 12px;">ドリル耐久度</div>
                <div id="warningText" class="warning" style="display: none;">⚠️ 高温注意！</div>
            </div>
        </div>
        
        <div id="startScreen">
            <h1>🔥 地熱井戸掘削ゲーム 🔥</h1>
            <div class="instructions">
                <p>自動で地球の深部へ掘り進みます！</p>
                <p>← → キーで掘削機を左右に移動して障害物を避けよう</p>
                <p>岩にぶつかるとドリルが消耗します</p>
                <p>蒸気孔に近づくとボーナスエネルギー獲得！</p>
                <p>より深く掘るほど高温になり、多くのエネルギーを獲得できます</p>
            </div>
            <button onclick="startGame()">ゲームスタート</button>
        </div>
        
        <div id="gameOver">
            <h2>ゲームオーバー</h2>
            <p>最終深度: <span id="finalDepth">0</span> m</p>
            <p>最高温度: <span id="maxTemp">0</span> ℃</p>
            <button onclick="resetGame()">もう一度プレイ</button>
        </div>
        
        <!-- モバイル用タッチコントロール -->
        <div id="mobileControls">
            <div class="touch-button" id="leftButton">←</div>
            <div class="touch-button" id="rightButton">→</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // PDCビット画像の読み込み
        const drillBitImage = new Image();
        drillBitImage.src = 'Gemini_Generated_Image_sfxgpisfxgpisfxg.png';
        let imageLoaded = false;
        drillBitImage.onload = function() {
            imageLoaded = true;
        };
        
        // レスポンシブ対応
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            const scaleX = containerRect.width / 1200;
            const scaleY = containerRect.height / 1000;
            const scale = Math.min(scaleX, scaleY);
            
            canvas.style.transform = `scale(${scale})`;
            canvas.style.transformOrigin = 'top left';
            
            // ゲーム内座標も調整
            if (game.drillX === 600) { // 初期位置の場合
                game.drillX = 1200 * 0.5; // 画面中央
            }
        }
        
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeGame, 100);
        });
        
        let game = {
            depth: 0,
            temperature: 15,
            drillX: 600,
            drillY: 0,
            drillSpeed: 2.5, // 初期速度を2.5倍に増加
            drillDurability: 100,
            drillMaxDurability: 100,
            particles: [],
            rocks: [],
            steamVents: [],
            magmaPools: [],
            faults: [], // 断層
            moles: [], // もぐら
            pipeSegments: [], // ドリルパイプのセグメント
            maxDepth: 0,
            maxTemp: 15,
            gameRunning: false,
            cameraY: 0
        };
        
        const keys = {};
        
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.type = type;

                if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() * -10) - 5;
                    this.size = Math.random() * 4 + 1;
                    this.gravity = 0.4;
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = Math.random() * -5 - 2;
                    this.size = Math.random() * 5 + 2;
                    this.gravity = 0.3;
                }
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= 0.03;
                this.size *= 0.97;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'rock') {
                    ctx.fillStyle = '#8B4513';
                } else if (this.type === 'steam') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                } else if (this.type === 'lava') {
                    ctx.fillStyle = '#FF4500';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF4500';
                } else if (this.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFD700';
                }
                
                const screenY = this.y - game.cameraY;
                ctx.beginPath();
                ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Rock {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 100 + 50;
                this.height = Math.random() * 60 + 30;
                this.hardness = Math.random() * 3 + 1;
                this.hit = false;
                this.points = [];
                // Generate irregular shape points
                const numPoints = Math.floor(Math.random() * 5) + 8; // 8-12 points
                const angleStep = (Math.PI * 2) / numPoints;
                for (let i = 0; i < numPoints; i++) {
                    const angle = i * angleStep;
                    const radius = (Math.random() * 0.3 + 0.7) * Math.min(this.width, this.height) / 2;
                    this.points.push({
                        x: radius * Math.cos(angle),
                        y: radius * Math.sin(angle)
                    });
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                if (this.hit) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Base rock color with gradient
                const gradient = ctx.createLinearGradient(0, -this.height / 2, 0, this.height / 2);
                gradient.addColorStop(0, `rgba(150, 75, 0, ${0.8 / this.hardness})`); // Lighter brown
                gradient.addColorStop(0.5, `rgba(139, 69, 19, ${0.8 / this.hardness})`); // Medium brown
                gradient.addColorStop(1, `rgba(100, 50, 0, ${0.8 / this.hardness})`); // Darker brown
                ctx.fillStyle = gradient;

                // Draw irregular shape
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();

                // Add some texture/noise
                ctx.fillStyle = `rgba(0, 0, 0, ${0.1 / this.hardness})`;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.width - this.width / 2, Math.random() * this.height - this.height / 2, Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Gold outline and shadow
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 15;
                ctx.strokeStyle = '#FFD700'; // Gold outline
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        class SteamVent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = true;
                this.timer = 0;
                this.radius = 20;
            }
            
            update() {
                this.timer++;
                if (this.timer % 3 === 0 && this.active) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 20,
                        this.y,
                        'steam'
                    ));
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);

                // 蒸気孔の穴
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // 蒸気孔の光
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // 蒸気の表現 (パーティクルで描画されるため、ここでは追加の視覚効果のみ)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }
        
        class Mole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.width = 40;
                this.height = 30;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.animationTime = 0;
                this.tunnelX = x;
                this.surprised = false;
                this.fleeing = false;
            }
            
            update() {
                this.animationTime++;
                
                // ドリルとの距離を計算
                const distance = Math.sqrt(
                    Math.pow(this.x - game.drillX, 2) + 
                    Math.pow(this.y - game.drillY, 2)
                );
                
                // ドリルが近づいたら驚いて逃げる
                if (distance < 150 && !this.fleeing) {
                    this.surprised = true;
                    this.fleeing = true;
                    this.vx = (this.x - game.drillX) * 0.1;
                    this.vy = -2;
                }
                
                if (this.fleeing) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.95;
                    this.vy += 0.1;
                } else {
                    // 通常の移動
                    this.x += Math.sin(this.animationTime * 0.05) * 0.5 * this.direction;
                    
                    // 画面端で方向転換
                    if (this.x < 50 || this.x > canvas.width - 50) {
                        this.direction *= -1;
                    }
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                // もぐらの穴
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // もぐらの体 (より有機的な形状と毛並み)
                ctx.fillStyle = '#4B3621';
                ctx.strokeStyle = '#3A2B1A';
                ctx.lineWidth = 1;
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // 毛並みの表現 (簡単な線で)
                for(let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                    ctx.lineTo(radius * Math.cos(angle) * 1.2, radius * Math.sin(angle) * 1.2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.stroke();
                }
                
                // もぐらの頭
                ctx.fillStyle = '#5C4033';
                ctx.beginPath();
                ctx.ellipse(this.direction * 15, -5, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // 鼻 (よりリアルに)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(this.direction * 22, -5, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 目 (表情豊かに)
                if (this.surprised) {
                    // 驚いた目
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 4, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // 通常の目
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 手 (より詳細に)
                ctx.fillStyle = '#4B3621';
                ctx.beginPath();
                ctx.ellipse(-10, 5, 6, 8, -0.3, 0, Math.PI * 2);
                ctx.ellipse(10, 5, 6, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // 土の粒子
                if (!this.fleeing && Math.random() < 0.3) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 30,
                        this.y + 10,
                        'rock'
                    ));
                }
                
                // 驚きマーク
                if (this.surprised && !this.fleeing) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', 0, -25);
                }
                
                ctx.restore();
            }
        }
        
        class Fault {
            constructor(y) {
                this.y = y;
                this.leftX = Math.random() * 200 + 100;
                this.rightX = this.leftX + Math.random() * 200 + 150;
                this.height = 30;
                this.warningHeight = 100;
                this.particles = [];
                this.crackPoints = [];
                // 亀裂の形状を生成
                const numPoints = Math.floor(Math.random() * 5) + 5; // 5-9 points
                for (let i = 0; i <= numPoints; i++) {
                    const x = this.leftX + (this.rightX - this.leftX) * (i / numPoints);
                    const yOffset = (Math.random() - 0.5) * 40; // Vertical variation
                    this.crackPoints.push({ x: x, y: yOffset });
                }
            }
            
            update() {
                // 警告パーティクル
                if (Math.random() < 0.3) {
                    const x = this.leftX + Math.random() * (this.rightX - this.leftX);
                    this.particles.push({
                        x: x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= 0.02;
                    p.size *= 0.98;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -this.warningHeight || screenY > canvas.height + 50) return;
                
                // 警告ゾーン（断層の上）
                if (screenY > -this.warningHeight && screenY < this.height) {
                    ctx.save();
                    const gradient = ctx.createLinearGradient(0, screenY - this.warningHeight, 0, screenY);
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                    gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.6)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, screenY - this.warningHeight, this.leftX + 10, this.warningHeight);
                    ctx.fillRect(this.rightX - 10, screenY - this.warningHeight, canvas.width - (this.rightX - 10), this.warningHeight);
                    ctx.restore();
                }
                
                // 安全ゾーン（緑色で表示）
                if (screenY > -this.warningHeight && screenY < this.height + 20) {
                    ctx.save();
                    const safeGradient = ctx.createLinearGradient(0, screenY - this.warningHeight, 0, screenY + 20);
                    safeGradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
                    safeGradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.3)');
                    safeGradient.addColorStop(1, 'rgba(0, 255, 0, 0.1)');
                    ctx.fillStyle = safeGradient;
                    ctx.fillRect(this.leftX + 10, screenY - this.warningHeight, 
                                (this.rightX - 10) - (this.leftX + 10), this.warningHeight + 20);
                    ctx.restore();
                }
                
                // 断層本体（亀裂のように描画）
                ctx.save();
                ctx.strokeStyle = '#333333'; // 亀裂の色
                ctx.lineWidth = 10; // 亀裂の太さ
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#000';

                ctx.beginPath();
                ctx.moveTo(this.crackPoints[0].x, screenY + this.crackPoints[0].y);
                for (let i = 1; i < this.crackPoints.length; i++) {
                    ctx.lineTo(this.crackPoints[i].x, screenY + this.crackPoints[i].y);
                }
                ctx.stroke();

                // 亀裂の光る縁
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(this.crackPoints[0].x, screenY + this.crackPoints[0].y);
                for (let i = 1; i < this.crackPoints.length; i++) {
                    ctx.lineTo(this.crackPoints[i].x, screenY + this.crackPoints[i].y);
                }
                ctx.stroke();
                
                // 警告パーティクル
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                
                // 警告テキスト
                if (screenY > 0 && screenY < canvas.height) {
                    ctx.save();
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 24px Arial'; // 20pxから増加
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15; // 10から増加
                    ctx.shadowColor = '#FF0000';
                    ctx.fillText('⚠ 断層 ⚠', canvas.width / 2, screenY - 40);
                    ctx.restore();
                }
            }
        }
        
        function generateTerrain() {
            // 画面下端から少し先の位置で障害物を生成
            const spawnY = game.cameraY + canvas.height + 200;
            const spawnCheck = Math.floor(spawnY / 100) * 100;
            
            if (!game.generatedSpawns) game.generatedSpawns = new Set();
            
            if (!game.generatedSpawns.has(spawnCheck)) {
                game.generatedSpawns.add(spawnCheck);
                
                // もぐら（500-2000mの部分） - 画面下から出現
                if (game.depth >= 500 && game.depth < 2000) {
                    if (Math.random() < 0.3) {
                        game.moles.push(new Mole(
                            Math.random() * (canvas.width - 100) + 50,
                            spawnY
                        ));
                    }
                }
                
                // 岩の生成 - 画面下から出現
                const rockCount = Math.floor(Math.random() * 2) + 1 + Math.floor(game.depth / 2000);
                for (let i = 0; i < rockCount; i++) {
                    const rock = new Rock(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    );
                    rock.hardness += game.depth / 3000;
                    game.rocks.push(rock);
                }
                
                // 蒸気孔（1500m以降） - 画面下から出現
                if (game.depth > 1500 && Math.random() < 0.2 + game.depth / 8000) {
                    game.steamVents.push(new SteamVent(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // 断層（2500m以降） - 画面下から出現
                if (game.depth > 2500) {
                    const faultChance = 0.1 + (game.depth - 2500) / 15000;
                    if (Math.random() < faultChance) {
                        game.faults.push(new Fault(spawnY + Math.random() * 100));
                    }
                }
            }
        }
        
        function updateGame() {
            if (!game.gameRunning) return;

            // --- START OF NEW EFFECTS ---

            // 1. Continuous screen shake for drilling vibration
            const shakeIntensity = Math.min(game.drillSpeed / 10, 1.5);
            const shakeX = (Math.random() - 0.5) * shakeIntensity;
            const shakeY = (Math.random() - 0.5) * shakeIntensity;
            canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;

            // 2. Continuous drilling particle generation
            const particleCount = Math.ceil(game.drillSpeed); // パーティクル数を増加
            for (let i = 0; i < particleCount; i++) {
                let particleType = 'rock';
                if (game.depth > 5000) {
                    particleType = 'lava';
                } else if (game.depth > 3000) {
                    if (Math.random() < 0.5) particleType = 'lava';
                }
                game.particles.push(new Particle(
                    game.drillX + (Math.random() - 0.5) * 30,
                    game.drillY + 60, // ドリルの先端より少し下から発生
                    particleType
                ));
            }

            // 3. Spark generation at high temperatures
            if (game.temperature > 800) {
                if (Math.random() < (game.temperature - 800) / 1000) {
                    game.particles.push(new Particle(game.drillX, game.drillY + 40, 'spark'));
                }
            }

            // --- END OF NEW EFFECTS ---
            
            // パイプセグメントの追加（10ピクセルごと）
            if (game.pipeSegments.length === 0 || 
                game.drillY - game.pipeSegments[game.pipeSegments.length - 1].y > 10) {
                game.pipeSegments.push({
                    x: game.drillX,
                    y: game.drillY,
                    angle: Math.atan2(
                        game.drillX - (game.pipeSegments.length > 0 ? 
                            game.pipeSegments[game.pipeSegments.length - 1].x : game.drillX),
                        10
                    )
                });
            }
            
            // 自動掘削（下方向への移動）
            game.drillY += game.drillSpeed;
            game.depth = Math.floor(game.drillY / 10);
            game.maxDepth = Math.max(game.maxDepth, game.depth);
            
            // カメラの追従
            game.cameraY = game.drillY - 100;
            
            // 左右移動（速度制限）
            const baseMoveSpeed = 1.5; // 基本移動速度をさらに低く設定
            const moveSpeed = baseMoveSpeed + (game.drillSpeed * 0.1); // 掘削速度の影響を最小限に
            const maxMoveSpeed = 2.5; // 最大移動速度をさらに制限
            const actualMoveSpeed = Math.min(moveSpeed, maxMoveSpeed);
            
            if (keys['ArrowLeft'] && game.drillX > 50) {
                game.drillX -= actualMoveSpeed;
            }
            if (keys['ArrowRight'] && game.drillX < canvas.width - 50) {
                game.drillX += actualMoveSpeed;
            }
            
            // デバッグ用：キー入力の確認
            // console.log('Keys:', keys, 'DrillX:', game.drillX);
            
            // 温度上昇
            game.temperature = 15 + game.depth * 0.035;
            if (game.depth > 3000) {
                game.temperature += (game.depth - 3000) * 0.05; // 3000m以降は急激に温度上昇
            }
            game.maxTemp = Math.max(game.maxTemp, game.temperature);
            
            // 衝突フラグをリセット
            let hitObstacle = false;
            
            // 警告表示
            document.getElementById('warningText').style.display = 
                game.temperature > 1000 ? 'block' : 'none';
            
            // 地形生成
            generateTerrain();
            
            // もぐらの更新と衝突チェック
            game.moles.forEach(mole => {
                mole.update();
                
                // もぐらとの衝突（ダメージは少ない）
                if (!mole.fleeing &&
                    Math.abs(mole.x - game.drillX) < 30 &&
                    Math.abs(mole.y - game.drillY) < 30) {
                    
                    game.drillDurability -= 5;
                    hitObstacle = true;
                    mole.surprised = true;
                    mole.fleeing = true;
                    
                    // かわいい衝突エフェクト
                    for (let i = 0; i < 5; i++) {
                        game.particles.push(new Particle(mole.x, mole.y, 'rock'));
                    }
                }
            });
            
            // 岩との衝突チェック
            game.rocks.forEach(rock => {
                if (!rock.hit &&
                    Math.abs(rock.x - game.drillX) < (rock.width/2 + 20) &&
                    Math.abs(rock.y - game.drillY) < (rock.height/2 + 30)) {
                    
                    rock.hit = true;
                    game.drillDurability -= rock.hardness * 3;
                    hitObstacle = true;
                    
                    // 衝突エフェクト (岩と火花)
                    for (let i = 0; i < 15; i++) {
                        game.particles.push(new Particle(game.drillX, game.drillY + 40, i < 10 ? 'rock' : 'spark'));
                    }
                    
                    // 画面の揺れ効果（強化）
                    canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    setTimeout(() => canvas.style.transform = '', 150);
                }
            });
            
            // 蒸気孔ボーナス
            game.steamVents.forEach(vent => {
                vent.update();
                const distance = Math.sqrt(
                    Math.pow(vent.x - game.drillX, 2) + 
                    Math.pow(vent.y - game.drillY, 2)
                );
                if (distance < 50) {
                    // 近くにいるとパーティクル増加
                    if (Math.random() < 0.3) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'steam'));
                    }
                }
            });
            
            // マグマ溜まりのダメージ
            game.magmaPools.forEach(pool => {
                pool.update();
                if (Math.abs(pool.x - game.drillX) < pool.width/2 &&
                    Math.abs(pool.y - game.drillY) < 50) {
                    game.drillDurability -= 0.5;
                    hitObstacle = true;
                    
                    if (Math.random() < 0.2) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'lava'));
                    }
                }
            });
            
            // パーティクル更新
            game.particles.forEach(p => p.update());
            game.particles = game.particles.filter(p => p.life > 0);
            
            // ドリル耐久度の回復（障害物に当たっていない時のみ）
            if (!hitObstacle && game.drillDurability < game.drillMaxDurability) {
                game.drillDurability += 0.1; // 回復速度を上げる
                game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
            }
            
            // 掘削速度の自動増加（深度ボーナス + 加速度的増加）
            if (game.depth % 300 === 0 && game.depth > 0) {  // 500m → 300mごとに加速
                game.drillSpeed += 0.3;  // 0.1 → 0.3に増加
            }
            
            // 2000m以降さらに加速（3000m → 2000mに早める）
            if (game.depth > 2000) {
                game.drillSpeed += 0.002 * (game.depth - 2000) / 100;  // 加速度を2倍に
            }
            
            // 断層との衝突チェック
            game.faults.forEach(fault => {
                fault.update();
                
                // ドリルのサイズを考慮した当たり判定（より正確に）
                const drillWidth = 60; // ドリルビットのサイズに合わせて調整
                const drillLeft = game.drillX - drillWidth / 2;
                const drillRight = game.drillX + drillWidth / 2;
                const drillTop = game.drillY - 30; // ドリル上部
                const drillBottom = game.drillY + 80; // ドリルビット下端まで
                
                // 断層の範囲
                const faultTop = fault.y - fault.height / 2;
                const faultBottom = fault.y + fault.height / 2;
                
                // 垂直方向の重なり判定
                if (drillBottom > faultTop && drillTop < faultBottom) {
                    // 断層の安全ゾーン（隙間）- より寛容に
                    const safeZoneLeft = fault.leftX + 15; // 余裕を増やす
                    const safeZoneRight = fault.rightX - 15;
                    
                    // ドリル全体が安全ゾーン内にあるかチェック
                    const isInSafeZone = (drillLeft >= safeZoneLeft && drillRight <= safeZoneRight);
                    
                    if (!isInSafeZone) {
                        // 警告ゾーンの判定（段階的ダメージ）
                        const warningZoneWidth = 25; // 警告ゾーンを広げる
                        const leftWarningZone = safeZoneLeft - warningZoneWidth;
                        const rightWarningZone = safeZoneRight + warningZoneWidth;
                        
                        // ドリルの一部が警告ゾーンにある場合
                        const isInWarningZone = 
                            (drillRight > leftWarningZone && drillLeft < safeZoneLeft) ||
                            (drillLeft < rightWarningZone && drillRight > safeZoneRight);
                        
                        if (isInWarningZone) {
                            // 警告段階：軽いダメージ
                            game.drillDurability -= 0.3; // ダメージを軽減
                            hitObstacle = true;
                            
                            // 警告エフェクト
                            if (Math.random() < 0.15) {
                                for (let i = 0; i < 2; i++) {
                                    game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                                }
                            }
                        } else {
                            // 危険ゾーン：重いダメージ
                            const isDangerZone = 
                                drillRight < leftWarningZone || drillLeft > rightWarningZone;
                            
                            if (isDangerZone) {
                                // 即座にゲームオーバーではなく、重いダメージ
                                game.drillDurability -= 5; // 重いダメージ
                                hitObstacle = true;
                                
                                // 激しいエフェクト
                                for (let i = 0; i < 8; i++) {
                                    game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                                }
                                
                                // 画面揺れ
                                canvas.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
                                setTimeout(() => canvas.style.transform = '', 100);
                            }
                        }
                    }
                }
            });
            
            // ゲームオーバー判定
            if (game.drillDurability <= 0) {
                gameOver();
            }
            
            // オブジェクトのクリーンアップ（画面外のオブジェクトを削除）
            game.rocks = game.rocks.filter(rock => rock.y > game.cameraY - 200);
            game.steamVents = game.steamVents.filter(vent => vent.y > game.cameraY - 200);
            game.magmaPools = game.magmaPools.filter(pool => pool.y > game.cameraY - 200);
            game.faults = game.faults.filter(fault => fault.y > game.cameraY - 200);
            game.moles = game.moles.filter(mole => mole.y > game.cameraY - 200 && mole.y < game.cameraY + canvas.height + 200);
            game.pipeSegments = game.pipeSegments.filter(segment => segment.y > game.cameraY - 100);
            
            updateUI();
        }
        
        function drawGame() {
            // --- START OF NEW BACKGROUND LOGIC ---

            // 1. Define colors for different geological layers
            const layers = [
                { depth: 0,    colors: ['#87CEEB', '#A0522D'] }, // Surface: Sky to Soil
                { depth: 500,  colors: ['#A0522D', '#8B4513'] }, // Soil to Sediment
                { depth: 1500, colors: ['#696969', '#505050'] }, // Sedimentary/Metamorphic Rock (Greys)
                { depth: 3000, colors: ['#3E2723', '#2E1F1A'] }, // Igneous Rock (Dark Browns)
                { depth: 5000, colors: ['#2E1F1A', '#8B0000'] }, // Close to Mantle (Dark Red)
                { depth: 7000, colors: ['#8B0000', '#FF4500'] }  // Magma (Red to Orange)
            ];

            // 2. Determine the current and next layer based on depth
            let currentLayer = layers[0];
            let nextLayer = layers[1];
            for (let i = 0; i < layers.length - 1; i++) {
                if (game.depth >= layers[i].depth) {
                    currentLayer = layers[i];
                    nextLayer = layers[i+1];
                }
            }
            
            // 3. Calculate the transition progress between the two layers
            const layerDepthSpan = nextLayer.depth - currentLayer.depth;
            const progressInLayer = (game.depth - currentLayer.depth) / layerDepthSpan;
            
            // 4. Interpolate colors based on progress
            const r1 = parseInt(currentLayer.colors[0].slice(1, 3), 16);
            const g1 = parseInt(currentLayer.colors[0].slice(3, 5), 16);
            const b1 = parseInt(currentLayer.colors[0].slice(5, 7), 16);
            
            const r2 = parseInt(nextLayer.colors[0].slice(1, 3), 16);
            const g2 = parseInt(nextLayer.colors[0].slice(3, 5), 16);
            const b2 = parseInt(nextLayer.colors[0].slice(5, 7), 16);

            const r3 = parseInt(currentLayer.colors[1].slice(1, 3), 16);
            const g3 = parseInt(currentLayer.colors[1].slice(3, 5), 16);
            const b3 = parseInt(currentLayer.colors[1].slice(5, 7), 16);

            const r4 = parseInt(nextLayer.colors[1].slice(1, 3), 16);
            const g4 = parseInt(nextLayer.colors[1].slice(3, 5), 16);
            const b4 = parseInt(nextLayer.colors[1].slice(5, 7), 16);

            const topR = Math.round(r1 + (r2 - r1) * progressInLayer);
            const topG = Math.round(g1 + (g2 - g1) * progressInLayer);
            const topB = Math.round(b1 + (b2 - b1) * progressInLayer);

            const bottomR = Math.round(r3 + (r4 - r3) * progressInLayer);
            const bottomG = Math.round(g3 + (g4 - g3) * progressInLayer);
            const bottomB = Math.round(b3 + (b4 - b3) * progressInLayer);

            const topColor = `rgb(${topR}, ${topG}, ${topB})`;
            const bottomColor = `rgb(${bottomR}, ${bottomG}, ${bottomB})`;

            // 5. Create and apply the gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 6. Add procedural strata patterns based on depth
            ctx.save();
            for (let d = Math.floor(game.cameraY / 50) * 50; d < game.cameraY + canvas.height + 50; d += 50) {
                const y = d - game.cameraY;
                const currentDepthInMeters = d / 10;

                if (y > 0 && y < canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);

                    if (currentDepthInMeters < 1500) {
                        // Sedimentary layers: relatively straight lines
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.lineWidth = Math.random() * 2 + 1;
                        ctx.lineTo(canvas.width, y + (Math.random() - 0.5) * 5);
                    } else if (currentDepthInMeters < 3000) {
                        // Metamorphic layers: wavy, distorted lines
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                        ctx.lineWidth = Math.random() * 2.5 + 1;
                        ctx.quadraticCurveTo(
                            canvas.width / 2 + Math.sin(d / 100) * 50,
                            y + (Math.random() - 0.5) * 15,
                            canvas.width, 
                            y + (Math.random() - 0.5) * 10
                        );
                    } else {
                        // Igneous/Deeper layers: sharp, crystalline patterns
                        ctx.strokeStyle = 'rgba(255, 220, 180, 0.1)';
                        ctx.lineWidth = Math.random() * 1.5 + 0.5;
                        ctx.moveTo(Math.random() * 50, y);
                        for(let x = 50; x < canvas.width; x += Math.random() * 100 + 50) {
                            ctx.lineTo(x, y + (Math.random() - 0.5) * 25);
                        }
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();

            // 7. Add heat/magma effect for deep sections
            if (game.depth > 3000) {
                const heatIntensity = Math.min((game.depth - 3000) / 4000, 0.4);
                ctx.fillStyle = `rgba(255, 69, 0, ${heatIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Glowing cracks for very deep sections
                if (game.depth > 5000) {
                    ctx.save();
                    const crackCount = Math.min(10, Math.floor((game.depth - 5000) / 200));
                    ctx.globalAlpha = Math.min((game.depth - 5000) / 3000, 0.7);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500';
                    for (let i = 0; i < crackCount; i++) {
                        const y = Math.random() * canvas.height;
                        const x_start = Math.random() * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(x_start, y);
                        ctx.bezierCurveTo(
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 400, y + (Math.random() - 0.5) * 200
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            // --- END OF NEW BACKGROUND LOGIC ---

            // --- START BOREHOLE DRAWING ---
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Dark, semi-transparent for the tunnel
            ctx.lineWidth = 50; // Width of the borehole, wider than the drill
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            let firstVisibleSegment = true;
            game.pipeSegments.forEach(segment => {
                const screenY = segment.y - game.cameraY;
                // Only draw segments visible on screen
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisibleSegment) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisibleSegment = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });

            // Extend the tunnel to the current drill position
            if (game.pipeSegments.length > 0 && !firstVisibleSegment) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }

            ctx.stroke();
            ctx.restore();
            // --- END BOREHOLE DRAWING ---
            
            // ドリルパイプの描画
            ctx.save();
            ctx.strokeStyle = '#708090';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // パイプの本体
            ctx.beginPath();
            let firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });
            
            // 最後のセグメントから掘削機まで
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }
            
            ctx.stroke();
            
            // パイプのハイライト
            ctx.strokeStyle = '#A9A9A9';
            ctx.lineWidth = 10;
            ctx.beginPath();
            firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x - 5, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x - 5, screenY);
                    }
                }
            });
            
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX - 5, drillScreenY);
            }
            
            ctx.stroke();
            
            // パイプの継ぎ目
            ctx.fillStyle = '#606060';
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50 && index % 50 === 0) {
                    ctx.beginPath();
                    ctx.arc(segment.x, screenY, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 継ぎ目のボルト
                    ctx.fillStyle = '#404040';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i;
                        const boltX = segment.x + Math.cos(angle) * 10;
                        const boltY = screenY + Math.sin(angle) * 10;
                        ctx.beginPath();
                        ctx.arc(boltX, boltY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#606060';
                }
            });
            
            ctx.restore();
            
            // もぐら
            game.moles.forEach(mole => mole.draw());
            
            // 断層
            game.faults.forEach(fault => fault.draw());
            
            // マグマ溜まり
            game.magmaPools.forEach(pool => pool.draw());
            
            // 岩
            game.rocks.forEach(rock => rock.draw());
            
            // 蒸気孔
            game.steamVents.forEach(vent => vent.draw());
            
            // パーティクル
            game.particles.forEach(p => p.draw());
            
            // 掘削機
            const drillScreenY = game.drillY - game.cameraY;
            ctx.save();
            ctx.translate(game.drillX, drillScreenY);

            // ドリルの傾きを適用
            let tiltAngle = 0;
            const maxTilt = Math.PI / 16; // 傾きの最大角度（ラジアン）
            if (keys['ArrowLeft']) {
                tiltAngle = maxTilt; // 左キーで右に傾ける
            } else if (keys['ArrowRight']) {
                tiltAngle = -maxTilt; // 右キーで左に傾ける
            }
            ctx.rotate(tiltAngle);
            
            // PDCドリルビット（実際の画像を使用、回転アニメーション）- ドリル本体の後ろに配置
            ctx.save();
            ctx.translate(0, 70); // ドリル本体から少し下に配置（50から70に変更）
            
            // 画像を90度回転させて、さらに上下に180度回転、最後に30度回転させて正しい向きにする
            ctx.rotate(Math.PI / 2); // 90度回転
            ctx.rotate(Math.PI); // 上下に180度回転
            ctx.rotate(Math.PI / 6); // さらに30度回転
            ctx.rotate(Math.PI / 8); // さらに30度回転
            ctx.rotate(Math.PI / 8); // さらに30度回転
            ctx.rotate(Math.PI / 9); // さらに30度回転
             
        
        
           
            
            if (imageLoaded) {
                // 画像のサイズ調整（より大きなサイズに）
                const bitWidth = 100; // 60から100に拡大
                const bitHeight = 120; // 80から120に拡大
                
                // 高温時の効果
                if (game.temperature > 500) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = game.temperature > 800 ? '#FF4500' : '#FFD700';
                }
                
                // 高温時の色調変更
                if (game.temperature > 800) {
                    ctx.filter = 'hue-rotate(30deg) saturate(1.5) brightness(1.2)';
                } else if (game.temperature > 500) {
                    ctx.filter = 'saturate(1.2) brightness(1.1)';
                } else {
                    ctx.filter = 'none';
                }
                
                // PDCビット画像を描画（90度回転後の位置調整）
                ctx.drawImage(
                    drillBitImage, 
                    -bitWidth / 2, 
                    -bitHeight / 2, // 中央に配置
                    bitWidth, 
                    bitHeight
                );
                
                // フィルターをリセット
                ctx.filter = 'none';
                
                // 高温時の追加効果（オーバーレイ）
                if (game.temperature > 800) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bitWidth/2 + 8, bitHeight/2 + 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            } else {
                // 画像が読み込まれるまでの代替表示
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(-40, -50, 80, 100); // より大きなサイズ
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', 0, 0);
            }
            
            ctx.restore();
            
            // ドリル本体（PDCビットの上に描画）
            const gradient2 = ctx.createLinearGradient(-20, -30, 20, 30);
            gradient2.addColorStop(0, '#E0E0E0');
            gradient2.addColorStop(1, '#808080');
            ctx.fillStyle = gradient2;
            ctx.fillRect(-25, -40, 50, 80);
            
            // 排気
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = -50 - i * 10;
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, 5 + i * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // 深度マーカー
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 14px Arial';
            for (let d = Math.floor(game.cameraY / 100) * 100; d <= game.cameraY + canvas.height + 100; d += 100) {
                const y = d - game.cameraY;
                if (y > 0 && y < canvas.height) {
                    ctx.fillText(`${Math.floor(d / 10)}m`, 10, y);
                    ctx.fillRect(0, y, 40, 2);
                }
            }
            
            // 画面端の警告
            if (game.drillX < 100 || game.drillX > canvas.width - 100) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (game.drillX < 100) {
                    ctx.fillRect(0, 0, 50, canvas.height);
                } else {
                    ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);
                }
            }
        }
        
        function updateUI() {
            document.getElementById('depth').textContent = game.depth;
            document.getElementById('temperature').textContent = Math.floor(game.temperature);
            document.getElementById('drillSpeed').textContent = game.drillSpeed.toFixed(1);
            document.getElementById('drillEnergy').style.width = `${Math.max(0, (game.drillDurability / game.drillMaxDurability) * 100)}%`;
            
            // 耐久度による色変更
            const durabilityRatio = game.drillDurability / game.drillMaxDurability;
            if (durabilityRatio < 0.3) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #8B0000, #FF0000)';
            } else if (durabilityRatio < 0.6) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF8C00, #FFD700)';
            } else {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF4500, #FFD700)';
            }
        }
        
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }
        
        
        function gameOver(reason = null) {
            game.gameRunning = false;
            document.getElementById('finalDepth').textContent = game.maxDepth;
            document.getElementById('maxTemp').textContent = Math.floor(game.maxTemp);
            
            // ゲームオーバーの理由を表示
            const gameOverDiv = document.getElementById('gameOver');
            const h2 = gameOverDiv.querySelector('h2');
            if (reason) {
                h2.textContent = reason;
            } else {
                h2.textContent = 'ゲームオーバー';
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        function resetGame() {
            game = {
                depth: 0,
                energy: 0,
                temperature: 15,
                drillX: 600,
                drillY: 0,
                drillSpeed: 2.5, // 初期速度を2.5倍に増加
                drillDurability: 100,
                drillMaxDurability: 100,
                cooling: 1,
                particles: [],
                rocks: [],
                steamVents: [],
                magmaPools: [],
                faults: [], // 断層
                moles: [], // もぐら
                pipeSegments: [], // ドリルパイプのセグメント
                maxDepth: 0,
                maxTemp: 15,
                gameRunning: true,
                cameraY: 0,
                generatedSpawns: new Set(),
                upgrades: {
                    speed: { level: 1, cost: 10 },
                    durability: { level: 1, cost: 15 },
                    cooling: { level: 1, cost: 20 }
                }
            };
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }
        
        // アップグレード機能は現在UIにないため、一旦コメントアウトします。
        /*
        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (game.energy >= game.upgrades.speed.cost) {
                game.energy -= game.upgrades.speed.cost;
                game.drillSpeed += 0.8;  // 0.3 → 0.8に増加
                game.upgrades.speed.level++;
                game.upgrades.speed.cost = Math.floor(game.upgrades.speed.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeDurability').addEventListener('click', () => {
            if (game.energy >= game.upgrades.durability.cost) {
                game.energy -= game.upgrades.durability.cost;
                game.drillMaxDurability += 50;
                game.drillDurability += 50;
                game.upgrades.durability.level++;
                game.upgrades.durability.cost = Math.floor(game.upgrades.durability.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeCooling').addEventListener('click', () => {
            if (game.energy >= game.upgrades.cooling.cost) {
                game.energy -= game.upgrades.cooling.cost;
                game.cooling += 0.5;
                game.upgrades.cooling.level++;
                game.upgrades.cooling.cost = Math.floor(game.upgrades.cooling.cost * 2);
                updateUI();
            }
        });
        */
        
        // キー入力
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = false;
        });
        
        // タッチ操作対応
        let touchStartX = null;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (touchStartX !== null) {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                
                if (diff < -30) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else if (diff > 30) {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }
            }
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', () => {
            touchStartX = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });
        
        // モバイル用タッチボタン
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        
        // マウスでも動作するように
        leftButton.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
        leftButton.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
        rightButton.addEventListener('mousedown', () => keys['ArrowRight'] = true);
        rightButton.addEventListener('mouseup', () => keys['ArrowRight'] = false);
        
        // ゲーム開始時にリサイズ
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game.gameRunning = true;
            resizeGame(); // リサイズを実行
            gameLoop();
        }
    </script>
</body>
</html>