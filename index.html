<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœ°ç†±äº•æˆ¸æ˜å‰Šã‚²ãƒ¼ãƒ </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #8B4513 20%, #654321 40%, #3E2723 60%, #D2691E 80%, #FF4500 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1200px, 95vw);
            height: min(800px, 85vh);
            max-width: 100%;
            max-height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: min(20px, 2vw);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: min(15px, 2vw);
            border-radius: min(10px, 1.5vw);
            border: 2px solid #FF4500;
            font-size: min(14px, 3vw);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #stats {
            top: min(20px, 2vh);
            left: min(20px, 2vw);
            min-width: min(200px, 40vw);
        }

        #controls {
            top: 20px;
            right: 20px;
            pointer-events: all;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #FF4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
        }

        button {
            background: #FF4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            background: #FF6347;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        .stat-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
        }

        .energy-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #FFD700;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #FF4500, #FFD700);
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        h1, h2 {
            margin: 10px 0;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        .upgrade-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #228B22;
            margin-top: 5px;
        }

        .upgrade-btn:hover {
            background: #32CD32;
        }

        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 1000;
        }

        #startScreen h1 {
            font-size: 48px;
            color: #FF4500;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .instructions {
            margin: 20px 0;
            font-size: 18px;
            line-height: 1.5;
        }

        .warning {
            color: #FF6347;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #mobileControls {
            position: absolute;
            bottom: min(20px, 2vh);
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: min(20px, 3vw);
            z-index: 1000;
        }

        .touch-button {
            width: min(80px, 15vw);
            height: min(80px, 15vw);
            background: rgba(255, 69, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-size: min(24px, 4vw);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            touch-action: manipulation;
        }

        .touch-button:active {
            background: rgba(255, 69, 0, 1);
            transform: scale(0.95);
        }

        @media (max-width: 768px) or (max-height: 600px) {
            #mobileControls {
                display: flex;
            }
            
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }
            
            .info-panel {
                font-size: max(12px, 2.5vw);
                padding: max(8px, 1.5vw);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="1000"></canvas>
        <div id="ui">
            <div id="stats" class="info-panel">
                <h2>æ˜å‰ŠçŠ¶æ³</h2>
                <div>æ·±åº¦: <span class="stat-value" id="depth">0</span> m</div>
                <div>æ¸©åº¦: <span class="stat-value" id="temperature">15</span> â„ƒ</div>
                <div>æ˜å‰Šé€Ÿåº¦: <span class="stat-value" id="drillSpeed">2.5</span> m/s</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="drillEnergy"></div>
                </div>
                <div style="font-size: 12px;">ãƒ‰ãƒªãƒ«è€ä¹…åº¦</div>
                <div id="warningText" class="warning" style="display: none;">âš ï¸ é«˜æ¸©æ³¨æ„ï¼</div>
            </div>
        </div>
        
        <div id="startScreen">
            <h1>ğŸ”¥ åœ°ç†±äº•æˆ¸æ˜å‰Šã‚²ãƒ¼ãƒ  ğŸ”¥</h1>
            <div class="instructions">
                <p>è‡ªå‹•ã§åœ°çƒã®æ·±éƒ¨ã¸æ˜ã‚Šé€²ã¿ã¾ã™ï¼</p>
                <p>â† â†’ ã‚­ãƒ¼ã§æ˜å‰Šæ©Ÿã‚’å·¦å³ã«ç§»å‹•ã—ã¦éšœå®³ç‰©ã‚’é¿ã‘ã‚ˆã†</p>
                <p>å²©ã«ã¶ã¤ã‹ã‚‹ã¨ãƒ‰ãƒªãƒ«ãŒæ¶ˆè€—ã—ã¾ã™</p>
                <p>è’¸æ°—å­”ã«è¿‘ã¥ãã¨ãƒœãƒ¼ãƒŠã‚¹ã‚¨ãƒãƒ«ã‚®ãƒ¼ç²å¾—ï¼</p>
                <p>ã‚ˆã‚Šæ·±ãæ˜ã‚‹ã»ã©é«˜æ¸©ã«ãªã‚Šã€å¤šãã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’ç²å¾—ã§ãã¾ã™</p>
            </div>
            <button onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        </div>
        
        <div id="gameOver">
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <p>æœ€çµ‚æ·±åº¦: <span id="finalDepth">0</span> m</p>
            <p>æœ€é«˜æ¸©åº¦: <span id="maxTemp">0</span> â„ƒ</p>
            <button onclick="resetGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
        </div>
        
        <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div id="mobileControls">
            <div class="touch-button" id="leftButton">â†</div>
            <div class="touch-button" id="rightButton">â†’</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // PDCãƒ“ãƒƒãƒˆç”»åƒã®èª­ã¿è¾¼ã¿
        const drillBitImage = new Image();
        drillBitImage.src = 'Gemini_Generated_Image_sfxgpisfxgpisfxg.png';
        let imageLoaded = false;
        drillBitImage.onload = function() {
            imageLoaded = true;
        };
        
        // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            const scaleX = containerRect.width / 1200;
            const scaleY = containerRect.height / 1000;
            const scale = Math.min(scaleX, scaleY);
            
            canvas.style.transform = `scale(${scale})`;
            canvas.style.transformOrigin = 'top left';
            
            // ã‚²ãƒ¼ãƒ å†…åº§æ¨™ã‚‚èª¿æ•´
            if (game.drillX === 600) { // åˆæœŸä½ç½®ã®å ´åˆ
                game.drillX = 1200 * 0.5; // ç”»é¢ä¸­å¤®
            }
        }
        
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeGame, 100);
        });
        
        let game = {
            depth: 0,
            temperature: 15,
            drillX: 600,
            drillY: 0,
            drillSpeed: 2.5, // åˆæœŸé€Ÿåº¦ã‚’2.5å€ã«å¢—åŠ 
            drillDurability: 100,
            drillMaxDurability: 100,
            particles: [],
            rocks: [],
            steamVents: [],
            magmaPools: [],
            faults: [], // æ–­å±¤
            moles: [], // ã‚‚ãã‚‰
            pipeSegments: [], // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
            maxDepth: 0,
            maxTemp: 15,
            gameRunning: false,
            cameraY: 0
        };
        
        const keys = {};
        
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.type = type;

                if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() * -10) - 5;
                    this.size = Math.random() * 4 + 1;
                    this.gravity = 0.4;
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = Math.random() * -5 - 2;
                    this.size = Math.random() * 5 + 2;
                    this.gravity = 0.3;
                }
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= 0.03;
                this.size *= 0.97;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'rock') {
                    ctx.fillStyle = '#8B4513';
                } else if (this.type === 'steam') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                } else if (this.type === 'lava') {
                    ctx.fillStyle = '#FF4500';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF4500';
                } else if (this.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFD700';
                }
                
                const screenY = this.y - game.cameraY;
                ctx.beginPath();
                ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Rock {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 100 + 50;
                this.height = Math.random() * 60 + 30;
                this.hardness = Math.random() * 3 + 1;
                this.hit = false;
                this.points = [];
                // Generate irregular shape points
                const numPoints = Math.floor(Math.random() * 5) + 8; // 8-12 points
                const angleStep = (Math.PI * 2) / numPoints;
                for (let i = 0; i < numPoints; i++) {
                    const angle = i * angleStep;
                    const radius = (Math.random() * 0.3 + 0.7) * Math.min(this.width, this.height) / 2;
                    this.points.push({
                        x: radius * Math.cos(angle),
                        y: radius * Math.sin(angle)
                    });
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                if (this.hit) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Base rock color with gradient
                const gradient = ctx.createLinearGradient(0, -this.height / 2, 0, this.height / 2);
                gradient.addColorStop(0, `rgba(150, 75, 0, ${0.8 / this.hardness})`); // Lighter brown
                gradient.addColorStop(0.5, `rgba(139, 69, 19, ${0.8 / this.hardness})`); // Medium brown
                gradient.addColorStop(1, `rgba(100, 50, 0, ${0.8 / this.hardness})`); // Darker brown
                ctx.fillStyle = gradient;

                // Draw irregular shape
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();

                // Add some texture/noise
                ctx.fillStyle = `rgba(0, 0, 0, ${0.1 / this.hardness})`;
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * this.width - this.width / 2, Math.random() * this.height - this.height / 2, Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Gold outline and shadow
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 15;
                ctx.strokeStyle = '#FFD700'; // Gold outline
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        class SteamVent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = true;
                this.timer = 0;
                this.radius = 20;
            }
            
            update() {
                this.timer++;
                if (this.timer % 3 === 0 && this.active) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 20,
                        this.y,
                        'steam'
                    ));
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);

                // è’¸æ°—å­”ã®ç©´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // è’¸æ°—å­”ã®å…‰
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // è’¸æ°—ã®è¡¨ç¾ (ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã§æç”»ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯è¿½åŠ ã®è¦–è¦šåŠ¹æœã®ã¿)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }
        
        class Mole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.width = 40;
                this.height = 30;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.animationTime = 0;
                this.tunnelX = x;
                this.surprised = false;
                this.fleeing = false;
            }
            
            update() {
                this.animationTime++;
                
                // ãƒ‰ãƒªãƒ«ã¨ã®è·é›¢ã‚’è¨ˆç®—
                const distance = Math.sqrt(
                    Math.pow(this.x - game.drillX, 2) + 
                    Math.pow(this.y - game.drillY, 2)
                );
                
                // ãƒ‰ãƒªãƒ«ãŒè¿‘ã¥ã„ãŸã‚‰é©šã„ã¦é€ƒã’ã‚‹
                if (distance < 150 && !this.fleeing) {
                    this.surprised = true;
                    this.fleeing = true;
                    this.vx = (this.x - game.drillX) * 0.1;
                    this.vy = -2;
                }
                
                if (this.fleeing) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.95;
                    this.vy += 0.1;
                } else {
                    // é€šå¸¸ã®ç§»å‹•
                    this.x += Math.sin(this.animationTime * 0.05) * 0.5 * this.direction;
                    
                    // ç”»é¢ç«¯ã§æ–¹å‘è»¢æ›
                    if (this.x < 50 || this.x > canvas.width - 50) {
                        this.direction *= -1;
                    }
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                // ã‚‚ãã‚‰ã®ç©´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ã‚‚ãã‚‰ã®ä½“ (ã‚ˆã‚Šæœ‰æ©Ÿçš„ãªå½¢çŠ¶ã¨æ¯›ä¸¦ã¿)
                ctx.fillStyle = '#4B3621';
                ctx.strokeStyle = '#3A2B1A';
                ctx.lineWidth = 1;
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // æ¯›ä¸¦ã¿ã®è¡¨ç¾ (ç°¡å˜ãªç·šã§)
                for(let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                    ctx.lineTo(radius * Math.cos(angle) * 1.2, radius * Math.sin(angle) * 1.2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.stroke();
                }
                
                // ã‚‚ãã‚‰ã®é ­
                ctx.fillStyle = '#5C4033';
                ctx.beginPath();
                ctx.ellipse(this.direction * 15, -5, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // é¼» (ã‚ˆã‚Šãƒªã‚¢ãƒ«ã«)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(this.direction * 22, -5, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç›® (è¡¨æƒ…è±Šã‹ã«)
                if (this.surprised) {
                    // é©šã„ãŸç›®
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 4, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // é€šå¸¸ã®ç›®
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // æ‰‹ (ã‚ˆã‚Šè©³ç´°ã«)
                ctx.fillStyle = '#4B3621';
                ctx.beginPath();
                ctx.ellipse(-10, 5, 6, 8, -0.3, 0, Math.PI * 2);
                ctx.ellipse(10, 5, 6, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // åœŸã®ç²’å­
                if (!this.fleeing && Math.random() < 0.3) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 30,
                        this.y + 10,
                        'rock'
                    ));
                }
                
                // é©šããƒãƒ¼ã‚¯
                if (this.surprised && !this.fleeing) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', 0, -25);
                }
                
                ctx.restore();
            }
        }
        
        class Fault {
            constructor(y) {
                this.y = y;
                this.leftX = Math.random() * 200 + 100;
                this.rightX = this.leftX + Math.random() * 200 + 150;
                this.height = 30;
                this.warningHeight = 100;
                this.particles = [];
                this.crackPoints = [];
                // äº€è£‚ã®å½¢çŠ¶ã‚’ç”Ÿæˆ
                const numPoints = Math.floor(Math.random() * 5) + 5; // 5-9 points
                for (let i = 0; i <= numPoints; i++) {
                    const x = this.leftX + (this.rightX - this.leftX) * (i / numPoints);
                    const yOffset = (Math.random() - 0.5) * 40; // Vertical variation
                    this.crackPoints.push({ x: x, y: yOffset });
                }
            }
            
            update() {
                // è­¦å‘Šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                if (Math.random() < 0.3) {
                    const x = this.leftX + Math.random() * (this.rightX - this.leftX);
                    this.particles.push({
                        x: x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= 0.02;
                    p.size *= 0.98;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -this.warningHeight || screenY > canvas.height + 50) return;
                
                // è­¦å‘Šã‚¾ãƒ¼ãƒ³ï¼ˆæ–­å±¤ã®ä¸Šï¼‰
                if (screenY > -this.warningHeight && screenY < this.height) {
                    ctx.save();
                    const gradient = ctx.createLinearGradient(0, screenY - this.warningHeight, 0, screenY);
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                    gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0.6)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, screenY - this.warningHeight, this.leftX + 10, this.warningHeight);
                    ctx.fillRect(this.rightX - 10, screenY - this.warningHeight, canvas.width - (this.rightX - 10), this.warningHeight);
                    ctx.restore();
                }
                
                // å®‰å…¨ã‚¾ãƒ¼ãƒ³ï¼ˆç·‘è‰²ã§è¡¨ç¤ºï¼‰
                if (screenY > -this.warningHeight && screenY < this.height + 20) {
                    ctx.save();
                    const safeGradient = ctx.createLinearGradient(0, screenY - this.warningHeight, 0, screenY + 20);
                    safeGradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
                    safeGradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.3)');
                    safeGradient.addColorStop(1, 'rgba(0, 255, 0, 0.1)');
                    ctx.fillStyle = safeGradient;
                    ctx.fillRect(this.leftX + 10, screenY - this.warningHeight, 
                                (this.rightX - 10) - (this.leftX + 10), this.warningHeight + 20);
                    ctx.restore();
                }
                
                // æ–­å±¤æœ¬ä½“ï¼ˆäº€è£‚ã®ã‚ˆã†ã«æç”»ï¼‰
                ctx.save();
                ctx.strokeStyle = '#333333'; // äº€è£‚ã®è‰²
                ctx.lineWidth = 10; // äº€è£‚ã®å¤ªã•
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#000';

                ctx.beginPath();
                ctx.moveTo(this.crackPoints[0].x, screenY + this.crackPoints[0].y);
                for (let i = 1; i < this.crackPoints.length; i++) {
                    ctx.lineTo(this.crackPoints[i].x, screenY + this.crackPoints[i].y);
                }
                ctx.stroke();

                // äº€è£‚ã®å…‰ã‚‹ç¸
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(this.crackPoints[0].x, screenY + this.crackPoints[0].y);
                for (let i = 1; i < this.crackPoints.length; i++) {
                    ctx.lineTo(this.crackPoints[i].x, screenY + this.crackPoints[i].y);
                }
                ctx.stroke();
                
                // è­¦å‘Šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                
                // è­¦å‘Šãƒ†ã‚­ã‚¹ãƒˆ
                if (screenY > 0 && screenY < canvas.height) {
                    ctx.save();
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 24px Arial'; // 20pxã‹ã‚‰å¢—åŠ 
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15; // 10ã‹ã‚‰å¢—åŠ 
                    ctx.shadowColor = '#FF0000';
                    ctx.fillText('âš  æ–­å±¤ âš ', canvas.width / 2, screenY - 40);
                    ctx.restore();
                }
            }
        }
        
        function generateTerrain() {
            // ç”»é¢ä¸‹ç«¯ã‹ã‚‰å°‘ã—å…ˆã®ä½ç½®ã§éšœå®³ç‰©ã‚’ç”Ÿæˆ
            const spawnY = game.cameraY + canvas.height + 200;
            const spawnCheck = Math.floor(spawnY / 100) * 100;
            
            if (!game.generatedSpawns) game.generatedSpawns = new Set();
            
            if (!game.generatedSpawns.has(spawnCheck)) {
                game.generatedSpawns.add(spawnCheck);
                
                // ã‚‚ãã‚‰ï¼ˆ500-2000mã®éƒ¨åˆ†ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth >= 500 && game.depth < 2000) {
                    if (Math.random() < 0.3) {
                        game.moles.push(new Mole(
                            Math.random() * (canvas.width - 100) + 50,
                            spawnY
                        ));
                    }
                }
                
                // å²©ã®ç”Ÿæˆ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                const rockCount = Math.floor(Math.random() * 2) + 1 + Math.floor(game.depth / 2000);
                for (let i = 0; i < rockCount; i++) {
                    const rock = new Rock(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    );
                    rock.hardness += game.depth / 3000;
                    game.rocks.push(rock);
                }
                
                // è’¸æ°—å­”ï¼ˆ1500mä»¥é™ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth > 1500 && Math.random() < 0.2 + game.depth / 8000) {
                    game.steamVents.push(new SteamVent(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // æ–­å±¤ï¼ˆ2500mä»¥é™ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth > 2500) {
                    const faultChance = 0.1 + (game.depth - 2500) / 15000;
                    if (Math.random() < faultChance) {
                        game.faults.push(new Fault(spawnY + Math.random() * 100));
                    }
                }
            }
        }
        
        function updateGame() {
            if (!game.gameRunning) return;

            // --- START OF NEW EFFECTS ---

            // 1. Continuous screen shake for drilling vibration
            const shakeIntensity = Math.min(game.drillSpeed / 10, 1.5);
            const shakeX = (Math.random() - 0.5) * shakeIntensity;
            const shakeY = (Math.random() - 0.5) * shakeIntensity;
            canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;

            // 2. Continuous drilling particle generation
            const particleCount = Math.ceil(game.drillSpeed); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å¢—åŠ 
            for (let i = 0; i < particleCount; i++) {
                let particleType = 'rock';
                if (game.depth > 5000) {
                    particleType = 'lava';
                } else if (game.depth > 3000) {
                    if (Math.random() < 0.5) particleType = 'lava';
                }
                game.particles.push(new Particle(
                    game.drillX + (Math.random() - 0.5) * 30,
                    game.drillY + 60, // ãƒ‰ãƒªãƒ«ã®å…ˆç«¯ã‚ˆã‚Šå°‘ã—ä¸‹ã‹ã‚‰ç™ºç”Ÿ
                    particleType
                ));
            }

            // 3. Spark generation at high temperatures
            if (game.temperature > 800) {
                if (Math.random() < (game.temperature - 800) / 1000) {
                    game.particles.push(new Particle(game.drillX, game.drillY + 40, 'spark'));
                }
            }

            // --- END OF NEW EFFECTS ---
            
            // ãƒ‘ã‚¤ãƒ—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¿½åŠ ï¼ˆ10ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ï¼‰
            if (game.pipeSegments.length === 0 || 
                game.drillY - game.pipeSegments[game.pipeSegments.length - 1].y > 10) {
                game.pipeSegments.push({
                    x: game.drillX,
                    y: game.drillY,
                    angle: Math.atan2(
                        game.drillX - (game.pipeSegments.length > 0 ? 
                            game.pipeSegments[game.pipeSegments.length - 1].x : game.drillX),
                        10
                    )
                });
            }
            
            // è‡ªå‹•æ˜å‰Šï¼ˆä¸‹æ–¹å‘ã¸ã®ç§»å‹•ï¼‰
            game.drillY += game.drillSpeed;
            game.depth = Math.floor(game.drillY / 10);
            game.maxDepth = Math.max(game.maxDepth, game.depth);
            
            // ã‚«ãƒ¡ãƒ©ã®è¿½å¾“
            game.cameraY = game.drillY - 100;
            
            // å·¦å³ç§»å‹•ï¼ˆé€Ÿåº¦åˆ¶é™ï¼‰
            const baseMoveSpeed = 1.5; // åŸºæœ¬ç§»å‹•é€Ÿåº¦ã‚’ã•ã‚‰ã«ä½ãè¨­å®š
            const moveSpeed = baseMoveSpeed + (game.drillSpeed * 0.1); // æ˜å‰Šé€Ÿåº¦ã®å½±éŸ¿ã‚’æœ€å°é™ã«
            const maxMoveSpeed = 2.5; // æœ€å¤§ç§»å‹•é€Ÿåº¦ã‚’ã•ã‚‰ã«åˆ¶é™
            const actualMoveSpeed = Math.min(moveSpeed, maxMoveSpeed);
            
            if (keys['ArrowLeft'] && game.drillX > 50) {
                game.drillX -= actualMoveSpeed;
            }
            if (keys['ArrowRight'] && game.drillX < canvas.width - 50) {
                game.drillX += actualMoveSpeed;
            }
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚­ãƒ¼å…¥åŠ›ã®ç¢ºèª
            // console.log('Keys:', keys, 'DrillX:', game.drillX);
            
            // æ¸©åº¦ä¸Šæ˜‡
            game.temperature = 15 + game.depth * 0.035;
            if (game.depth > 3000) {
                game.temperature += (game.depth - 3000) * 0.05; // 3000mä»¥é™ã¯æ€¥æ¿€ã«æ¸©åº¦ä¸Šæ˜‡
            }
            game.maxTemp = Math.max(game.maxTemp, game.temperature);
            
            // è¡çªãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            let hitObstacle = false;
            
            // è­¦å‘Šè¡¨ç¤º
            document.getElementById('warningText').style.display = 
                game.temperature > 1000 ? 'block' : 'none';
            
            // åœ°å½¢ç”Ÿæˆ
            generateTerrain();
            
            // ã‚‚ãã‚‰ã®æ›´æ–°ã¨è¡çªãƒã‚§ãƒƒã‚¯
            game.moles.forEach(mole => {
                mole.update();
                
                // ã‚‚ãã‚‰ã¨ã®è¡çªï¼ˆãƒ€ãƒ¡ãƒ¼ã‚¸ã¯å°‘ãªã„ï¼‰
                if (!mole.fleeing &&
                    Math.abs(mole.x - game.drillX) < 30 &&
                    Math.abs(mole.y - game.drillY) < 30) {
                    
                    game.drillDurability -= 5;
                    hitObstacle = true;
                    mole.surprised = true;
                    mole.fleeing = true;
                    
                    // ã‹ã‚ã„ã„è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 5; i++) {
                        game.particles.push(new Particle(mole.x, mole.y, 'rock'));
                    }
                }
            });
            
            // å²©ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
            game.rocks.forEach(rock => {
                if (!rock.hit &&
                    Math.abs(rock.x - game.drillX) < (rock.width/2 + 20) &&
                    Math.abs(rock.y - game.drillY) < (rock.height/2 + 30)) {
                    
                    rock.hit = true;
                    game.drillDurability -= rock.hardness * 3;
                    hitObstacle = true;
                    
                    // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (å²©ã¨ç«èŠ±)
                    for (let i = 0; i < 15; i++) {
                        game.particles.push(new Particle(game.drillX, game.drillY + 40, i < 10 ? 'rock' : 'spark'));
                    }
                    
                    // ç”»é¢ã®æºã‚ŒåŠ¹æœï¼ˆå¼·åŒ–ï¼‰
                    canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    setTimeout(() => canvas.style.transform = '', 150);
                }
            });
            
            // è’¸æ°—å­”ãƒœãƒ¼ãƒŠã‚¹
            game.steamVents.forEach(vent => {
                vent.update();
                const distance = Math.sqrt(
                    Math.pow(vent.x - game.drillX, 2) + 
                    Math.pow(vent.y - game.drillY, 2)
                );
                if (distance < 50) {
                    // è¿‘ãã«ã„ã‚‹ã¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¢—åŠ 
                    if (Math.random() < 0.3) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'steam'));
                    }
                }
            });
            
            // ãƒã‚°ãƒæºœã¾ã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸
            game.magmaPools.forEach(pool => {
                pool.update();
                if (Math.abs(pool.x - game.drillX) < pool.width/2 &&
                    Math.abs(pool.y - game.drillY) < 50) {
                    game.drillDurability -= 0.5;
                    hitObstacle = true;
                    
                    if (Math.random() < 0.2) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'lava'));
                    }
                }
            });
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            game.particles.forEach(p => p.update());
            game.particles = game.particles.filter(p => p.life > 0);
            
            // ãƒ‰ãƒªãƒ«è€ä¹…åº¦ã®å›å¾©ï¼ˆéšœå®³ç‰©ã«å½“ãŸã£ã¦ã„ãªã„æ™‚ã®ã¿ï¼‰
            if (!hitObstacle && game.drillDurability < game.drillMaxDurability) {
                game.drillDurability += 0.1; // å›å¾©é€Ÿåº¦ã‚’ä¸Šã’ã‚‹
                game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
            }
            
            // æ˜å‰Šé€Ÿåº¦ã®è‡ªå‹•å¢—åŠ ï¼ˆæ·±åº¦ãƒœãƒ¼ãƒŠã‚¹ + åŠ é€Ÿåº¦çš„å¢—åŠ ï¼‰
            if (game.depth % 300 === 0 && game.depth > 0) {  // 500m â†’ 300mã”ã¨ã«åŠ é€Ÿ
                game.drillSpeed += 0.3;  // 0.1 â†’ 0.3ã«å¢—åŠ 
            }
            
            // 2000mä»¥é™ã•ã‚‰ã«åŠ é€Ÿï¼ˆ3000m â†’ 2000mã«æ—©ã‚ã‚‹ï¼‰
            if (game.depth > 2000) {
                game.drillSpeed += 0.002 * (game.depth - 2000) / 100;  // åŠ é€Ÿåº¦ã‚’2å€ã«
            }
            
            // æ–­å±¤ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
            game.faults.forEach(fault => {
                fault.update();
                
                // ãƒ‰ãƒªãƒ«ã®ã‚µã‚¤ã‚ºã‚’è€ƒæ…®ã—ãŸå½“ãŸã‚Šåˆ¤å®šï¼ˆã‚ˆã‚Šæ­£ç¢ºã«ï¼‰
                const drillWidth = 60; // ãƒ‰ãƒªãƒ«ãƒ“ãƒƒãƒˆã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´
                const drillLeft = game.drillX - drillWidth / 2;
                const drillRight = game.drillX + drillWidth / 2;
                const drillTop = game.drillY - 30; // ãƒ‰ãƒªãƒ«ä¸Šéƒ¨
                const drillBottom = game.drillY + 80; // ãƒ‰ãƒªãƒ«ãƒ“ãƒƒãƒˆä¸‹ç«¯ã¾ã§
                
                // æ–­å±¤ã®ç¯„å›²
                const faultTop = fault.y - fault.height / 2;
                const faultBottom = fault.y + fault.height / 2;
                
                // å‚ç›´æ–¹å‘ã®é‡ãªã‚Šåˆ¤å®š
                if (drillBottom > faultTop && drillTop < faultBottom) {
                    // æ–­å±¤ã®å®‰å…¨ã‚¾ãƒ¼ãƒ³ï¼ˆéš™é–“ï¼‰- ã‚ˆã‚Šå¯›å®¹ã«
                    const safeZoneLeft = fault.leftX + 15; // ä½™è£•ã‚’å¢—ã‚„ã™
                    const safeZoneRight = fault.rightX - 15;
                    
                    // ãƒ‰ãƒªãƒ«å…¨ä½“ãŒå®‰å…¨ã‚¾ãƒ¼ãƒ³å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    const isInSafeZone = (drillLeft >= safeZoneLeft && drillRight <= safeZoneRight);
                    
                    if (!isInSafeZone) {
                        // è­¦å‘Šã‚¾ãƒ¼ãƒ³ã®åˆ¤å®šï¼ˆæ®µéšçš„ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
                        const warningZoneWidth = 25; // è­¦å‘Šã‚¾ãƒ¼ãƒ³ã‚’åºƒã’ã‚‹
                        const leftWarningZone = safeZoneLeft - warningZoneWidth;
                        const rightWarningZone = safeZoneRight + warningZoneWidth;
                        
                        // ãƒ‰ãƒªãƒ«ã®ä¸€éƒ¨ãŒè­¦å‘Šã‚¾ãƒ¼ãƒ³ã«ã‚ã‚‹å ´åˆ
                        const isInWarningZone = 
                            (drillRight > leftWarningZone && drillLeft < safeZoneLeft) ||
                            (drillLeft < rightWarningZone && drillRight > safeZoneRight);
                        
                        if (isInWarningZone) {
                            // è­¦å‘Šæ®µéšï¼šè»½ã„ãƒ€ãƒ¡ãƒ¼ã‚¸
                            game.drillDurability -= 0.3; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’è»½æ¸›
                            hitObstacle = true;
                            
                            // è­¦å‘Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                            if (Math.random() < 0.15) {
                                for (let i = 0; i < 2; i++) {
                                    game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                                }
                            }
                        } else {
                            // å±é™ºã‚¾ãƒ¼ãƒ³ï¼šé‡ã„ãƒ€ãƒ¡ãƒ¼ã‚¸
                            const isDangerZone = 
                                drillRight < leftWarningZone || drillLeft > rightWarningZone;
                            
                            if (isDangerZone) {
                                // å³åº§ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã¯ãªãã€é‡ã„ãƒ€ãƒ¡ãƒ¼ã‚¸
                                game.drillDurability -= 5; // é‡ã„ãƒ€ãƒ¡ãƒ¼ã‚¸
                                hitObstacle = true;
                                
                                // æ¿€ã—ã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                                for (let i = 0; i < 8; i++) {
                                    game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                                }
                                
                                // ç”»é¢æºã‚Œ
                                canvas.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
                                setTimeout(() => canvas.style.transform = '', 100);
                            }
                        }
                    }
                }
            });
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
            if (game.drillDurability <= 0) {
                gameOver();
            }
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆç”»é¢å¤–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ï¼‰
            game.rocks = game.rocks.filter(rock => rock.y > game.cameraY - 200);
            game.steamVents = game.steamVents.filter(vent => vent.y > game.cameraY - 200);
            game.magmaPools = game.magmaPools.filter(pool => pool.y > game.cameraY - 200);
            game.faults = game.faults.filter(fault => fault.y > game.cameraY - 200);
            game.moles = game.moles.filter(mole => mole.y > game.cameraY - 200 && mole.y < game.cameraY + canvas.height + 200);
            game.pipeSegments = game.pipeSegments.filter(segment => segment.y > game.cameraY - 100);
            
            updateUI();
        }
        
        function drawGame() {
            // --- START OF NEW BACKGROUND LOGIC ---

            // 1. Define colors for different geological layers
            const layers = [
                { depth: 0,    colors: ['#87CEEB', '#A0522D'] }, // Surface: Sky to Soil
                { depth: 500,  colors: ['#A0522D', '#8B4513'] }, // Soil to Sediment
                { depth: 1500, colors: ['#696969', '#505050'] }, // Sedimentary/Metamorphic Rock (Greys)
                { depth: 3000, colors: ['#3E2723', '#2E1F1A'] }, // Igneous Rock (Dark Browns)
                { depth: 5000, colors: ['#2E1F1A', '#8B0000'] }, // Close to Mantle (Dark Red)
                { depth: 7000, colors: ['#8B0000', '#FF4500'] }  // Magma (Red to Orange)
            ];

            // 2. Determine the current and next layer based on depth
            let currentLayer = layers[0];
            let nextLayer = layers[1];
            for (let i = 0; i < layers.length - 1; i++) {
                if (game.depth >= layers[i].depth) {
                    currentLayer = layers[i];
                    nextLayer = layers[i+1];
                }
            }
            
            // 3. Calculate the transition progress between the two layers
            const layerDepthSpan = nextLayer.depth - currentLayer.depth;
            const progressInLayer = (game.depth - currentLayer.depth) / layerDepthSpan;
            
            // 4. Interpolate colors based on progress
            const r1 = parseInt(currentLayer.colors[0].slice(1, 3), 16);
            const g1 = parseInt(currentLayer.colors[0].slice(3, 5), 16);
            const b1 = parseInt(currentLayer.colors[0].slice(5, 7), 16);
            
            const r2 = parseInt(nextLayer.colors[0].slice(1, 3), 16);
            const g2 = parseInt(nextLayer.colors[0].slice(3, 5), 16);
            const b2 = parseInt(nextLayer.colors[0].slice(5, 7), 16);

            const r3 = parseInt(currentLayer.colors[1].slice(1, 3), 16);
            const g3 = parseInt(currentLayer.colors[1].slice(3, 5), 16);
            const b3 = parseInt(currentLayer.colors[1].slice(5, 7), 16);

            const r4 = parseInt(nextLayer.colors[1].slice(1, 3), 16);
            const g4 = parseInt(nextLayer.colors[1].slice(3, 5), 16);
            const b4 = parseInt(nextLayer.colors[1].slice(5, 7), 16);

            const topR = Math.round(r1 + (r2 - r1) * progressInLayer);
            const topG = Math.round(g1 + (g2 - g1) * progressInLayer);
            const topB = Math.round(b1 + (b2 - b1) * progressInLayer);

            const bottomR = Math.round(r3 + (r4 - r3) * progressInLayer);
            const bottomG = Math.round(g3 + (g4 - g3) * progressInLayer);
            const bottomB = Math.round(b3 + (b4 - b3) * progressInLayer);

            const topColor = `rgb(${topR}, ${topG}, ${topB})`;
            const bottomColor = `rgb(${bottomR}, ${bottomG}, ${bottomB})`;

            // 5. Create and apply the gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 6. Add procedural strata patterns based on depth
            ctx.save();
            for (let d = Math.floor(game.cameraY / 50) * 50; d < game.cameraY + canvas.height + 50; d += 50) {
                const y = d - game.cameraY;
                const currentDepthInMeters = d / 10;

                if (y > 0 && y < canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);

                    if (currentDepthInMeters < 1500) {
                        // Sedimentary layers: relatively straight lines
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.lineWidth = Math.random() * 2 + 1;
                        ctx.lineTo(canvas.width, y + (Math.random() - 0.5) * 5);
                    } else if (currentDepthInMeters < 3000) {
                        // Metamorphic layers: wavy, distorted lines
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                        ctx.lineWidth = Math.random() * 2.5 + 1;
                        ctx.quadraticCurveTo(
                            canvas.width / 2 + Math.sin(d / 100) * 50,
                            y + (Math.random() - 0.5) * 15,
                            canvas.width, 
                            y + (Math.random() - 0.5) * 10
                        );
                    } else {
                        // Igneous/Deeper layers: sharp, crystalline patterns
                        ctx.strokeStyle = 'rgba(255, 220, 180, 0.1)';
                        ctx.lineWidth = Math.random() * 1.5 + 0.5;
                        ctx.moveTo(Math.random() * 50, y);
                        for(let x = 50; x < canvas.width; x += Math.random() * 100 + 50) {
                            ctx.lineTo(x, y + (Math.random() - 0.5) * 25);
                        }
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();

            // 7. Add heat/magma effect for deep sections
            if (game.depth > 3000) {
                const heatIntensity = Math.min((game.depth - 3000) / 4000, 0.4);
                ctx.fillStyle = `rgba(255, 69, 0, ${heatIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Glowing cracks for very deep sections
                if (game.depth > 5000) {
                    ctx.save();
                    const crackCount = Math.min(10, Math.floor((game.depth - 5000) / 200));
                    ctx.globalAlpha = Math.min((game.depth - 5000) / 3000, 0.7);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500';
                    for (let i = 0; i < crackCount; i++) {
                        const y = Math.random() * canvas.height;
                        const x_start = Math.random() * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(x_start, y);
                        ctx.bezierCurveTo(
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 400, y + (Math.random() - 0.5) * 200
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            // --- END OF NEW BACKGROUND LOGIC ---

            // --- START BOREHOLE DRAWING ---
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Dark, semi-transparent for the tunnel
            ctx.lineWidth = 50; // Width of the borehole, wider than the drill
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            let firstVisibleSegment = true;
            game.pipeSegments.forEach(segment => {
                const screenY = segment.y - game.cameraY;
                // Only draw segments visible on screen
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisibleSegment) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisibleSegment = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });

            // Extend the tunnel to the current drill position
            if (game.pipeSegments.length > 0 && !firstVisibleSegment) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }

            ctx.stroke();
            ctx.restore();
            // --- END BOREHOLE DRAWING ---
            
            // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®æç”»
            ctx.save();
            ctx.strokeStyle = '#708090';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // ãƒ‘ã‚¤ãƒ—ã®æœ¬ä½“
            ctx.beginPath();
            let firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });
            
            // æœ€å¾Œã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‹ã‚‰æ˜å‰Šæ©Ÿã¾ã§
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }
            
            ctx.stroke();
            
            // ãƒ‘ã‚¤ãƒ—ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.strokeStyle = '#A9A9A9';
            ctx.lineWidth = 10;
            ctx.beginPath();
            firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x - 5, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x - 5, screenY);
                    }
                }
            });
            
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX - 5, drillScreenY);
            }
            
            ctx.stroke();
            
            // ãƒ‘ã‚¤ãƒ—ã®ç¶™ãç›®
            ctx.fillStyle = '#606060';
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50 && index % 50 === 0) {
                    ctx.beginPath();
                    ctx.arc(segment.x, screenY, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç¶™ãç›®ã®ãƒœãƒ«ãƒˆ
                    ctx.fillStyle = '#404040';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i;
                        const boltX = segment.x + Math.cos(angle) * 10;
                        const boltY = screenY + Math.sin(angle) * 10;
                        ctx.beginPath();
                        ctx.arc(boltX, boltY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#606060';
                }
            });
            
            ctx.restore();
            
            // ã‚‚ãã‚‰
            game.moles.forEach(mole => mole.draw());
            
            // æ–­å±¤
            game.faults.forEach(fault => fault.draw());
            
            // ãƒã‚°ãƒæºœã¾ã‚Š
            game.magmaPools.forEach(pool => pool.draw());
            
            // å²©
            game.rocks.forEach(rock => rock.draw());
            
            // è’¸æ°—å­”
            game.steamVents.forEach(vent => vent.draw());
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            game.particles.forEach(p => p.draw());
            
            // æ˜å‰Šæ©Ÿ
            const drillScreenY = game.drillY - game.cameraY;
            ctx.save();
            ctx.translate(game.drillX, drillScreenY);

            // ãƒ‰ãƒªãƒ«ã®å‚¾ãã‚’é©ç”¨
            let tiltAngle = 0;
            const maxTilt = Math.PI / 16; // å‚¾ãã®æœ€å¤§è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
            if (keys['ArrowLeft']) {
                tiltAngle = maxTilt; // å·¦ã‚­ãƒ¼ã§å³ã«å‚¾ã‘ã‚‹
            } else if (keys['ArrowRight']) {
                tiltAngle = -maxTilt; // å³ã‚­ãƒ¼ã§å·¦ã«å‚¾ã‘ã‚‹
            }
            ctx.rotate(tiltAngle);
            
            // PDCãƒ‰ãƒªãƒ«ãƒ“ãƒƒãƒˆï¼ˆå®Ÿéš›ã®ç”»åƒã‚’ä½¿ç”¨ã€å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰- ãƒ‰ãƒªãƒ«æœ¬ä½“ã®å¾Œã‚ã«é…ç½®
            ctx.save();
            ctx.translate(0, 70); // ãƒ‰ãƒªãƒ«æœ¬ä½“ã‹ã‚‰å°‘ã—ä¸‹ã«é…ç½®ï¼ˆ50ã‹ã‚‰70ã«å¤‰æ›´ï¼‰
            
            // ç”»åƒã‚’90åº¦å›è»¢ã•ã›ã¦ã€ã•ã‚‰ã«ä¸Šä¸‹ã«180åº¦å›è»¢ã€æœ€å¾Œã«30åº¦å›è»¢ã•ã›ã¦æ­£ã—ã„å‘ãã«ã™ã‚‹
            ctx.rotate(Math.PI / 2); // 90åº¦å›è»¢
            ctx.rotate(Math.PI); // ä¸Šä¸‹ã«180åº¦å›è»¢
            ctx.rotate(Math.PI / 6); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 8); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 8); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 9); // ã•ã‚‰ã«30åº¦å›è»¢
             
        
        
           
            
            if (imageLoaded) {
                // ç”»åƒã®ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚ºã«ï¼‰
                const bitWidth = 100; // 60ã‹ã‚‰100ã«æ‹¡å¤§
                const bitHeight = 120; // 80ã‹ã‚‰120ã«æ‹¡å¤§
                
                // é«˜æ¸©æ™‚ã®åŠ¹æœ
                if (game.temperature > 500) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = game.temperature > 800 ? '#FF4500' : '#FFD700';
                }
                
                // é«˜æ¸©æ™‚ã®è‰²èª¿å¤‰æ›´
                if (game.temperature > 800) {
                    ctx.filter = 'hue-rotate(30deg) saturate(1.5) brightness(1.2)';
                } else if (game.temperature > 500) {
                    ctx.filter = 'saturate(1.2) brightness(1.1)';
                } else {
                    ctx.filter = 'none';
                }
                
                // PDCãƒ“ãƒƒãƒˆç”»åƒã‚’æç”»ï¼ˆ90åº¦å›è»¢å¾Œã®ä½ç½®èª¿æ•´ï¼‰
                ctx.drawImage(
                    drillBitImage, 
                    -bitWidth / 2, 
                    -bitHeight / 2, // ä¸­å¤®ã«é…ç½®
                    bitWidth, 
                    bitHeight
                );
                
                // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
                ctx.filter = 'none';
                
                // é«˜æ¸©æ™‚ã®è¿½åŠ åŠ¹æœï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰
                if (game.temperature > 800) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bitWidth/2 + 8, bitHeight/2 + 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            } else {
                // ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§ã®ä»£æ›¿è¡¨ç¤º
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(-40, -50, 80, 100); // ã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚º
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', 0, 0);
            }
            
            ctx.restore();
            
            // ãƒ‰ãƒªãƒ«æœ¬ä½“ï¼ˆPDCãƒ“ãƒƒãƒˆã®ä¸Šã«æç”»ï¼‰
            const gradient2 = ctx.createLinearGradient(-20, -30, 20, 30);
            gradient2.addColorStop(0, '#E0E0E0');
            gradient2.addColorStop(1, '#808080');
            ctx.fillStyle = gradient2;
            ctx.fillRect(-25, -40, 50, 80);
            
            // æ’æ°—
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = -50 - i * 10;
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, 5 + i * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // æ·±åº¦ãƒãƒ¼ã‚«ãƒ¼
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 14px Arial';
            for (let d = Math.floor(game.cameraY / 100) * 100; d <= game.cameraY + canvas.height + 100; d += 100) {
                const y = d - game.cameraY;
                if (y > 0 && y < canvas.height) {
                    ctx.fillText(`${Math.floor(d / 10)}m`, 10, y);
                    ctx.fillRect(0, y, 40, 2);
                }
            }
            
            // ç”»é¢ç«¯ã®è­¦å‘Š
            if (game.drillX < 100 || game.drillX > canvas.width - 100) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (game.drillX < 100) {
                    ctx.fillRect(0, 0, 50, canvas.height);
                } else {
                    ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);
                }
            }
        }
        
        function updateUI() {
            document.getElementById('depth').textContent = game.depth;
            document.getElementById('temperature').textContent = Math.floor(game.temperature);
            document.getElementById('drillSpeed').textContent = game.drillSpeed.toFixed(1);
            document.getElementById('drillEnergy').style.width = `${Math.max(0, (game.drillDurability / game.drillMaxDurability) * 100)}%`;
            
            // è€ä¹…åº¦ã«ã‚ˆã‚‹è‰²å¤‰æ›´
            const durabilityRatio = game.drillDurability / game.drillMaxDurability;
            if (durabilityRatio < 0.3) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #8B0000, #FF0000)';
            } else if (durabilityRatio < 0.6) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF8C00, #FFD700)';
            } else {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF4500, #FFD700)';
            }
        }
        
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }
        
        
        function gameOver(reason = null) {
            game.gameRunning = false;
            document.getElementById('finalDepth').textContent = game.maxDepth;
            document.getElementById('maxTemp').textContent = Math.floor(game.maxTemp);
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ç†ç”±ã‚’è¡¨ç¤º
            const gameOverDiv = document.getElementById('gameOver');
            const h2 = gameOverDiv.querySelector('h2');
            if (reason) {
                h2.textContent = reason;
            } else {
                h2.textContent = 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        function resetGame() {
            game = {
                depth: 0,
                energy: 0,
                temperature: 15,
                drillX: 600,
                drillY: 0,
                drillSpeed: 2.5, // åˆæœŸé€Ÿåº¦ã‚’2.5å€ã«å¢—åŠ 
                drillDurability: 100,
                drillMaxDurability: 100,
                cooling: 1,
                particles: [],
                rocks: [],
                steamVents: [],
                magmaPools: [],
                faults: [], // æ–­å±¤
                moles: [], // ã‚‚ãã‚‰
                pipeSegments: [], // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
                maxDepth: 0,
                maxTemp: 15,
                gameRunning: true,
                cameraY: 0,
                generatedSpawns: new Set(),
                upgrades: {
                    speed: { level: 1, cost: 10 },
                    durability: { level: 1, cost: 15 },
                    cooling: { level: 1, cost: 20 }
                }
            };
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }
        
        // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰æ©Ÿèƒ½ã¯ç¾åœ¨UIã«ãªã„ãŸã‚ã€ä¸€æ—¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
        /*
        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (game.energy >= game.upgrades.speed.cost) {
                game.energy -= game.upgrades.speed.cost;
                game.drillSpeed += 0.8;  // 0.3 â†’ 0.8ã«å¢—åŠ 
                game.upgrades.speed.level++;
                game.upgrades.speed.cost = Math.floor(game.upgrades.speed.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeDurability').addEventListener('click', () => {
            if (game.energy >= game.upgrades.durability.cost) {
                game.energy -= game.upgrades.durability.cost;
                game.drillMaxDurability += 50;
                game.drillDurability += 50;
                game.upgrades.durability.level++;
                game.upgrades.durability.cost = Math.floor(game.upgrades.durability.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeCooling').addEventListener('click', () => {
            if (game.energy >= game.upgrades.cooling.cost) {
                game.energy -= game.upgrades.cooling.cost;
                game.cooling += 0.5;
                game.upgrades.cooling.level++;
                game.upgrades.cooling.cost = Math.floor(game.upgrades.cooling.cost * 2);
                updateUI();
            }
        });
        */
        
        // ã‚­ãƒ¼å…¥åŠ›
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = false;
        });
        
        // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œ
        let touchStartX = null;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (touchStartX !== null) {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                
                if (diff < -30) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else if (diff > 30) {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }
            }
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', () => {
            touchStartX = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });
        
        // ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        
        // ãƒã‚¦ã‚¹ã§ã‚‚å‹•ä½œã™ã‚‹ã‚ˆã†ã«
        leftButton.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
        leftButton.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
        rightButton.addEventListener('mousedown', () => keys['ArrowRight'] = true);
        rightButton.addEventListener('mouseup', () => keys['ArrowRight'] = false);
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ãƒªã‚µã‚¤ã‚º
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game.gameRunning = true;
            resizeGame(); // ãƒªã‚µã‚¤ã‚ºã‚’å®Ÿè¡Œ
            gameLoop();
        }
    </script>
</body>
</html>