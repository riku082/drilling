<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœ°ç†±äº•æˆ¸æ˜å‰Šã‚²ãƒ¼ãƒ </title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #8B4513 20%, #654321 40%, #3E2723 60%, #D2691E 80%, #FF4500 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1200px, 95vw);
            height: min(800px, 85vh);
            max-width: 100%;
            max-height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: min(20px, 2vw);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: min(15px, 2vw);
            border-radius: min(10px, 1.5vw);
            border: 2px solid #FF4500;
            font-size: min(14px, 3vw);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #stats {
            top: min(20px, 2vh);
            left: min(20px, 2vw);
            min-width: min(200px, 40vw);
        }

        /* ã‚¹ãƒãƒ›å°‚ç”¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºèª¿æ•´ */
        @media (max-width: 480px) {
            #stats {
                top: 5px !important;
                left: 5px !important;
                transform: scale(0.6) !important;
                max-width: 150px !important;
                font-size: 10px !important;
            }

            .info-panel {
                padding: 8px !important;
                font-size: 10px !important;
            }
        }

        #controls {
            top: 20px;
            right: 20px;
            pointer-events: all;
        }

        /* ã‚¹ãƒãƒ›ç‰ˆå¯¾å¿œ */
        @media (max-width: 768px) {
            #brazilDistanceButton {
                position: absolute !important;
                top: 10px !important;
                right: 10px !important;
                z-index: 1000;
            }
            
            #brazilDistanceButton button {
                padding: 8px 12px !important;
                font-size: 12px !important;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            #startScreen h1 {
                margin-top: 60px !important;
                font-size: 36px !important;
            }

            .instructions {
                font-size: 14px !important;
                margin: 15px 10px !important;
                line-height: 1.4 !important;
            }

            #startScreen button {
                font-size: 16px !important;
                padding: 12px 24px !important;
                margin: 8px !important;
            }

            #titleRanking {
                max-width: 90% !important;
                margin: 15px auto !important;
                padding: 15px !important;
            }

            #titleRanking h3 {
                font-size: 20px !important;
            }

            .title-record-item {
                font-size: 14px !important;
                padding: 10px !important;
            }
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #FF4500;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }

        /* ã‚¹ãƒãƒ›ç‰ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼èª¿æ•´ */
        @media (max-width: 768px) {
            #gameOver {
                max-width: 95% !important;
                max-height: 90% !important;
                padding: 20px !important;
                font-size: 14px !important;
            }

            #gameOver h2 {
                font-size: 24px !important;
                margin: 10px 0 !important;
            }

            #gameOver h3 {
                font-size: 18px !important;
                margin: 8px 0 !important;
            }

            #gameOver p {
                font-size: 13px !important;
                margin: 5px 0 !important;
            }

            #gameOver button {
                font-size: 14px !important;
                padding: 10px 16px !important;
                margin: 5px !important;
            }

            #playerNameInput {
                width: 90% !important;
                font-size: 14px !important;
                padding: 8px !important;
                margin: 8px 0 !important;
            }

            .record-item {
                font-size: 12px !important;
                padding: 8px !important;
                margin: 4px 0 !important;
            }
        }
        
        #playerNameInput {
            padding: 8px;
            margin: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            color: black;
        }
        
        #recordsList {
            margin-top: 20px;
            text-align: left;
        }
        
        .record-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .record-rank {
            font-weight: bold;
            color: #FFD700;
        }
        
        .record-info {
            flex: 1;
            margin-left: 10px;
        }
        
        .record-score {
            font-weight: bold;
            color: #FF4500;
        }

        button {
            background: #FF4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            background: #FF6347;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        .stat-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 18px;
        }

        .energy-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #FFD700;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #FF4500, #FFD700);
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        h1, h2 {
            margin: 10px 0;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        .upgrade-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #228B22;
            margin-top: 5px;
        }

        .upgrade-btn:hover {
            background: #32CD32;
        }

        .upgrade-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 1000;
        }

        #startScreen h1 {
            font-size: 48px;
            color: #FF4500;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .instructions {
            margin: 20px 0;
            font-size: 18px;
            line-height: 1.5;
        }
        
        #titleRanking {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #FF4500;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-width: 600px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #titleRanking h3 {
            color: #FFD700;
            margin-top: 0;
            font-size: 24px;
        }
        
        .title-record-item {
            background: rgba(255, 255, 255, 0.1);
            margin: 8px 0;
            padding: 12px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
        }
        
        .title-record-rank {
            font-weight: bold;
            color: #FFD700;
            min-width: 40px;
        }
        
        .title-record-info {
            flex: 1;
            margin-left: 10px;
            text-align: left;
        }
        
        .title-record-depth {
            font-weight: bold;
            color: #FF4500;
            font-size: 18px;
        }
        
        #brazilDistancePage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000428 0%, #004e92 100%);
            overflow: hidden;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1200px) {
            #brazilDistancePage .flex-container {
                flex-direction: column !important;
                gap: 20px !important;
            }
            
            #brazilDistancePage .earth-container {
                flex: none !important;
                margin-bottom: 20px;
            }
            
            #brazilDistancePage canvas {
                width: 350px !important;
                height: 350px !important;
            }
        }
        
        @media (max-width: 768px) {
            #brazilDistancePage canvas {
                width: 300px !important;
                height: 300px !important;
            }
        }

        .warning {
            color: #FF6347;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        #mobileControls {
            position: absolute;
            bottom: min(20px, 2vh);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: min(15px, 2.5vw);
            z-index: 1000;
        }

        /* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã¯éè¡¨ç¤º */
        @media (min-width: 769px) and (min-height: 601px) {
            #mobileControls {
                display: none !important;
            }
        }

        .touch-button {
            width: min(70px, 14vw);
            height: min(70px, 14vw);
            background: rgba(255, 69, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 50%;
            color: white;
            font-size: min(20px, 4vw);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.1s;
            touch-action: manipulation;
        }

        #spaceButton {
            background: rgba(135, 206, 235, 0.8);
            border-color: #87CEEB;
        }

        #spaceButton:active {
            background: rgba(135, 206, 235, 1);
            transform: scale(0.95);
        }

        .touch-button:active {
            background: rgba(255, 69, 0, 1);
            transform: scale(0.95);
        }

        @media (max-width: 768px) or (max-height: 600px) {
            #mobileControls {
                display: flex !important;
            }
            
            body {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
            }
            
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
            }
            
            #gameCanvas {
                width: 100% !important;
                height: 100% !important;
                object-fit: contain;
            }
            
            .info-panel {
                font-size: max(10px, 2.2vw);
                padding: max(6px, 1.2vw);
                min-width: max(150px, 30vw);
                border-radius: max(5px, 1vw);
            }
            
            #stats {
                top: max(5px, 0.5vh);
                left: max(5px, 1vw);
                transform: scale(0.7);
                transform-origin: top left;
                max-width: min(180px, 35vw);
            }
            
            #mobileControls {
                bottom: max(10px, 1vh);
                gap: max(15px, 2vw);
            }
            
            .touch-button {
                width: max(60px, 12vw);
                height: max(60px, 12vw);
                font-size: max(18px, 3.5vw);
                border-width: 2px;
            }
            
            /* ç¸¦å‘ãã‚¹ãƒãƒ›ç”¨ */
            @media (orientation: portrait) {
                #gameContainer {
                    height: 100vh;
                }
                
                .info-panel {
                    font-size: max(11px, 2.8vw);
                }
                
                .touch-button {
                    width: max(70px, 14vw);
                    height: max(70px, 14vw);
                }
            }
            
            /* æ¨ªå‘ãã‚¹ãƒãƒ›ç”¨ */
            @media (orientation: landscape) {
                #gameContainer {
                    width: 100vw;
                    height: 100vh;
                }
                
                .info-panel {
                    font-size: max(9px, 2vh);
                    padding: max(5px, 1vh);
                }
                
                #stats {
                    transform: scale(0.65);
                    max-width: min(160px, 32vw);
                }

                #gameOver {
                    max-width: 98% !important;
                    max-height: 95% !important;
                    padding: 15px !important;
                    font-size: 12px !important;
                }

                #gameOver h2 {
                    font-size: 20px !important;
                }

                #gameOver h3 {
                    font-size: 16px !important;
                }

                #gameOver button {
                    font-size: 12px !important;
                    padding: 8px 12px !important;
                    margin: 3px !important;
                }

                #playerNameInput {
                    font-size: 12px !important;
                    padding: 6px !important;
                }
                
                .touch-button {
                    width: max(50px, 8vh);
                    height: max(50px, 8vh);
                    font-size: max(16px, 3vh);
                }
                
                #mobileControls {
                    bottom: max(5px, 1vh);
                }
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="1000"></canvas>
        <div id="ui">
            <div id="stats" class="info-panel">
                <h2>æ˜å‰ŠçŠ¶æ³</h2>
                <div>æ·±åº¦: <span class="stat-value" id="depth">0</span> m</div>
                <div>æ¸©åº¦: <span class="stat-value" id="temperature">15</span> â„ƒ</div>
                <div>æ˜å‰Šé€Ÿåº¦: <span class="stat-value" id="drillSpeed">2.5</span> m/s</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="drillEnergy"></div>
                </div>
                <div style="font-size: 12px;">ãƒ‰ãƒªãƒ«è€ä¹…åº¦</div>
                
                <div style="margin-top: 10px; font-size: 14px;">ğŸ’° ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼: <span class="stat-value" id="oilMoneyCount">0</span></div>
                <div style="margin-top: 5px; font-size: 12px; color: #FFD700;">ğŸ”¥ ã‚³ãƒ³ãƒœ: <span class="stat-value" id="comboCount">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #87CEEB;">
                    <div>ğŸŒ ç·æ˜å‰Šè·é›¢: <span class="stat-value" id="totalDistance">0</span> m</div>
                    <div>ğŸ“Š ä»Šå›ã®ãƒ—ãƒ¬ã‚¤: <span class="stat-value" id="currentPlayDistance">0</span> m</div>
                </div>
                <div class="energy-bar" style="margin-top: 10px;">
                    <div class="energy-fill" id="beamEnergy"></div>
                </div>
                <div style="font-size: 12px;">æ³¥æ°´ãƒ“ãƒ¼ãƒ  <span id="beamStatus">ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ã‚’é›†ã‚ã‚ˆã†ï¼</span></div>
                <div id="warningText" class="warning" style="display: none;">âš ï¸ é«˜æ¸©æ³¨æ„ï¼</div>
            </div>
            
            <!-- éŸ³å£°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
            <div id="audioControls" style="position: absolute; top: 20px; right: 20px; pointer-events: all;">
                <button id="muteButton" style="font-size: 12px; padding: 5px 10px; background: rgba(0,0,0,0.7); color: white; border: 1px solid #FF4500;">ğŸ”Š éŸ³å£°ON</button>
            </div>
        </div>
        
        <div id="startScreen">
            <!-- ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®è·é›¢ãƒœã‚¿ãƒ³ -->
            <div id="brazilDistanceButton" style="position: absolute; top: 20px; right: 20px; z-index: 1000;">
                <button onclick="showBrazilDistance()" style="background: #228B22; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 14px; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">
                    ğŸŒ ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®è·é›¢
                </button>
            </div>
            
            <h1>ğŸ”¥ åœ°ç†±äº•æˆ¸æ˜å‰Šã‚²ãƒ¼ãƒ  ğŸ”¥</h1>
            <div class="instructions">
                <p>è‡ªå‹•ã§åœ°çƒã®æ·±éƒ¨ã¸æ˜ã‚Šé€²ã¿ã¾ã™ï¼</p>
                <p>â† â†’ ã‚­ãƒ¼ã§æ˜å‰Šæ©Ÿã‚’å·¦å³ã«ç§»å‹•ã—ã¦éšœå®³ç‰©ã‚’é¿ã‘ã‚ˆã†</p>
                <p>å²©ã«ã¶ã¤ã‹ã‚‹ã¨ãƒ‰ãƒªãƒ«ãŒæ¶ˆè€—ã—ã¾ã™</p>
                <p>ğŸ›¢ï¸ ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆã§ãƒ‰ãƒªãƒ«è€ä¹…åº¦ãŒå›å¾©ï¼</p>
                <p>ğŸ’§ æ³¥æ°´ãƒ“ãƒ¼ãƒ ã‚²ãƒ¼ã‚¸ãŒæºœã¾ã£ãŸã‚‰ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§éšœå®³ç‰©ã‚’ç ´å£Šï¼</p>
                <p>ã‚ˆã‚Šæ·±ãæ˜ã‚‹ã»ã©é«˜æ¸©ã«ãªã‚Šã€å¤šãã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’ç²å¾—ã§ãã¾ã™</p>
            </div>
            <button onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <button onclick="showTitleRanking()">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
            
            <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º -->
            <div id="titleRanking" style="display: none;">
                <h3>ğŸ† æ·±åº¦ãƒ©ãƒ³ã‚­ãƒ³ã‚° TOP5</h3>
                <div id="titleRankingList"></div>
                <div id="titleTotalDistance" style="margin-top: 15px;"></div>
                <button onclick="hideTitleRanking()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
        
        <div id="gameOver">
            <!-- ãƒˆãƒƒãƒ—ãƒœã‚¿ãƒ³ -->
            <div id="topButtons" style="margin-bottom: 20px;">
                <button onclick="resetGame()" style="margin-right: 10px;">ğŸ”„ ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
                <button onclick="backToTitle()">ğŸ  ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
            </div>
            
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <p>æœ€çµ‚æ·±åº¦: <span id="finalDepth">0</span> m</p>
            <p>æœ€é«˜æ¸©åº¦: <span id="maxTemp">0</span> â„ƒ</p>
            <div id="playerNameSection">
                <input type="text" id="playerNameInput" placeholder="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å…¥åŠ›" maxlength="20">
                <button onclick="updatePlayerName()">åå‰ã‚’è¨­å®š</button>
            </div>
            <div id="recordsSection">
                <button onclick="showRecords()">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’è¦‹ã‚‹</button>
                <div id="recordsList" style="display: none;">
                    <h3>ãƒˆãƒƒãƒ—10</h3>
                    <div id="topRecords"></div>
                    <h3>ã‚ãªãŸã®è¨˜éŒ²</h3>
                    <div id="playerRecords"></div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®è·é›¢ãƒšãƒ¼ã‚¸ -->
        <div id="brazilDistancePage" style="display: none;">
            <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
            <div style="position: absolute; top: 20px; left: 20px; z-index: 1002;">
                <button onclick="hideBrazilDistance()" style="background: #FF4500; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                    â† æˆ»ã‚‹
                </button>
            </div>
            
            <div style="text-align: center; padding: 20px 0 10px 0; color: white;">
                <h1 style="color: #FF4500; margin: 0; font-size: 28px;">ğŸŒ ç§‹ç”°çœŒã‹ã‚‰ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®æ—…</h1>
            </div>
            
            <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆ2åˆ—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰ -->
            <div class="flex-container" style="display: flex; flex: 1; padding: 0 30px 30px 30px; gap: 30px; max-height: calc(100vh - 80px);">
                <!-- å·¦å´ï¼šç›®æ¨™æƒ…å ±ã¨åœ°çƒã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ -->
                <div class="earth-container" style="flex: 1.2; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <!-- ç›®æ¨™æƒ…å ± -->
                    <div style="background: rgba(0, 0, 0, 0.8); padding: 16px; border-radius: 15px; margin-bottom: 20px; width: 100%; max-width: 450px;">
                        <h3 style="color: #FFD700; margin-top: 0; margin-bottom: 10px; font-size: 18px; text-align: center;">ğŸ¯ ç›®æ¨™</h3>
                        <p style="font-size: 14px; margin: 0 0 12px 0; text-align: center;">ç§‹ç”°çœŒã‹ã‚‰ãƒ–ãƒ©ã‚¸ãƒ«ï¼ˆãƒ–ãƒ©ã‚¸ãƒªã‚¢ï¼‰ã¾ã§: <span style="color: #FF4500; font-weight: bold;">18,000 km</span></p>
                        
                        <h3 style="color: #87CEEB; margin: 12px 0 10px 0; font-size: 18px; text-align: center;">ğŸ“ ç¾åœ¨ã®é€²æ—</h3>
                        <div style="background: #333; padding: 12px; border-radius: 8px; margin: 10px 0;">
                            <div style="font-size: 18px; color: #FFD700; margin-bottom: 6px; text-align: center;">
                                æ˜å‰Šæ¸ˆã¿: <span id="currentDistance">0</span> km
                            </div>
                            <div style="font-size: 14px; color: #87CEEB; text-align: center;">
                                æ®‹ã‚Š: <span id="remainingDistance">18,000</span> km
                            </div>
                            <div style="font-size: 14px; color: #90EE90; margin-top: 6px; text-align: center;">
                                é”æˆç‡: <span id="progressPercentage">0</span>%
                            </div>
                        </div>
                        
                        <!-- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ -->
                        <div style="background: #333; height: 16px; border-radius: 8px; margin: 10px 0; overflow: hidden;">
                            <div id="progressBar" style="background: linear-gradient(to right, #FF4500, #FFD700); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                    </div>
                    
                    <!-- åœ°çƒã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ -->
                    <div id="earthContainer" style="position: relative; display: inline-block;">
                        <canvas id="earthCanvas" width="450" height="450" style="border: 2px solid #FF4500; border-radius: 50%; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);"></canvas>
                        <div id="progressIndicator" style="position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%); font-size: 24px;">ğŸš€</div>
                    </div>
                </div>
                
                <!-- å³å´ï¼šãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º -->
                <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                    <!-- ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º -->
                    <div id="brazilPageRanking" style="background: rgba(0, 0, 0, 0.8); padding: 25px; border-radius: 15px; flex: 1; min-height: 0; display: flex; flex-direction: column;">
                        <h3 style="color: #FFD700; margin: 0 0 20px 0; font-size: 24px; flex-shrink: 0; text-align: center;">ğŸ† æ·±åº¦ãƒ©ãƒ³ã‚­ãƒ³ã‚° TOP5</h3>
                        <div id="brazilRankingList" style="flex: 1; overflow-y: auto; min-height: 0;">
                            <p>èª­ã¿è¾¼ã¿ä¸­...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div id="mobileControls">
            <div class="touch-button" id="leftButton">â†</div>
            <div class="touch-button" id="spaceButton">ğŸ’§</div>
            <div class="touch-button" id="rightButton">â†’</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // PDCãƒ“ãƒƒãƒˆç”»åƒã®èª­ã¿è¾¼ã¿
        const drillBitImage = new Image();
        drillBitImage.src = 'Gemini_Generated_Image_sfxgpisfxgpisfxg.png';
        let imageLoaded = false;
        drillBitImage.onload = function() {
            imageLoaded = true;
        };
        
        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ 
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.masterVolume = 0.5;
                this.sfxVolume = 0.7;
                this.musicVolume = 0.3;
                this.muted = false;
                this.sounds = {};
                this.musicLoop = null;
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.warn('Web Audio API not supported:', e);
                }
            }
            
            createSounds() {
                // æ˜å‰ŠéŸ³ï¼ˆä½ã„é€£ç¶šéŸ³ï¼‰
                this.sounds.drilling = this.createDrillingSound();
                // å²©çŸ³ç ´å£ŠéŸ³
                this.sounds.rockBreak = this.createRockBreakSound();
                // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ç²å¾—éŸ³
                this.sounds.oilMoney = this.createOilMoneySound();
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹éŸ³
                this.sounds.starMode = this.createStarModeSound();
                // ãƒ“ãƒ¼ãƒ ç™ºå°„éŸ³
                this.sounds.beam = this.createBeamSound();
                // è¡çªéŸ³
                this.sounds.collision = this.createCollisionSound();
                // è­¦å‘ŠéŸ³
                this.sounds.warning = this.createWarningSound();
            }
            
            createOscillator(frequency, type = 'sine') {
                if (!this.audioContext) return null;
                const oscillator = this.audioContext.createOscillator();
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                return oscillator;
            }
            
            createGain(volume = 1) {
                if (!this.audioContext) return null;
                const gain = this.audioContext.createGain();
                gain.gain.value = volume * this.masterVolume * (this.muted ? 0 : 1);
                return gain;
            }
            
            createDrillingSound() {
                return () => {
                    if (!this.audioContext) return;
                    
                    // æ·±åº¦ã«å¿œã˜ãŸéŸ³ã®å¤‰åŒ–
                    let baseFreq = 80 + Math.random() * 20;
                    let filterFreq = 200;
                    let volume = 0.3;
                    
                    if (game.depth > 3000) {
                        baseFreq += 20; // æ·±éƒ¨ã§ã¯é«˜ã„éŸ³
                        filterFreq += 100;
                        volume = 0.4; // éŸ³é‡ã‚‚ä¸ŠãŒã‚‹
                    }
                    if (game.depth > 5000) {
                        baseFreq += 30; // æ¥µæ·±éƒ¨ã§ã¯ã•ã‚‰ã«é«˜ã„éŸ³
                        filterFreq += 150;
                        volume = 0.5;
                    }
                    
                    // ãƒ¡ã‚¤ãƒ³æ˜å‰ŠéŸ³
                    const osc = this.createOscillator(baseFreq, 'sawtooth');
                    const gain = this.createGain(volume * this.sfxVolume);
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = filterFreq;
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.12);
                    osc.stop(this.audioContext.currentTime + 0.12);
                    
                    // è¿½åŠ ã®é‡‘å±éŸ³ï¼ˆç¢ºç‡çš„ã«ï¼‰
                    if (Math.random() < 0.3) {
                        const metalOsc = this.createOscillator(baseFreq * 3, 'square');
                        const metalGain = this.createGain(0.1 * this.sfxVolume);
                        const metalFilter = this.audioContext.createBiquadFilter();
                        metalFilter.type = 'highpass';
                        metalFilter.frequency.value = 800;
                        
                        metalOsc.connect(metalFilter);
                        metalFilter.connect(metalGain);
                        metalGain.connect(this.audioContext.destination);
                        
                        metalOsc.start();
                        metalGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                        metalOsc.stop(this.audioContext.currentTime + 0.05);
                    }
                };
            }
            
            createRockBreakSound() {
                return () => {
                    if (!this.audioContext) return;
                    const noise = this.audioContext.createBufferSource();
                    const buffer = this.audioContext.createBuffer(1, 4410, 44100);
                    const data = buffer.getChannelData(0);
                    
                    for (let i = 0; i < 4410; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    noise.buffer = buffer;
                    const gain = this.createGain(0.4 * this.sfxVolume);
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 800;
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    noise.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                };
            }
            
            createOilMoneySound() {
                return () => {
                    if (!this.audioContext) return;
                    const notes = [523.25, 659.25, 783.99, 1046.5]; // C5, E5, G5, C6
                    
                    notes.forEach((freq, i) => {
                        const osc = this.createOscillator(freq, 'sine');
                        const gain = this.createGain(0.3 * this.sfxVolume);
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        const startTime = this.audioContext.currentTime + i * 0.1;
                        osc.start(startTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                        osc.stop(startTime + 0.2);
                    });
                };
            }
            
            createStarModeSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc1 = this.createOscillator(440, 'sine');
                    const osc2 = this.createOscillator(880, 'sine');
                    const gain = this.createGain(0.5 * this.sfxVolume);
                    
                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc1.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.5);
                    osc2.frequency.exponentialRampToValueAtTime(1760, this.audioContext.currentTime + 0.5);
                    
                    osc1.start();
                    osc2.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                    osc1.stop(this.audioContext.currentTime + 0.8);
                    osc2.stop(this.audioContext.currentTime + 0.8);
                };
            }
            
            createBeamSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc = this.createOscillator(150, 'sawtooth');
                    const gain = this.createGain(0.4 * this.sfxVolume);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.3);
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                    osc.stop(this.audioContext.currentTime + 0.3);
                };
            }
            
            createCollisionSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc = this.createOscillator(200 + Math.random() * 100, 'square');
                    const gain = this.createGain(0.3 * this.sfxVolume);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                    osc.stop(this.audioContext.currentTime + 0.05);
                };
            }
            
            createWarningSound() {
                return () => {
                    if (!this.audioContext) return;
                    const osc = this.createOscillator(800, 'sine');
                    const gain = this.createGain(0.3 * this.sfxVolume);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start();
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    osc.stop(this.audioContext.currentTime + 0.2);
                };
            }
            
            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }
            
            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
            }
            
            toggleMute() {
                this.muted = !this.muted;
            }
            
            startBackgroundMusic() {
                if (!this.audioContext || this.musicLoop) return;
                
                // éŸ³æ¥½ã®è¨­å®šï¼ˆæ˜ã‚‹ãã‚¢ãƒƒãƒ—ãƒ†ãƒ³ãƒã«ï¼‰
                const tempo = 140; // BPMï¼ˆ120â†’140ã«é«˜é€ŸåŒ–ï¼‰
                const beatDuration = 60 / tempo; // 1æ‹ã®é•·ã•ï¼ˆç§’ï¼‰
                
                // ã‚­ãƒ¼: C majorï¼ˆæ˜ã‚‹ã„ã‚­ãƒ¼ï¼‰
                const scale = {
                    // C - Am - F - G ã®ã‚³ãƒ¼ãƒ‰é€²è¡Œï¼ˆæ˜ã‚‹ã„é€²è¡Œï¼‰
                    chords: [
                        [261.63, 329.63, 392.00], // C major (C4, E4, G4)
                        [220.00, 261.63, 329.63], // A minor (A3, C4, E4)
                        [174.61, 220.00, 261.63], // F major (F3, A3, C4)
                        [196.00, 246.94, 293.66]  // G major (G3, B3, D4)
                    ],
                    melody: [
                        [523.25, 659.25, 783.99, 523.25], // å°ç¯€1: C5, E5, G5, C5ï¼ˆæ˜ã‚‹ã„ä¸Šæ˜‡ï¼‰
                        [440.00, 523.25, 659.25, 440.00], // å°ç¯€2: A4, C5, E5, A4ï¼ˆè·³èºï¼‰
                        [349.23, 440.00, 523.25, 349.23], // å°ç¯€3: F4, A4, C5, F4ï¼ˆå®‰å®šï¼‰
                        [392.00, 493.88, 587.33, 392.00]  // å°ç¯€4: G4, B4, D5, G4ï¼ˆè§£æ±ºï¼‰
                    ]
                };
                
                let currentMeasure = 0;
                let currentBeat = 0;
                
                const playMusicLoop = () => {
                    if (this.muted) {
                        setTimeout(playMusicLoop, beatDuration * 1000);
                        return;
                    }
                    
                    const currentTime = this.audioContext.currentTime;
                    
                    // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆæ˜ã‚‹ã„ä½éŸ³ï¼‰
                    const bassFreq = scale.chords[currentMeasure][0];
                    const bassOsc = this.createOscillator(bassFreq * 0.5, 'triangle'); // ã‚ˆã‚Šæš–ã‹ã„éŸ³è‰²
                    const bassGain = this.createGain(0.18 * this.musicVolume); // å°‘ã—å¤§ãã
                    
                    bassOsc.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    
                    bassOsc.start(currentTime);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 2);
                    bassOsc.stop(currentTime + beatDuration * 2);
                    
                    // ã‚³ãƒ¼ãƒ‰ï¼ˆå’ŒéŸ³ï¼‰- ã‚ˆã‚Šæ˜ã‚‹ã
                    scale.chords[currentMeasure].forEach((freq, i) => {
                        const chordOsc = this.createOscillator(freq, 'sine'); // æŸ”ã‚‰ã‹ã„éŸ³è‰²
                        const chordGain = this.createGain(0.12 * this.musicVolume); // å°‘ã—å¤§ãã
                        
                        chordOsc.connect(chordGain);
                        chordGain.connect(this.audioContext.destination);
                        
                        chordOsc.start(currentTime + i * 0.01);
                        chordGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 2);
                        chordOsc.stop(currentTime + beatDuration * 2);
                    });
                    
                    // ãƒ¡ãƒ­ãƒ‡ã‚£ãƒ¼ï¼ˆ1æ‹ã”ã¨ï¼‰- ã‚ˆã‚Šæ˜ã‚‹ãç›®ç«‹ã¤
                    const melodyFreq = scale.melody[currentMeasure][currentBeat];
                    const melodyOsc = this.createOscillator(melodyFreq, 'triangle'); // æ¸©ã‹ã„éŸ³è‰²
                    const melodyGain = this.createGain(0.2 * this.musicVolume); // å¤§ãã
                    
                    melodyOsc.connect(melodyGain);
                    melodyGain.connect(this.audioContext.destination);
                    
                    melodyOsc.start(currentTime);
                    melodyGain.gain.setValueAtTime(0.2 * this.musicVolume, currentTime);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 0.8);
                    melodyOsc.stop(currentTime + beatDuration);
                    
                    // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ï¼ˆ2æ‹ã”ã¨ï¼‰- è±Šã‹ãªéŸ¿ã
                    if (currentBeat % 2 === 0) {
                        const harmonyFreq = melodyFreq * 0.75; // 5åº¦ä¸‹
                        const harmonyOsc = this.createOscillator(harmonyFreq, 'sine');
                        const harmonyGain = this.createGain(0.1 * this.musicVolume);
                        
                        harmonyOsc.connect(harmonyGain);
                        harmonyGain.connect(this.audioContext.destination);
                        
                        harmonyOsc.start(currentTime);
                        harmonyGain.gain.setValueAtTime(0.1 * this.musicVolume, currentTime);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + beatDuration * 0.6);
                        harmonyOsc.stop(currentTime + beatDuration);
                    }
                    
                    // ãƒªã‚ºãƒ æ›´æ–°
                    currentBeat++;
                    if (currentBeat >= 4) {
                        currentBeat = 0;
                        currentMeasure = (currentMeasure + 1) % 4;
                    }
                    
                    setTimeout(playMusicLoop, beatDuration * 1000);
                };
                
                playMusicLoop();
                this.musicLoop = true;
            }
            
            startStarModeBGM() {
                if (!this.audioContext || this.muted) return;
                
                // ãƒãƒªã‚ªã®ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹BGMï¼ˆæ­£ç¢ºãªå†ç¾ï¼‰
                const tempo = 300; // éå¸¸ã«é«˜é€Ÿ
                const sixteenthNote = (60 / tempo) / 4; // 16åˆ†éŸ³ç¬¦ã®é•·ã•
                
                // ãƒãƒªã‚ªã®ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ã®å®Ÿéš›ã®ãƒ¡ãƒ­ãƒ‡ã‚£ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
                // C major scale ã§ã®ä¸Šæ˜‡ãƒ»ä¸‹é™ã‚¢ãƒ«ãƒšã‚¸ã‚ª
                const starArpeggio = [
                    523.25, 659.25, 783.99, 1046.5, 1318.5, 1568.0, 1318.5, 1046.5, // ä¸Šæ˜‡ãƒ»ä¸‹é™
                    659.25, 783.99, 1046.5, 1318.5, 1568.0, 1318.5, 1046.5, 783.99,  // å¤‰åŒ–
                    523.25, 659.25, 783.99, 1046.5, 1318.5, 1568.0, 1318.5, 1046.5, // ç¹°ã‚Šè¿”ã—
                    783.99, 659.25, 523.25, 659.25, 783.99, 1046.5, 1318.5, 1568.0   // çµ‚äº†
                ];
                
                // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªãƒ«ãƒ¼ãƒˆéŸ³ï¼‰
                const bassPattern = [
                    261.63, 261.63, 261.63, 261.63, 329.63, 329.63, 329.63, 329.63,
                    392.00, 392.00, 392.00, 392.00, 261.63, 261.63, 261.63, 261.63,
                    261.63, 261.63, 261.63, 261.63, 329.63, 329.63, 329.63, 329.63,
                    392.00, 392.00, 392.00, 392.00, 261.63, 261.63, 261.63, 261.63
                ];
                
                let noteIndex = 0;
                
                const playStarMusic = () => {
                    if (!game.starMode) return;
                    
                    const currentTime = this.audioContext.currentTime;
                    
                    // ãƒ¡ã‚¤ãƒ³ãƒ»ãƒ¡ãƒ­ãƒ‡ã‚£ãƒ¼ï¼ˆé«˜é€Ÿã‚¢ãƒ«ãƒšã‚¸ã‚ªï¼‰
                    const melodyFreq = starArpeggio[noteIndex];
                    const melodyOsc = this.createOscillator(melodyFreq, 'square');
                    const melodyGain = this.createGain(0.35 * this.musicVolume);
                    
                    // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼ˆçŸ­ãã‚¯ãƒªã‚¢ãªéŸ³ï¼‰
                    melodyOsc.connect(melodyGain);
                    melodyGain.connect(this.audioContext.destination);
                    
                    melodyOsc.start(currentTime);
                    melodyGain.gain.setValueAtTime(0.35 * this.musicVolume, currentTime);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 0.8);
                    melodyOsc.stop(currentTime + sixteenthNote);
                    
                    // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆ2æ‹ã”ã¨ï¼‰
                    if (noteIndex % 2 === 0) {
                        const bassFreq = bassPattern[noteIndex];
                        const bassOsc = this.createOscillator(bassFreq, 'triangle');
                        const bassGain = this.createGain(0.25 * this.musicVolume);
                        
                        bassOsc.connect(bassGain);
                        bassGain.connect(this.audioContext.destination);
                        
                        bassOsc.start(currentTime);
                        bassGain.gain.setValueAtTime(0.25 * this.musicVolume, currentTime);
                        bassGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 1.5);
                        bassOsc.stop(currentTime + sixteenthNote * 2);
                    }
                    
                    // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ï¼ˆ4æ‹ã”ã¨ï¼‰
                    if (noteIndex % 4 === 0) {
                        const harmonyFreq = melodyFreq * 0.75; // 5åº¦ä¸‹
                        const harmonyOsc = this.createOscillator(harmonyFreq, 'square');
                        const harmonyGain = this.createGain(0.15 * this.musicVolume);
                        
                        harmonyOsc.connect(harmonyGain);
                        harmonyGain.connect(this.audioContext.destination);
                        
                        harmonyOsc.start(currentTime);
                        harmonyGain.gain.setValueAtTime(0.15 * this.musicVolume, currentTime);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 0.6);
                        harmonyOsc.stop(currentTime + sixteenthNote);
                    }
                    
                    // ãƒ‘ãƒ¼ã‚«ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ8æ‹ã”ã¨ï¼‰
                    if (noteIndex % 8 === 0) {
                        const kickOsc = this.createOscillator(80, 'sine');
                        const kickGain = this.createGain(0.4 * this.musicVolume);
                        
                        kickOsc.connect(kickGain);
                        kickGain.connect(this.audioContext.destination);
                        
                        kickOsc.start(currentTime);
                        kickGain.gain.setValueAtTime(0.4 * this.musicVolume, currentTime);
                        kickGain.gain.exponentialRampToValueAtTime(0.01, currentTime + sixteenthNote * 2);
                        kickOsc.stop(currentTime + sixteenthNote * 2);
                    }
                    
                    // æ¬¡ã®éŸ³ç¬¦ã¸
                    noteIndex = (noteIndex + 1) % starArpeggio.length;
                    
                    setTimeout(playStarMusic, sixteenthNote * 1000);
                };
                
                playStarMusic();
            }
            
            stopBackgroundMusic() {
                this.musicLoop = false;
            }
            
            stopStarModeBGM() {
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ã®BGMã‚’åœæ­¢ã™ã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚°
                // å®Ÿéš›ã®åœæ­¢ã¯å„ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®starModeçŠ¶æ…‹ã§åˆ¶å¾¡ã•ã‚Œã‚‹
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        const audioManager = new AudioManager();
        
        // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const containerRect = container.getBoundingClientRect();
            const isMobile = window.innerWidth <= 768 || window.innerHeight <= 600;
            
            if (isMobile) {
                // ãƒ¢ãƒã‚¤ãƒ«ã§ã¯ç”»é¢å…¨ä½“ã‚’ä½¿ç”¨
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.transform = 'none';
                canvas.style.objectFit = 'contain';
            } else {
                // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã¯é©åˆ‡ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                const scaleX = containerRect.width / 1200;
                const scaleY = containerRect.height / 1000;
                const scale = Math.min(scaleX, scaleY);
                
                canvas.style.transform = `scale(${scale})`;
                canvas.style.transformOrigin = 'top left';
                canvas.style.width = '1200px';
                canvas.style.height = '1000px';
                canvas.style.objectFit = 'initial';
            }
            
            // ã‚²ãƒ¼ãƒ å†…åº§æ¨™ã‚‚èª¿æ•´
            if (game.drillX === 600) { // åˆæœŸä½ç½®ã®å ´åˆ
                game.drillX = 1200 * 0.5; // ç”»é¢ä¸­å¤®
            }
        }
        
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeGame, 100);
        });
        
        // Firebaseè¨­å®š
        const firebaseConfig = {
            apiKey: "AIzaSyC_HcHZGly2GijG7Y07oSZSjrxP3CUCMRA",
            authDomain: "abab-3k6tdx.firebaseapp.com",
            projectId: "abab-3k6tdx",
            storageBucket: "abab-3k6tdx.firebasestorage.app",
            messagingSenderId: "5046366384",
            appId: "1:5046366384:web:2ef45b11dfc7add6250b75"
        };
        
        // FirebaseåˆæœŸåŒ–
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // ã‚²ãƒ¼ãƒ è¨˜éŒ²ç®¡ç†ã‚¯ãƒ©ã‚¹
        class GameRecordManager {
            constructor() {
                this.playerName = localStorage.getItem('playerName') || 'Player';
                this.collection = db.collection('gameRecords');
                this.statsCollection = db.collection('gameStats');
            }
            
            async saveRecord(record) {
                try {
                    const docRef = await this.collection.add({
                        playerName: this.playerName,
                        depth: record.depth,
                        temperature: record.temperature,
                        oilMoneyStock: record.oilMoneyStock,
                        comboCount: record.comboCount,
                        score: record.score,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        gameVersion: '1.0.1'
                    });
                    
                    // ç·æ˜å‰Šè·é›¢ã‚’æ›´æ–°
                    await this.updateTotalDistance(record.depth);
                    
                    console.log('è¨˜éŒ²ã‚’ä¿å­˜ã—ã¾ã—ãŸ:', docRef.id);
                    return docRef.id;
                } catch (error) {
                    console.error('è¨˜éŒ²ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }
            
            async getTopRecordsByDepth(limit = 5) {
                try {
                    const snapshot = await this.collection
                        .orderBy('depth', 'desc')
                        .limit(limit)
                        .get();
                    
                    const records = [];
                    snapshot.forEach(doc => {
                        records.push({
                            id: doc.id,
                            ...doc.data()
                        });
                    });
                    return records;
                } catch (error) {
                    console.error('è¨˜éŒ²å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }
            
            async checkIfTopRecord(depth) {
                try {
                    const snapshot = await this.collection
                        .orderBy('depth', 'desc')
                        .limit(5)
                        .get();
                    
                    const records = [];
                    snapshot.forEach(doc => {
                        records.push(doc.data());
                    });
                    
                    // 5ä½æœªæº€ã®è¨˜éŒ²æ•°ã®å ´åˆã€ã¾ãŸã¯æ–°è¨˜éŒ²ãŒ5ä½ä»¥ä¸Šã®å ´åˆ
                    if (records.length < 5 || depth > records[4].depth) {
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('è¨˜éŒ²ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
                    return false;
                }
            }
            
            async updateTotalDistance(distance) {
                try {
                    const statsRef = this.statsCollection.doc('totalDistance');
                    await statsRef.set({
                        total: firebase.firestore.FieldValue.increment(distance),
                        lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } catch (error) {
                    console.error('ç·è·é›¢æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            async getTotalDistance() {
                try {
                    const doc = await this.statsCollection.doc('totalDistance').get();
                    if (doc.exists) {
                        return doc.data().total || 0;
                    }
                    return 0;
                } catch (error) {
                    console.error('ç·è·é›¢å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                    return 0;
                }
            }
            
            setPlayerName(name) {
                this.playerName = name;
                localStorage.setItem('playerName', name);
            }
        }
        
        // è¨˜éŒ²ç®¡ç†ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
        const recordManager = new GameRecordManager();
        
        let game = {
            depth: 0,
            temperature: 15,
            drillX: 600,
            drillY: 0,
            drillSpeed: 4.0, // åˆæœŸé€Ÿåº¦ã‚’4.0å€ã«å¢—åŠ 
            drillDurability: 100,
            drillMaxDurability: 100,
            oilMoneyStock: 0, // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ã‚¹ãƒˆãƒƒã‚¯æ•°
            starMode: false, // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ãƒ•ãƒ©ã‚°
            starModeTimer: 0, // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹æ®‹ã‚Šæ™‚é–“ï¼ˆç§’ï¼‰
            starModeDuration: 5, // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰
            lastBenchmarkDepth: 0, // æœ€å¾Œã«è¡¨ç¤ºã—ãŸãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã®æ·±åº¦
            comboCount: 0, // ã‚³ãƒ³ãƒœã‚«ã‚¦ãƒ³ãƒˆ
            comboTimer: 0, // ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒãƒ¼ï¼ˆç§’ï¼‰
            comboMaxTime: 3, // ã‚³ãƒ³ãƒœã®æœ€å¤§æŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰
            beams: [], // ç™ºå°„ä¸­ã®ãƒ“ãƒ¼ãƒ 
            particles: [],
            rocks: [],
            steamVents: [],
            magmaPools: [],
            faults: [], // æ–­å±¤
            oilPockets: [], // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆ
            oilMoney: [], // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼
            moles: [], // ã‚‚ãã‚‰
            pipeSegments: [], // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
            maxDepth: 0,
            maxTemp: 15,
            gameRunning: false,
            cameraY: 0
        };
        
        const keys = {};
        
        class Beam {
            constructor(x, y, direction) {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.direction = direction; // è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
                this.speed = 15; // ãƒ“ãƒ¼ãƒ é€Ÿåº¦
                this.width = 8; // ãƒ“ãƒ¼ãƒ å¹…
                this.length = 60; // ãƒ“ãƒ¼ãƒ é•·ã•
                this.life = 1.0; // ãƒ“ãƒ¼ãƒ ã®ç”Ÿå­˜æ™‚é–“
                this.power = 50; // ç ´å£ŠåŠ›
                this.particles = [];
                this.hasHit = false;
            }
            
            update() {
                // ãƒ“ãƒ¼ãƒ ã®ç§»å‹•
                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;
                
                // ç”Ÿå­˜æ™‚é–“ã®æ¸›å°‘
                this.life -= 0.02;
                
                // ãƒ“ãƒ¼ãƒ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç”Ÿæˆ
                if (Math.random() < 0.8) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.width,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 1,
                        size: Math.random() * 3 + 1
                    });
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    p.size *= 0.95;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
                
                // éšœå®³ç‰©ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
                this.checkCollisions();
            }
            
            checkCollisions() {
                if (this.hasHit) return;
                
                // å²©ã¨ã®è¡çª
                for (let i = game.rocks.length - 1; i >= 0; i--) {
                    const rock = game.rocks[i];
                    if (!rock.hit && this.isCollidingWithRock(rock)) {
                        this.destroyRock(rock, i);
                        this.hasHit = true;
                        this.life = 0.3; // çŸ­ã„æ®‹å­˜æ™‚é–“
                        break;
                    }
                }
                
                // æ–­å±¤ã¨ã®è¡çª
                for (let i = game.faults.length - 1; i >= 0; i--) {
                    const fault = game.faults[i];
                    if (this.isCollidingWithFault(fault)) {
                        this.destroyFault(fault, i);
                        this.hasHit = true;
                        this.life = 0.3;
                        break;
                    }
                }
                
                // ã‚‚ãã‚‰ã¨ã®è¡çª
                for (let i = game.moles.length - 1; i >= 0; i--) {
                    const mole = game.moles[i];
                    if (this.isCollidingWithMole(mole)) {
                        this.destroyMole(mole, i);
                        this.hasHit = true;
                        this.life = 0.3;
                        break;
                    }
                }
            }
            
            isCollidingWithRock(rock) {
                const distance = Math.sqrt(
                    Math.pow(this.x - rock.x, 2) + 
                    Math.pow(this.y - rock.y, 2)
                );
                return distance < (Math.max(rock.width, rock.height) / 2 + this.width);
            }
            
            isCollidingWithFault(fault) {
                return fault.checkCrackCollision(this.x, this.y, this.width * 2, this.width * 2);
            }
            
            isCollidingWithMole(mole) {
                const distance = Math.sqrt(
                    Math.pow(this.x - mole.x, 2) + 
                    Math.pow(this.y - mole.y, 2)
                );
                return distance < (Math.max(mole.width, mole.height) / 2 + this.width);
            }
            
            destroyRock(rock, index) {
                // å²©ã‚’é…åˆ—ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
                game.rocks.splice(index, 1);
                
                // ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 30; i++) {
                    game.particles.push(new Particle(
                        rock.x + (Math.random() - 0.5) * rock.width,
                        rock.y + (Math.random() - 0.5) * rock.height,
                        Math.random() < 0.6 ? 'rock' : 'spark'
                    ));
                }
                
                // ç”»é¢ã®æºã‚ŒåŠ¹æœ
                canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                setTimeout(() => canvas.style.transform = '', 250);
                
                console.log(`å²©çŸ³ã‚’ç ´å£Šï¼æ®‹ã‚Šå²©çŸ³æ•°: ${game.rocks.length}`);
            }
            
            destroyFault(fault, index) {
                // æ–­å±¤ã‚’é…åˆ—ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
                game.faults.splice(index, 1);
                
                // æ–­å±¤ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 35; i++) {
                    game.particles.push(new Particle(
                        fault.startX + Math.random() * 100 - 50,
                        fault.y + Math.random() * 100 - 50,
                        Math.random() < 0.5 ? 'spark' : 'rock'
                    ));
                }
                
                // ã‚ˆã‚Šå¼·ã„ç”»é¢æºã‚Œ
                canvas.style.transform = `translate(${Math.random() * 25 - 12.5}px, ${Math.random() * 25 - 12.5}px)`;
                setTimeout(() => canvas.style.transform = '', 300);
                
                console.log(`æ–­å±¤ã‚’ç ´å£Šï¼æ®‹ã‚Šæ–­å±¤æ•°: ${game.faults.length}`);
            }
            
            destroyMole(mole, index) {
                // ã‚‚ãã‚‰ã‚’é…åˆ—ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
                game.moles.splice(index, 1);
                
                // ã‚‚ãã‚‰ç ´å£Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆåœŸã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
                for (let i = 0; i < 20; i++) {
                    game.particles.push(new Particle(
                        mole.x + (Math.random() - 0.5) * mole.width,
                        mole.y + (Math.random() - 0.5) * mole.height,
                        'rock'
                    ));
                }
                
                console.log(`ã‚‚ãã‚‰ã‚’é™¤å»ï¼æ®‹ã‚Šã‚‚ãã‚‰æ•°: ${game.moles.length}`);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                const startScreenY = this.startY - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                
                // æ³¥æ°´ãƒ“ãƒ¼ãƒ æœ¬ä½“ï¼ˆèŒ¶è‰²ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                const beamGradient = ctx.createLinearGradient(
                    this.startX, startScreenY,
                    this.x, screenY
                );
                beamGradient.addColorStop(0, `rgba(139, 69, 19, ${this.life * 0.4})`); // æ¿ƒã„èŒ¶è‰²
                beamGradient.addColorStop(0.5, `rgba(160, 82, 45, ${this.life * 0.8})`); // ä¸­é–“ã®èŒ¶è‰²
                beamGradient.addColorStop(1, `rgba(210, 180, 140, ${this.life})`); // æ˜ã‚‹ã„èŒ¶è‰²
                
                ctx.strokeStyle = beamGradient;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#8B4513';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, startScreenY);
                ctx.lineTo(this.x, screenY);
                ctx.stroke();
                
                // æ³¥æ°´ãƒ“ãƒ¼ãƒ ã®ä¸­å¿ƒç·šï¼ˆæ°´åˆ†ã‚’è¡¨ç¾ï¼‰
                ctx.strokeStyle = `rgba(135, 206, 235, ${this.life * 0.6})`; // æ°´è‰²
                ctx.lineWidth = this.width * 0.2;
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#87CEEB';
                
                ctx.beginPath();
                ctx.moveTo(this.startX, startScreenY);
                ctx.lineTo(this.x, screenY);
                ctx.stroke();
                
                // æ³¥æ°´ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆèŒ¶è‰²ã¨æ°´è‰²ã®æ··åˆï¼‰
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life * this.life;
                    // ãƒ©ãƒ³ãƒ€ãƒ ã§æ³¥ã‹æ°´ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                    ctx.fillStyle = Math.random() < 0.7 ? '#8B4513' : '#87CEEB';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.type = type;

                if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 12; // 8 â†’ 12ã«é«˜é€ŸåŒ–
                    this.vy = (Math.random() * -15) - 8; // ã‚ˆã‚Šé«˜é€ŸãªåˆæœŸé€Ÿåº¦
                    this.size = Math.random() * 4 + 1;
                    this.gravity = 0.6; // é‡åŠ›ã‚’å¼·åŒ–
                } else {
                    this.vx = (Math.random() - 0.5) * 6; // 4 â†’ 6ã«é«˜é€ŸåŒ–
                    this.vy = Math.random() * -8 - 3; // ã‚ˆã‚Šé«˜é€ŸãªåˆæœŸé€Ÿåº¦
                    this.size = Math.random() * 5 + 2;
                    this.gravity = 0.5; // é‡åŠ›ã‚’å¼·åŒ–
                }
            }
            
            update() {
                this.x += this.vx * 1.5; // ç§»å‹•é€Ÿåº¦ã‚’1.5å€ã«
                this.y += this.vy * 1.5; // ç§»å‹•é€Ÿåº¦ã‚’1.5å€ã«
                this.vy += this.gravity;
                this.life -= 0.04; // ãƒ©ã‚¤ãƒ•æ¸›å°‘ã‚’å°‘ã—æ—©ã
                this.size *= 0.96; // ã‚µã‚¤ã‚ºæ¸›å°‘ã‚’å°‘ã—æ—©ã
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'rock') {
                    ctx.fillStyle = '#8B4513';
                } else if (this.type === 'steam') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                } else if (this.type === 'lava') {
                    ctx.fillStyle = '#FF4500';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF4500';
                } else if (this.type === 'spark') {
                    ctx.fillStyle = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFD700';
                }
                
                const screenY = this.y - game.cameraY;
                ctx.beginPath();
                ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Rock {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 100 + 50;
                this.height = Math.random() * 60 + 30;
                this.hardness = Math.random() * 3 + 1;
                this.hit = false;
                this.points = [];
                // Generate irregular shape points
                const numPoints = Math.floor(Math.random() * 5) + 8; // 8-12 points
                const angleStep = (Math.PI * 2) / numPoints;
                for (let i = 0; i < numPoints; i++) {
                    const angle = i * angleStep;
                    const radius = (Math.random() * 0.3 + 0.7) * Math.min(this.width, this.height) / 2;
                    this.points.push({
                        x: radius * Math.cos(angle),
                        y: radius * Math.sin(angle)
                    });
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                if (this.hit) {
                    ctx.globalAlpha = 0.7;
                }
                
                // ç¡¬è³ªå²©çŸ³ã®è‰² - é»’ã‹ã‚‰æ¿ƒã„ã‚°ãƒ¬ãƒ¼ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const gradient = ctx.createLinearGradient(0, -this.height / 2, 0, this.height / 2);
                const baseOpacity = 0.9; // ã‚ˆã‚Šä¸é€æ˜ã«
                gradient.addColorStop(0, `rgba(64, 64, 64, ${baseOpacity})`); // æ¿ƒã„ã‚°ãƒ¬ãƒ¼
                gradient.addColorStop(0.3, `rgba(32, 32, 32, ${baseOpacity})`); // ã‚ˆã‚Šæš—ã„ã‚°ãƒ¬ãƒ¼
                gradient.addColorStop(0.7, `rgba(16, 16, 16, ${baseOpacity})`); // éå¸¸ã«æš—ã„ã‚°ãƒ¬ãƒ¼
                gradient.addColorStop(1, `rgba(8, 8, 8, ${baseOpacity})`); // ã»ã¼é»’
                ctx.fillStyle = gradient;

                // ä¸è¦å‰‡ãªç¡¬è³ªå²©çŸ³ã®å½¢çŠ¶ã‚’æç”»
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();

                // ç¡¬è³ªå²©çŸ³ã®çµæ™¶æ§‹é€ ã‚’è¡¨ç¾ï¼ˆå°ã•ãªæ˜ã‚‹ã„ç‚¹ï¼‰
                ctx.fillStyle = `rgba(128, 128, 128, 0.4)`;
                for (let i = 0; i < 8; i++) {
                    const x = (Math.random() - 0.5) * this.width * 0.8;
                    const y = (Math.random() - 0.5) * this.height * 0.8;
                    const size = Math.random() * 2 + 1;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // é‰±ç‰©ã®å¾®ç´°ãªå…‰æ²¢ï¼ˆéå¸¸ã«æ§ãˆã‚ï¼‰
                ctx.fillStyle = `rgba(192, 192, 192, 0.1)`;
                for (let i = 0; i < 3; i++) {
                    const x = (Math.random() - 0.5) * this.width * 0.6;
                    const y = (Math.random() - 0.5) * this.height * 0.6;
                    const size = Math.random() * 1.5 + 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ç¡¬è³ªå²©çŸ³ã®æš—ã„è¼ªéƒ­ç·š
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#2F2F2F'; // æš—ã„ã‚°ãƒ¬ãƒ¼ã®è¼ªéƒ­
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç¡¬åº¦ãŒé«˜ã„å ´åˆã®è¿½åŠ çš„ãªæš—ã•
                if (this.hardness > 2) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2 * (this.hardness - 2)})`;
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (let i = 1; i < this.points.length; i++) {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        class SteamVent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.active = true;
                this.timer = 0;
                this.radius = 20;
            }
            
            update() {
                this.timer++;
                if (this.timer % 3 === 0 && this.active) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 20,
                        this.y,
                        'steam'
                    ));
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);

                // è’¸æ°—å­”ã®ç©´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // è’¸æ°—å­”ã®å…‰
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 1.5);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // è’¸æ°—ã®è¡¨ç¾ (ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã§æç”»ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯è¿½åŠ ã®è¦–è¦šåŠ¹æœã®ã¿)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }
        
        class OilPocket {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = Math.random() * 80 + 60; // 60-140px
                this.height = Math.random() * 60 + 40; // 40-100px
                this.hit = false;
                this.collected = false;
                this.particles = [];
                this.animationTime = 0;
                this.oilLevel = 1.0; // ã‚ªã‚¤ãƒ«ã®é‡ï¼ˆ1.0 = æº€ã‚¿ãƒ³ï¼‰
                this.healAmount = 30 + Math.random() * 20; // 30-50ã®å›å¾©é‡
            }
            
            update() {
                this.animationTime++;
                
                // ã‚ªã‚¤ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç”Ÿæˆ
                if (!this.collected && Math.random() < 0.1) {
                    this.particles.push({
                        x: this.x + (Math.random() - 0.5) * this.width,
                        y: this.y + (Math.random() - 0.5) * this.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.01;
                    p.size *= 0.99;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                if (!this.collected) {
                    // ã‚­ãƒ£ãƒƒãƒ—ãƒ­ãƒƒã‚¯ï¼ˆä¸Šéƒ¨ã®ç¡¬ã„å²©ç›¤å±¤ï¼‰- ã‚ˆã‚Šè‡ªç„¶ãªå½¢çŠ¶
                    const capRockHeight = this.height * 0.25;
                    
                    // ã‚­ãƒ£ãƒƒãƒ—ãƒ­ãƒƒã‚¯ã®ä¸è¦å‰‡ãªå½¢çŠ¶ã‚’ä½œæˆ
                    ctx.fillStyle = '#708090'; // ã‚ˆã‚Šè‡ªç„¶ãªã‚°ãƒ¬ãƒ¼
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, -this.height/2);
                    
                    // ä¸è¦å‰‡ãªä¸Šé¢
                    for (let i = 0; i <= 8; i++) {
                        const x = (-this.width/2) + (this.width * i / 8);
                        const yVariation = (Math.sin(this.x * 0.01 + i * 0.8) + Math.cos(this.y * 0.005 + i * 1.2)) * 3;
                        ctx.lineTo(x, -this.height/2 + yVariation);
                    }
                    
                    // å³å´
                    ctx.lineTo(this.width/2, -this.height/2 + capRockHeight);
                    
                    // ä¸è¦å‰‡ãªä¸‹é¢ï¼ˆã‚ªã‚¤ãƒ«å±¤ã¨ã®å¢ƒç•Œï¼‰
                    for (let i = 8; i >= 0; i--) {
                        const x = (-this.width/2) + (this.width * i / 8);
                        const yVariation = (Math.sin(this.x * 0.008 + i * 1.1) + Math.cos(this.y * 0.006 + i * 0.9)) * 5;
                        ctx.lineTo(x, -this.height/2 + capRockHeight + yVariation);
                    }
                    
                    // å·¦å´
                    ctx.lineTo(-this.width/2, -this.height/2);
                    ctx.fill();
                    
                    // ã‚­ãƒ£ãƒƒãƒ—ãƒ­ãƒƒã‚¯ã®å±¤ç†æ§‹é€ 
                    ctx.strokeStyle = 'rgba(105, 105, 105, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 1; i < 4; i++) {
                        const layerY = -this.height/2 + (capRockHeight * i / 4);
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + 5, layerY);
                        for (let j = 0; j <= 6; j++) {
                            const x = (-this.width/2 + 5) + ((this.width - 10) * j / 6);
                            const variation = Math.sin(this.x * 0.02 + j * 0.5) * 2;
                            ctx.lineTo(x, layerY + variation);
                        }
                        ctx.stroke();
                    }
                    
                    // å¤šå­”è³ªãªè²¯ç•™å±¤ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªå½¢çŠ¶ï¼‰
                    const reservoirTop = -this.height/2 + capRockHeight;
                    const reservoirHeight = this.height * 0.75;
                    
                    // èƒŒæ™¯ã®å²©çŸ³å±¤
                    const rockGradient = ctx.createLinearGradient(0, reservoirTop, 0, reservoirTop + reservoirHeight);
                    rockGradient.addColorStop(0, '#D2B48C'); // ç ‚å²©è‰²
                    rockGradient.addColorStop(0.5, '#F4A460'); // ã‚ˆã‚Šæ˜ã‚‹ã„ç ‚å²©
                    rockGradient.addColorStop(1, '#CD853F'); // æ¿ƒã„ç ‚å²©
                    ctx.fillStyle = rockGradient;
                    
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, reservoirTop);
                    
                    // ä¸è¦å‰‡ãªå¢ƒç•Œç·š
                    for (let i = 0; i <= 10; i++) {
                        const x = (-this.width/2) + (this.width * i / 10);
                        const topVariation = Math.sin(this.x * 0.01 + i * 0.7) * 3;
                        const bottomVariation = Math.cos(this.x * 0.012 + i * 0.9) * 4;
                        
                        if (i === 0) {
                            ctx.moveTo(x, reservoirTop + topVariation);
                        } else if (i === 10) {
                            ctx.lineTo(x, reservoirTop + topVariation);
                            ctx.lineTo(x, this.height/2 + bottomVariation);
                            
                            // åº•é¢
                            for (let j = 10; j >= 0; j--) {
                                const bottomX = (-this.width/2) + (this.width * j / 10);
                                const bottomVar = Math.cos(this.x * 0.012 + j * 0.9) * 4;
                                ctx.lineTo(bottomX, this.height/2 + bottomVar);
                            }
                            
                            ctx.lineTo(-this.width/2, reservoirTop);
                        } else {
                            ctx.lineTo(x, reservoirTop + topVariation);
                        }
                    }
                    ctx.fill();
                    
                    // ã‚ªã‚¤ãƒ«ï¼ˆåŸæ²¹ï¼‰ã®è¡¨ç¾
                    if (this.oilLevel > 0) {
                        const oilHeight = reservoirHeight * 0.8 * this.oilLevel;
                        
                        // ã‚ªã‚¤ãƒ«ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                        const oilGradient = ctx.createLinearGradient(0, this.height/2 - oilHeight, 0, this.height/2);
                        oilGradient.addColorStop(0, 'rgba(139, 69, 19, 0.9)'); // æ¿ƒã„èŒ¶è‰²
                        oilGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.95)'); // é»’
                        oilGradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.9)'); // æ¿ƒã„èŒ¶è‰²
                        oilGradient.addColorStop(1, 'rgba(139, 69, 19, 0.8)'); // ã‚„ã‚„æ˜ã‚‹ã„èŒ¶è‰²
                        
                        ctx.fillStyle = oilGradient;
                        ctx.fillRect(-this.width/2 + 8, this.height/2 - oilHeight, this.width - 16, oilHeight);
                        
                        // ã‚ªã‚¤ãƒ«ã®è¡¨é¢ã®æ³¢ç´‹åŠ¹æœ
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 1;
                        const surfaceY = this.height/2 - oilHeight;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + 8, surfaceY);
                        for (let i = 0; i <= 8; i++) {
                            const x = (-this.width/2 + 8) + ((this.width - 16) * i / 8);
                            const wave = Math.sin(this.animationTime * 0.05 + i * 0.5) * 1.5;
                            ctx.lineTo(x, surfaceY + wave);
                        }
                        ctx.stroke();
                        
                        // ã‚ªã‚¤ãƒ«ã®å…‰æ²¢
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        ctx.fillRect(-this.width/2 + 10, surfaceY, this.width - 20, 3);
                    }
                    
                    // å¤šå­”è³ªæ§‹é€ ã®è¡¨ç¾ï¼ˆå°ã•ãªç©´ï¼‰
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    for (let i = 0; i < 15; i++) {
                        const poreX = (Math.random() - 0.5) * (this.width - 20);
                        const poreY = reservoirTop + Math.random() * reservoirHeight * 0.8;
                        const poreSize = Math.random() * 2 + 1;
                        ctx.beginPath();
                        ctx.arc(poreX, poreY, poreSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // ç™ºè¦‹ãƒãƒ¼ã‚¯ï¼ˆã‚ˆã‚Šæ§ãˆã‚ã«ï¼‰
                    if (Math.abs(this.x - game.drillX) < 80 && Math.abs(this.y - game.drillY) < 80) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillText('âš«', 0, -this.height/2 - 15);
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // æ¡æ˜æ¸ˆã¿ã®è·¡ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªç©´ï¼‰
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(101, 67, 33, 0.4)');
                    gradient.addColorStop(1, 'rgba(139, 69, 19, 0.2)');
                    ctx.fillStyle = gradient;
                    
                    ctx.beginPath();
                    // ä¸è¦å‰‡ãªæ¡æ˜è·¡
                    for (let i = 0; i <= 16; i++) {
                        const angle = (Math.PI * 2 * i) / 16;
                        const radius = (this.width/2.5) + Math.sin(i * 0.7) * 8;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius * 0.7;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.fill();
                }
                
                // ã‚ªã‚¤ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆã‚ˆã‚Šç¾å®Ÿçš„ã«ï¼‰
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life * 0.6;
                    ctx.fillStyle = '#654321'; // ã‚ˆã‚Šè‡ªç„¶ãªæ²¹ã®è‰²
                    ctx.beginPath();
                    ctx.arc(p.x - this.x, p.y - screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }

        class OilMoney {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 80;
                this.collected = false;
                this.animationTime = 0;
                this.value = 500 + Math.random() * 500; // 500-1000ãƒã‚¤ãƒ³ãƒˆ
                this.image = new Image();
                this.image.src = 'sekiyu_oil_money.png';
                this.imageLoaded = false;
                
                this.image.onload = () => {
                    this.imageLoaded = true;
                };
                
                // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                this.rotation = 0;
                this.rotationSpeed = 0.02;
                
                // æµ®éŠã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                this.floatOffset = Math.random() * Math.PI * 2;
                this.floatAmplitude = 10;
            }
            
            update() {
                this.animationTime++;
                this.rotation += this.rotationSpeed;
                
                // æµ®éŠåŠ¹æœ
                this.y += Math.sin(this.animationTime * 0.05 + this.floatOffset) * 0.3;
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                if (this.imageLoaded) {
                    // ç”»åƒã‚’æç”»
                    ctx.save();
                    ctx.rotate(this.rotation);
                    
                    // ç”»åƒã®ã‚µã‚¤ã‚ºã‚’èª¿æ•´
                    const imageWidth = this.width;
                    const imageHeight = this.height;
                    
                    ctx.drawImage(
                        this.image,
                        -imageWidth / 2,
                        -imageHeight / 2,
                        imageWidth,
                        imageHeight
                    );
                    
                    ctx.restore();
                    
                    // å…‰ã‚‹åŠ¹æœ
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(this.animationTime * 0.1) * 0.2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FFD700';
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2 + 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 3;
                    
                    // ã‚ªã‚¤ãƒ«ãƒ‰ãƒ©ãƒ 
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                    
                    // "OIL" ãƒ†ã‚­ã‚¹ãƒˆ
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('OIL', 0, 5);
                }
                
                // ä¾¡å€¤è¡¨ç¤º
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(`$${Math.floor(this.value)}`, 0, this.height/2 + 20);
                ctx.fillText(`$${Math.floor(this.value)}`, 0, this.height/2 + 20);
                
                ctx.restore();
            }
        }

        class Mole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4; // ç§»å‹•é€Ÿåº¦ã‚’2å€ã«
                this.vy = 0;
                this.width = 40;
                this.height = 30;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.animationTime = 0;
                this.tunnelX = x;
                this.surprised = false;
                this.fleeing = false;
            }
            
            update() {
                this.animationTime++;
                
                // ãƒ‰ãƒªãƒ«ã¨ã®è·é›¢ã‚’è¨ˆç®—
                const distance = Math.sqrt(
                    Math.pow(this.x - game.drillX, 2) + 
                    Math.pow(this.y - game.drillY, 2)
                );
                
                // ãƒ‰ãƒªãƒ«ãŒè¿‘ã¥ã„ãŸã‚‰é©šã„ã¦é€ƒã’ã‚‹
                if (distance < 150 && !this.fleeing) {
                    this.surprised = true;
                    this.fleeing = true;
                    this.vx = (this.x - game.drillX) * 0.2; // é€ƒã’ã‚‹é€Ÿåº¦ã‚’2å€ã«
                    this.vy = -4; // å‚ç›´ç§»å‹•ã‚‚2å€ã«
                }
                
                if (this.fleeing) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.95;
                    this.vy += 0.1;
                } else {
                    // é€šå¸¸ã®ç§»å‹•
                    this.x += Math.sin(this.animationTime * 0.05) * 0.5 * this.direction;
                    
                    // ç”»é¢ç«¯ã§æ–¹å‘è»¢æ›
                    if (this.x < 50 || this.x > canvas.width - 50) {
                        this.direction *= -1;
                    }
                }
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                if (screenY < -100 || screenY > canvas.height + 100) return;
                
                ctx.save();
                ctx.translate(this.x, screenY);
                
                // ã‚‚ãã‚‰ã®ç©´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ã‚‚ãã‚‰ã®ä½“ (ã‚ˆã‚Šæœ‰æ©Ÿçš„ãªå½¢çŠ¶ã¨æ¯›ä¸¦ã¿)
                ctx.fillStyle = '#4B3621';
                ctx.strokeStyle = '#3A2B1A';
                ctx.lineWidth = 1;
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;

                ctx.beginPath();
                ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // æ¯›ä¸¦ã¿ã®è¡¨ç¾ (ç°¡å˜ãªç·šã§)
                for(let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 15;
                    ctx.beginPath();
                    ctx.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                    ctx.lineTo(radius * Math.cos(angle) * 1.2, radius * Math.sin(angle) * 1.2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.stroke();
                }
                
                // ã‚‚ãã‚‰ã®é ­
                ctx.fillStyle = '#5C4033';
                ctx.beginPath();
                ctx.ellipse(this.direction * 15, -5, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // é¼» (ã‚ˆã‚Šãƒªã‚¢ãƒ«ã«)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(this.direction * 22, -5, 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç›® (è¡¨æƒ…è±Šã‹ã«)
                if (this.surprised) {
                    // é©šã„ãŸç›®
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 4, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // é€šå¸¸ã®ç›®
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.direction * 15 - 5, -8, 2, 0, Math.PI * 2);
                    ctx.arc(this.direction * 15 + 5, -8, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // æ‰‹ (ã‚ˆã‚Šè©³ç´°ã«)
                ctx.fillStyle = '#4B3621';
                ctx.beginPath();
                ctx.ellipse(-10, 5, 6, 8, -0.3, 0, Math.PI * 2);
                ctx.ellipse(10, 5, 6, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // åœŸã®ç²’å­
                if (!this.fleeing && Math.random() < 0.3) {
                    game.particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 30,
                        this.y + 10,
                        'rock'
                    ));
                }
                
                // é©šããƒãƒ¼ã‚¯
                if (this.surprised && !this.fleeing) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', 0, -25);
                }
                
                ctx.restore();
            }
        }
        
        class Fault {
            constructor(y) {
                this.y = y;
                this.startX = Math.random() * (canvas.width - 400) + 200; // æ–­å±¤ã®é–‹å§‹Xä½ç½®
                this.length = Math.random() * 400 + 300; // æ–­å±¤ã®é•·ã•ï¼ˆ300-700pxï¼‰
                this.angle = (Math.random() * 60 - 30) * Math.PI / 180; // -30åº¦ã‹ã‚‰+30åº¦ã®è§’åº¦
                this.warningWidth = 60; // è­¦å‘Šç¯„å›²ã®å¹…
                this.particles = [];
                this.crackPoints = [];
                
                // æ–œã‚ã®äº€è£‚ã®å½¢çŠ¶ã‚’ç”Ÿæˆ
                const numPoints = Math.floor(Math.random() * 8) + 12; // 12-19 points
                for (let i = 0; i <= numPoints; i++) {
                    const progress = i / numPoints;
                    
                    // åŸºæœ¬ã®æ–œã‚ãƒ©ã‚¤ãƒ³
                    const baseX = Math.cos(this.angle) * this.length * progress;
                    const baseY = Math.sin(this.angle) * this.length * progress;
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªãšã‚Œã‚’è¿½åŠ ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªäº€è£‚ã«ï¼‰
                    const randomOffset = (Math.random() - 0.5) * 40;
                    const perpX = -Math.sin(this.angle) * randomOffset;
                    const perpY = Math.cos(this.angle) * randomOffset;
                    
                    this.crackPoints.push({ 
                        x: baseX + perpX, 
                        y: baseY + perpY 
                    });
                }
            }
            
            // äº€è£‚éƒ¨åˆ†ã¨ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆæ–œã‚å¯¾å¿œï¼‰
            checkCrackCollision(drillX, drillY, drillWidth, drillHeight) {
                const crackThickness = 15; // äº€è£‚ã®åšã¿
                
                for (let i = 0; i < this.crackPoints.length - 1; i++) {
                    const p1 = this.crackPoints[i];
                    const p2 = this.crackPoints[i + 1];
                    
                    // ç·šåˆ†ã®ä¸¡ç«¯ï¼ˆæ–œã‚ã®äº€è£‚ï¼‰
                    const x1 = this.startX + p1.x;
                    const y1 = this.y + p1.y;
                    const x2 = this.startX + p2.x;
                    const y2 = this.y + p2.y;
                    
                    // ãƒ‰ãƒªãƒ«ã®çŸ©å½¢ã¨ç·šåˆ†ã®äº¤å·®åˆ¤å®š
                    if (this.lineIntersectsRect(x1, y1, x2, y2, 
                        drillX - drillWidth/2, drillY - drillHeight/2, 
                        drillWidth, drillHeight, crackThickness)) {
                        return true;
                    }
                }
                return false;
            }
            
            // ç·šåˆ†ã¨çŸ©å½¢ã®äº¤å·®åˆ¤å®šï¼ˆå¤ªã„ç·šã¨ã—ã¦æ‰±ã†ï¼‰
            lineIntersectsRect(x1, y1, x2, y2, rectX, rectY, rectWidth, rectHeight, thickness) {
                // å¤ªã„ç·šã‚’çŸ©å½¢ã¨ã—ã¦æ‰±ã†
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return false;
                
                // æ­£è¦åŒ–ã•ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«
                const nx = dx / length;
                const ny = dy / length;
                
                // å‚ç›´ãƒ™ã‚¯ãƒˆãƒ«
                const px = -ny * thickness / 2;
                const py = nx * thickness / 2;
                
                // å¤ªã„ç·šã®4ã¤ã®è§’
                const corners = [
                    { x: x1 + px, y: y1 + py },
                    { x: x1 - px, y: y1 - py },
                    { x: x2 + px, y: y2 + py },
                    { x: x2 - px, y: y2 - py }
                ];
                
                // ä»»æ„ã®è§’ãŒãƒ‰ãƒªãƒ«ã®çŸ©å½¢å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                for (const corner of corners) {
                    if (corner.x >= rectX && corner.x <= rectX + rectWidth &&
                        corner.y >= rectY && corner.y <= rectY + rectHeight) {
                        return true;
                    }
                }
                
                return false;
            }
            
            update() {
                // è­¦å‘Šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆæ–œã‚æ–­å±¤ç”¨ï¼‰
                if (Math.random() < 0.3) {
                    // æ–­å±¤ç·šä¸Šã®ä»»æ„ã®ç‚¹ã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
                    const progress = Math.random();
                    const baseX = Math.cos(this.angle) * this.length * progress;
                    const baseY = Math.sin(this.angle) * this.length * progress;
                    
                    this.particles.push({
                        x: this.startX + baseX + (Math.random() - 0.5) * this.warningWidth,
                        y: this.y + baseY + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        life: 1,
                        size: Math.random() * 3 + 2
                    });
                }
                
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= 0.02;
                    p.size *= 0.98;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
            }
            
            draw() {
                const screenY = this.y - game.cameraY;
                
                // æ–­å±¤ã®å¢ƒç•Œã‚’è¨ˆç®—ï¼ˆæ–œã‚ç·šã®å ´åˆï¼‰
                const endX = this.startX + Math.cos(this.angle) * this.length;
                const endY = this.y + Math.sin(this.angle) * this.length;
                const screenEndY = endY - game.cameraY;
                
                // ç”»é¢å¤–ã®å ´åˆã¯æç”»ã—ãªã„
                const minY = Math.min(screenY, screenEndY);
                const maxY = Math.max(screenY, screenEndY);
                if (maxY < -50 || minY > canvas.height + 50) return;
                
                // è­¦å‘Šã‚¾ãƒ¼ãƒ³ï¼ˆæ–­å±¤ã®ä¸¡å´ã«æ²¿ã£ã¦ï¼‰
                if (minY < canvas.height && maxY > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.4;
                    
                    // æ–­å±¤ã«æ²¿ã£ãŸè­¦å‘Šã‚¨ãƒªã‚¢ã‚’æç”»
                    const perpX = -Math.sin(this.angle) * this.warningWidth;
                    const perpY = Math.cos(this.angle) * this.warningWidth;
                    
                    // è­¦å‘Šã‚¾ãƒ¼ãƒ³ã®å››è§’å½¢
                    const warningPoints = [
                        { x: this.startX + perpX, y: screenY + perpY },
                        { x: this.startX - perpX, y: screenY - perpY },
                        { x: endX - perpX, y: screenEndY - perpY },
                        { x: endX + perpX, y: screenEndY + perpY }
                    ];
                    
                    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è­¦å‘Šã‚¾ãƒ¼ãƒ³
                    const gradient = ctx.createLinearGradient(
                        this.startX - perpX, screenY - perpY,
                        this.startX + perpX, screenY + perpY
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                    gradient.addColorStop(0.4, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(0.6, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(warningPoints[0].x, warningPoints[0].y);
                    for (let i = 1; i < warningPoints.length; i++) {
                        ctx.lineTo(warningPoints[i].x, warningPoints[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                
                // æ–­å±¤æœ¬ä½“ï¼ˆæ–œã‚ã®äº€è£‚ã¨ã—ã¦æç”»ï¼‰
                ctx.save();
                ctx.strokeStyle = '#333333'; // äº€è£‚ã®è‰²
                ctx.lineWidth = 12; // äº€è£‚ã®å¤ªã•ã‚’å°‘ã—å¤ªã
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#000';

                ctx.beginPath();
                if (this.crackPoints.length > 0) {
                    const firstPoint = this.crackPoints[0];
                    ctx.moveTo(this.startX + firstPoint.x, this.y + firstPoint.y - game.cameraY);
                    for (let i = 1; i < this.crackPoints.length; i++) {
                        const point = this.crackPoints[i];
                        ctx.lineTo(this.startX + point.x, this.y + point.y - game.cameraY);
                    }
                }
                ctx.stroke();

                // äº€è£‚ã®å…‰ã‚‹ç¸
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#FF0000';
                ctx.beginPath();
                if (this.crackPoints.length > 0) {
                    const firstPoint = this.crackPoints[0];
                    ctx.moveTo(this.startX + firstPoint.x, this.y + firstPoint.y - game.cameraY);
                    for (let i = 1; i < this.crackPoints.length; i++) {
                        const point = this.crackPoints[i];
                        ctx.lineTo(this.startX + point.x, this.y + point.y - game.cameraY);
                    }
                }
                ctx.stroke();
                
                // è­¦å‘Šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = '#FF6347';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - game.cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                
                // è­¦å‘Šãƒ†ã‚­ã‚¹ãƒˆï¼ˆæ–­å±¤ã®ä¸­å¤®ã«è¡¨ç¤ºï¼‰
                const centerX = this.startX + Math.cos(this.angle) * this.length / 2;
                const centerY = this.y + Math.sin(this.angle) * this.length / 2;
                const screenCenterY = centerY - game.cameraY;
                
                if (screenCenterY > 40 && screenCenterY < canvas.height - 40 && 
                    centerX > 0 && centerX < canvas.width) {
                    ctx.save();
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF0000';
                    
                    // ãƒ†ã‚­ã‚¹ãƒˆã‚’æ–­å±¤ã®è§’åº¦ã«åˆã‚ã›ã¦å›è»¢
                    ctx.translate(centerX, screenCenterY - 30);
                    ctx.rotate(this.angle);
                    ctx.fillText('âš  æ–­å±¤ âš ', 0, 0);
                    ctx.restore();
                }
            }
        }
        
        function generateTerrain() {
            // ç”»é¢ä¸‹ç«¯ã‹ã‚‰å°‘ã—å…ˆã®ä½ç½®ã§éšœå®³ç‰©ã‚’ç”Ÿæˆ
            const spawnY = game.cameraY + canvas.height + 200;
            const spawnCheck = Math.floor(spawnY / 100) * 100;
            
            if (!game.generatedSpawns) game.generatedSpawns = new Set();
            
            if (!game.generatedSpawns.has(spawnCheck)) {
                game.generatedSpawns.add(spawnCheck);
                
                // ã‚‚ãã‚‰ï¼ˆ500-2000mã®éƒ¨åˆ†ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth >= 500 && game.depth < 2000) {
                    if (Math.random() < 0.3) {
                        game.moles.push(new Mole(
                            Math.random() * (canvas.width - 100) + 50,
                            spawnY
                        ));
                    }
                }
                
                // å²©ã®ç”Ÿæˆ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                const rockCount = Math.floor(Math.random() * 2) + 1 + Math.floor(game.depth / 2000);
                for (let i = 0; i < rockCount; i++) {
                    const rock = new Rock(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    );
                    rock.hardness += game.depth / 3000;
                    game.rocks.push(rock);
                }
                
                // è’¸æ°—å­”ï¼ˆ1500mä»¥é™ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth > 1500 && Math.random() < 0.2 + game.depth / 8000) {
                    game.steamVents.push(new SteamVent(
                        Math.random() * (canvas.width - 100) + 50,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆï¼ˆ800mä»¥é™ã€2000mæœªæº€ï¼‰ - æ¯”è¼ƒçš„æµ…ã„å±¤ã«é…ç½®
                if (game.depth >= 800 && game.depth < 2000 && Math.random() < 0.15) {
                    game.oilPockets.push(new OilPocket(
                        Math.random() * (canvas.width - 200) + 100,
                        spawnY + Math.random() * 100
                    ));
                }
                
                // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ï¼ˆåºç›¤ã‹ã‚‰å‡ºç¾ï¼‰ - ãƒ¬ã‚¢ã‚¢ã‚¤ãƒ†ãƒ 
                if (game.depth >= 200 && Math.random() < 0.05) {
                    game.oilMoney.push(new OilMoney(
                        Math.random() * (canvas.width - 120) + 60,
                        spawnY + Math.random() * 150
                    ));
                }
                
                // æ–­å±¤ï¼ˆ2500mä»¥é™ï¼‰ - ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
                if (game.depth > 2500) {
                    const faultChance = 0.1 + (game.depth - 2500) / 15000;
                    if (Math.random() < faultChance) {
                        game.faults.push(new Fault(spawnY + Math.random() * 100));
                    }
                }
            }
        }
        
        function updateGame() {
            if (!game.gameRunning) return;

            // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ã®ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
            if (game.starMode) {
                game.starModeTimer -= 1/60; // 60FPSã‚’æƒ³å®š
                if (game.starModeTimer <= 0) {
                    game.starMode = false;
                    game.starModeTimer = 0;
                    console.log('â­ ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹çµ‚äº†');
                }
            }
            
            // ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
            if (game.comboTimer > 0) {
                game.comboTimer -= 1/60; // 60FPSã‚’æƒ³å®š
                if (game.comboTimer <= 0) {
                    game.comboCount = 0; // ã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆ
                }
            }

            // --- START OF NEW EFFECTS ---

            // 1. Continuous screen shake for drilling vibrationï¼ˆå¼·åŒ–ç‰ˆï¼‰
            let shakeIntensity = Math.min(game.drillSpeed / 5, 3.0); // åŸºæœ¬å¼·åº¦ã‚’2å€ã«
            
            // æ·±åº¦ã«å¿œã˜ã¦ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦ã‚’å¢—åŠ 
            if (game.depth > 3000) {
                shakeIntensity *= 1.5; // æ·±éƒ¨ã§ã¯1.5å€
            }
            if (game.depth > 5000) {
                shakeIntensity *= 1.8; // æ¥µæ·±éƒ¨ã§ã¯1.8å€
            }
            
            // ã‚ˆã‚Šå‹•çš„ãªã‚·ã‚§ã‚¤ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³
            const shakeX = (Math.random() - 0.5) * shakeIntensity + Math.sin(Date.now() * 0.01) * (shakeIntensity * 0.3);
            const shakeY = (Math.random() - 0.5) * shakeIntensity + Math.cos(Date.now() * 0.008) * (shakeIntensity * 0.3);
            canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;

            // 2. Continuous drilling particle generationï¼ˆå¼·åŒ–ç‰ˆï¼‰
            const particleCount = Math.ceil(game.drillSpeed * 2); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’2å€ã«å¢—åŠ 
            for (let i = 0; i < particleCount; i++) {
                let particleType = 'rock';
                if (game.depth > 5000) {
                    particleType = Math.random() < 0.7 ? 'lava' : 'spark'; // æ·±éƒ¨ã§ã¯æº¶å²©ã¨ç«èŠ±
                } else if (game.depth > 3000) {
                    if (Math.random() < 0.5) particleType = 'lava';
                    if (Math.random() < 0.3) particleType = 'spark'; // ç«èŠ±ã‚‚è¿½åŠ 
                } else if (game.depth > 1000) {
                    if (Math.random() < 0.2) particleType = 'spark'; // ä¸­æ·±åº¦ã§ã‚‚ç«èŠ±
                }
                
                // ã‚ˆã‚Šåºƒç¯„å›²ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ•£ã‚‰ã™
                game.particles.push(new Particle(
                    game.drillX + (Math.random() - 0.5) * 50, // ç¯„å›²ã‚’æ‹¡å¤§
                    game.drillY + 60 + (Math.random() - 0.5) * 20, // ç¸¦æ–¹å‘ã«ã‚‚æ•£ã‚‰ã™
                    particleType
                ));
            }
            
            // è¿½åŠ ã®çˆ†ç™ºçš„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆç¢ºç‡çš„ã«ï¼‰
            if (Math.random() < 0.15) {
                for (let i = 0; i < 8; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 80,
                        game.drillY + 40 + (Math.random() - 0.5) * 40,
                        Math.random() < 0.5 ? 'spark' : 'rock'
                    ));
                }
            }
            
            // æ˜å‰ŠéŸ³ã‚’å†ç”Ÿï¼ˆç¢ºç‡çš„ã«ï¼‰- é »åº¦ã‚’ä¸Šã’ã¦çˆ½å¿«æ„Ÿå‘ä¸Š
            if (Math.random() < 0.25) { // 10% â†’ 25%ã«å¢—åŠ 
                audioManager.playSound('drilling');
            }

            // 3. Spark generation at high temperatures + æ·±åº¦åŠ¹æœ
            if (game.temperature > 800) {
                if (Math.random() < (game.temperature - 800) / 1000) {
                    game.particles.push(new Particle(game.drillX, game.drillY + 40, 'spark'));
                }
            }
            
            // 4. æ·±åº¦ã«å¿œã˜ãŸç‰¹æ®ŠåŠ¹æœ
            if (game.depth > 2000) {
                // æ·±åº¦2000mä»¥ä¸Šï¼šåœ°ç†±ã®å½±éŸ¿ã§ã‚ˆã‚Šå¤šãã®ç«èŠ±
                if (Math.random() < 0.08) {
                    for (let i = 0; i < 3; i++) {
                        game.particles.push(new Particle(
                            game.drillX + (Math.random() - 0.5) * 60,
                            game.drillY + 30 + Math.random() * 40,
                            'spark'
                        ));
                    }
                }
            }
            
            if (game.depth > 4000) {
                // æ·±åº¦4000mä»¥ä¸Šï¼šæº¶å²©ã®å½±éŸ¿ã§ã‚ªãƒ¬ãƒ³ã‚¸è‰²ã®å…‰ã‚‹åŠ¹æœ
                if (Math.random() < 0.05) {
                    canvas.style.filter = 'brightness(1.2) sepia(0.3) hue-rotate(20deg)';
                    setTimeout(() => canvas.style.filter = '', 100);
                }
            }
            
            if (game.depth > 6000) {
                // æ·±åº¦6000mä»¥ä¸Šï¼šæ¥µé™çŠ¶æ…‹ã§èµ¤ã„å…‰ã‚‹åŠ¹æœ
                if (Math.random() < 0.03) {
                    canvas.style.filter = 'brightness(1.4) sepia(0.8) hue-rotate(0deg) saturate(2)';
                    setTimeout(() => canvas.style.filter = '', 200);
                }
            }

            // --- END OF NEW EFFECTS ---
            
            // ãƒ‘ã‚¤ãƒ—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®è¿½åŠ ï¼ˆ10ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ï¼‰
            if (game.pipeSegments.length === 0 || 
                game.drillY - game.pipeSegments[game.pipeSegments.length - 1].y > 10) {
                game.pipeSegments.push({
                    x: game.drillX,
                    y: game.drillY,
                    angle: Math.atan2(
                        game.drillX - (game.pipeSegments.length > 0 ? 
                            game.pipeSegments[game.pipeSegments.length - 1].x : game.drillX),
                        10
                    )
                });
            }
            
            // è‡ªå‹•æ˜å‰Šï¼ˆä¸‹æ–¹å‘ã¸ã®ç§»å‹•ï¼‰
            game.drillY += game.drillSpeed;
            game.depth = Math.floor(game.drillY / 10);
            game.maxDepth = Math.max(game.maxDepth, game.depth);
            
            // ã‚«ãƒ¡ãƒ©ã®è¿½å¾“
            game.cameraY = game.drillY - 100;
            
            // å·¦å³ç§»å‹•ï¼ˆé€Ÿåº¦åˆ¶é™ï¼‰
            const baseMoveSpeed = 3.0; // åŸºæœ¬ç§»å‹•é€Ÿåº¦ã‚’é«˜é€ŸåŒ–
            const moveSpeed = baseMoveSpeed + (game.drillSpeed * 0.15); // æ˜å‰Šé€Ÿåº¦ã®å½±éŸ¿ã‚’å¢—åŠ 
            const maxMoveSpeed = 5.0; // æœ€å¤§ç§»å‹•é€Ÿåº¦ã‚’é«˜é€ŸåŒ–
            const actualMoveSpeed = Math.min(moveSpeed, maxMoveSpeed);
            
            if (keys['ArrowLeft'] && game.drillX > 50) {
                game.drillX -= actualMoveSpeed;
            }
            if (keys['ArrowRight'] && game.drillX < canvas.width - 50) {
                game.drillX += actualMoveSpeed;
            }
            
            // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚­ãƒ¼å…¥åŠ›ã®ç¢ºèª
            // console.log('Keys:', keys, 'DrillX:', game.drillX);
            
            // æ¸©åº¦ä¸Šæ˜‡
            game.temperature = 15 + game.depth * 0.035;
            if (game.depth > 3000) {
                game.temperature += (game.depth - 3000) * 0.05; // 3000mä»¥é™ã¯æ€¥æ¿€ã«æ¸©åº¦ä¸Šæ˜‡
            }
            game.maxTemp = Math.max(game.maxTemp, game.temperature);
            
            // è¡çªãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
            let hitObstacle = false;
            
            // è­¦å‘Šè¡¨ç¤º
            const shouldShowWarning = game.temperature > 1000;
            document.getElementById('warningText').style.display = shouldShowWarning ? 'block' : 'none';
            
            // é«˜æ¸©è­¦å‘ŠéŸ³ï¼ˆãŸã¾ã«å†ç”Ÿï¼‰
            if (shouldShowWarning && Math.random() < 0.02) {
                audioManager.playSound('warning');
            }
            
            // åœ°å½¢ç”Ÿæˆ
            generateTerrain();
            
            // ã‚‚ãã‚‰ã®æ›´æ–°ã¨è¡çªãƒã‚§ãƒƒã‚¯
            game.moles.forEach(mole => {
                mole.update();
                
                // ã‚‚ãã‚‰ã¨ã®è¡çªï¼ˆå…ˆç«¯ãƒ“ãƒƒãƒˆã®ã¿ã€ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯å°‘ãªã„ï¼‰
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ãƒ‰ãƒªãƒ«å…¨ä½“ã®æœ€ä¸‹ç«¯
                
                if (!mole.fleeing &&
                    Math.abs(mole.x - bitTipX) < 20 &&
                    Math.abs(mole.y - bitTipY) < 20) {
                    
                    game.drillDurability -= 5;
                    hitObstacle = true;
                    mole.surprised = true;
                    mole.fleeing = true;
                    
                    // ã‹ã‚ã„ã„è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 5; i++) {
                        game.particles.push(new Particle(mole.x, mole.y, 'rock'));
                    }
                    
                    // è¡çªéŸ³ã‚’å†ç”Ÿ
                    audioManager.playSound('collision');
                }
            });
            
            // å²©ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆå…ˆç«¯ãƒ“ãƒƒãƒˆã®ã¿ï¼‰
            game.rocks.forEach(rock => {
                // ãƒ“ãƒƒãƒˆå…ˆç«¯ä½ç½®ï¼ˆãƒ‰ãƒªãƒ«ã®æœ€ä¸‹ç«¯ï¼‰
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ãƒ‰ãƒªãƒ«å…¨ä½“ã®æœ€ä¸‹ç«¯
                const bitTipRadius = 25; // ãƒ“ãƒƒãƒˆå…ˆç«¯ã®å°ã•ãªç¯„å›²
                
                if (!rock.hit &&
                    Math.abs(rock.x - bitTipX) < (rock.width/2 + bitTipRadius) &&
                    Math.abs(rock.y - bitTipY) < (rock.height/2 + bitTipRadius)) {
                    
                    rock.hit = true;
                    game.drillDurability -= rock.hardness * 3;
                    hitObstacle = true;
                    
                    // ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ 
                    game.comboCount++;
                    game.comboTimer = game.comboMaxTime;
                    
                    // ã‚³ãƒ³ãƒœã«å¿œã˜ã¦åŠ¹æœã‚’å¼·åŒ–
                    const comboMultiplier = Math.min(game.comboCount / 5, 2.0); // æœ€å¤§2å€
                    const baseParticles = 15;
                    const comboParticles = Math.floor(baseParticles * (1 + comboMultiplier));
                    
                    // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (å²©ã¨ç«èŠ±) - ã‚³ãƒ³ãƒœã§å¼·åŒ–
                    for (let i = 0; i < comboParticles; i++) {
                        game.particles.push(new Particle(
                            game.drillX + (Math.random() - 0.5) * 60 * (1 + comboMultiplier * 0.5),
                            game.drillY + 40 + (Math.random() - 0.5) * 30,
                            i < comboParticles * 0.7 ? 'rock' : 'spark'
                        ));
                    }
                    
                    // å²©çŸ³ç ´å£ŠéŸ³ã‚’å†ç”Ÿ
                    audioManager.playSound('rockBreak');
                    
                    // ã‚³ãƒ³ãƒœãŒé«˜ã„å ´åˆã®ç‰¹åˆ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (game.comboCount >= 5) {
                        canvas.style.filter = 'brightness(1.3) saturate(1.5) hue-rotate(60deg)';
                        setTimeout(() => canvas.style.filter = '', 200);
                    }
                    if (game.comboCount >= 10) {
                        // è¶…ã‚³ãƒ³ãƒœæ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        for (let i = 0; i < 20; i++) {
                            game.particles.push(new Particle(
                                game.drillX + (Math.random() - 0.5) * 100,
                                game.drillY + (Math.random() - 0.5) * 100,
                                'spark'
                            ));
                        }
                    }
                    
                    // ç”»é¢ã®æºã‚ŒåŠ¹æœï¼ˆå¼·åŒ–ï¼‰
                    canvas.style.transform = `translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
                    setTimeout(() => canvas.style.transform = '', 150);
                }
            });
            
            // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
            game.oilPockets.forEach(oilPocket => {
                oilPocket.update();
                
                if (!oilPocket.collected &&
                    Math.abs(oilPocket.x - game.drillX) < (oilPocket.width/2 + 20) &&
                    Math.abs(oilPocket.y - game.drillY) < (oilPocket.height/2 + 30)) {
                    
                    oilPocket.collected = true;
                    
                    // ãƒ‰ãƒªãƒ«è€ä¹…åº¦å›å¾©
                    const oldDurability = game.drillDurability;
                    game.drillDurability += oilPocket.healAmount;
                    game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
                    
                    // å›å¾©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 20; i++) {
                        game.particles.push(new Particle(
                            oilPocket.x + (Math.random() - 0.5) * 60,
                            oilPocket.y + (Math.random() - 0.5) * 40,
                            'steam'
                        ));
                    }
                    
                    // ç”»é¢ã®å…‰ã‚‹åŠ¹æœ
                    canvas.style.filter = 'brightness(1.3) sepia(0.3)';
                    setTimeout(() => canvas.style.filter = '', 500);
                    
                    console.log(`ã‚ªã‚¤ãƒ«æ¡æ˜ï¼è€ä¹…åº¦ ${Math.floor(oldDurability)} â†’ ${Math.floor(game.drillDurability)} (+${Math.floor(oilPocket.healAmount)})`);
                }
            });
            
            // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
            game.oilMoney.forEach(oilMoney => {
                oilMoney.update();
                
                if (!oilMoney.collected &&
                    Math.abs(oilMoney.x - game.drillX) < (oilMoney.width/2 + 20) &&
                    Math.abs(oilMoney.y - game.drillY) < (oilMoney.height/2 + 30)) {
                    
                    oilMoney.collected = true;
                    
                    // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ã‚¹ãƒˆãƒƒã‚¯ã«è¿½åŠ 
                    game.oilMoneyStock += 1;
                    
                    // è±ªè¯ãªç²å¾—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 30; i++) {
                        game.particles.push(new Particle(
                            oilMoney.x + (Math.random() - 0.5) * 80,
                            oilMoney.y + (Math.random() - 0.5) * 60,
                            Math.random() < 0.5 ? 'spark' : 'steam'
                        ));
                    }
                    
                    // ç”»é¢ã®è±ªè¯ãªãƒ•ãƒ©ãƒƒã‚·ãƒ¥åŠ¹æœ
                    canvas.style.filter = 'brightness(1.5) saturate(1.5) hue-rotate(30deg)';
                    setTimeout(() => canvas.style.filter = '', 800);
                    
                    // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ç²å¾—éŸ³ã‚’å†ç”Ÿ
                    audioManager.playSound('oilMoney');
                    
                    console.log(`ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ç²å¾—ï¼ã‚¹ãƒˆãƒƒã‚¯æ•°: ${game.oilMoneyStock}`);
                }
            });

            // è’¸æ°—å­”ãƒœãƒ¼ãƒŠã‚¹
            game.steamVents.forEach(vent => {
                vent.update();
                const distance = Math.sqrt(
                    Math.pow(vent.x - game.drillX, 2) + 
                    Math.pow(vent.y - game.drillY, 2)
                );
                if (distance < 50) {
                    // è¿‘ãã«ã„ã‚‹ã¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¢—åŠ 
                    if (Math.random() < 0.3) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'steam'));
                    }
                }
            });
            
            // ãƒã‚°ãƒæºœã¾ã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆå…ˆç«¯ãƒ“ãƒƒãƒˆã®ã¿ï¼‰
            game.magmaPools.forEach(pool => {
                pool.update();
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ãƒ‰ãƒªãƒ«å…¨ä½“ã®æœ€ä¸‹ç«¯
                
                if (Math.abs(pool.x - bitTipX) < pool.width/2 &&
                    Math.abs(pool.y - bitTipY) < 30) {
                    game.drillDurability -= 0.5;
                    hitObstacle = true;
                    
                    if (Math.random() < 0.2) {
                        game.particles.push(new Particle(bitTipX, bitTipY, 'lava'));
                    }
                }
            });
            
            
            // ãƒ“ãƒ¼ãƒ æ›´æ–°
            game.beams.forEach(beam => beam.update());
            game.beams = game.beams.filter(beam => beam.life > 0);
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            game.particles.forEach(p => p.update());
            game.particles = game.particles.filter(p => p.life > 0);
            
            // ãƒ‰ãƒªãƒ«è€ä¹…åº¦ã®å›å¾©æ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–ï¼ˆã‚ˆã‚ŠæŒ‘æˆ¦çš„ãªã‚²ãƒ¼ãƒ ãƒãƒ©ãƒ³ã‚¹ï¼‰
            // if (!hitObstacle && game.drillDurability < game.drillMaxDurability) {
            //     game.drillDurability += 0.1; // å›å¾©é€Ÿåº¦ã‚’ä¸Šã’ã‚‹
            //     game.drillDurability = Math.min(game.drillDurability, game.drillMaxDurability);
            // }
            
            // æ˜å‰Šé€Ÿåº¦ã®è‡ªå‹•å¢—åŠ ï¼ˆç·©ã‚„ã‹ã«èª¿æ•´ï¼‰
            if (game.depth % 500 === 0 && game.depth > 0) {  // 500mã”ã¨ã«åŠ é€Ÿ
                game.drillSpeed += 0.15;  // ã‚ˆã‚Šç·©ã‚„ã‹ãªå¢—åŠ 
            }
            
            // 3000mä»¥é™ã•ã‚‰ã«åŠ é€Ÿï¼ˆã‚ˆã‚Šç·©ã‚„ã‹ï¼‰
            if (game.depth > 3000) {
                game.drillSpeed += 0.001 * (game.depth - 3000) / 200;  // åŠ é€Ÿåº¦ã‚’åŠåˆ†ã«
            }
            
            // æœ€å¤§é€Ÿåº¦åˆ¶é™ã‚’è¿½åŠ 
            game.drillSpeed = Math.min(game.drillSpeed, 8.0); // æœ€å¤§é€Ÿåº¦ã‚’8.0ã«åˆ¶é™
            
            // æ–­å±¤ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆå…ˆç«¯ãƒ“ãƒƒãƒˆã®ã¿ï¼‰
            game.faults.forEach(fault => {
                fault.update();
                
                // ãƒ“ãƒƒãƒˆå…ˆç«¯ä½ç½®ã¨ã‚µã‚¤ã‚º
                const bitTipX = game.drillX;
                const bitTipY = game.drillY + 110; // ãƒ‰ãƒªãƒ«å…¨ä½“ã®æœ€ä¸‹ç«¯
                const bitTipWidth = 50; // ãƒ“ãƒƒãƒˆå…ˆç«¯ã®å¹…
                const bitTipHeight = 30; // ãƒ“ãƒƒãƒˆå…ˆç«¯ã®é«˜ã•
                
                // äº€è£‚ã¨ã®è¡çªåˆ¤å®šï¼ˆå…ˆç«¯ãƒ“ãƒƒãƒˆã®ã¿ï¼‰
                if (fault.checkCrackCollision(bitTipX, bitTipY, bitTipWidth, bitTipHeight)) {
                    // äº€è£‚ã«ç›´æ¥è¡çªï¼šé‡ã„ãƒ€ãƒ¡ãƒ¼ã‚¸
                    game.drillDurability -= 3;
                    hitObstacle = true;
                    
                    // è¡çªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 10; i++) {
                        game.particles.push(new Particle(game.drillX, game.drillY, 'spark'));
                    }
                    
                    // ç”»é¢æºã‚Œ
                    canvas.style.transform = `translate(${Math.random() * 15 - 7.5}px, ${Math.random() * 15 - 7.5}px)`;
                    setTimeout(() => canvas.style.transform = '', 120);
                }
            });
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
            if (game.drillDurability <= 0) {
                gameOver();
            }
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆç”»é¢å¤–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ï¼‰
            game.rocks = game.rocks.filter(rock => rock.y > game.cameraY - 200);
            game.steamVents = game.steamVents.filter(vent => vent.y > game.cameraY - 200);
            game.magmaPools = game.magmaPools.filter(pool => pool.y > game.cameraY - 200);
            game.faults = game.faults.filter(fault => fault.y > game.cameraY - 200);
            game.oilPockets = game.oilPockets.filter(oilPocket => oilPocket.y > game.cameraY - 200);
            game.moles = game.moles.filter(mole => mole.y > game.cameraY - 200 && mole.y < game.cameraY + canvas.height + 200);
            game.pipeSegments = game.pipeSegments.filter(segment => segment.y > game.cameraY - 100);
            
            updateUI();
        }
        
        function drawGame() {
            // --- START OF NEW BACKGROUND LOGIC ---

            // 1. Define colors for different geological layers
            const layers = [
                { depth: 0,    colors: ['#87CEEB', '#A0522D'] }, // Surface: Sky to Soil
                { depth: 500,  colors: ['#A0522D', '#8B4513'] }, // Soil to Sediment
                { depth: 1500, colors: ['#696969', '#505050'] }, // Sedimentary/Metamorphic Rock (Greys)
                { depth: 3000, colors: ['#3E2723', '#2E1F1A'] }, // Igneous Rock (Dark Browns)
                { depth: 5000, colors: ['#2E1F1A', '#8B0000'] }, // Close to Mantle (Dark Red)
                { depth: 7000, colors: ['#8B0000', '#FF4500'] }  // Magma (Red to Orange)
            ];

            // 2. Determine the current and next layer based on depth
            let currentLayer = layers[0];
            let nextLayer = layers[1];
            for (let i = 0; i < layers.length - 1; i++) {
                if (game.depth >= layers[i].depth) {
                    currentLayer = layers[i];
                    nextLayer = layers[i+1];
                }
            }
            
            // 3. Calculate the transition progress between the two layers
            const layerDepthSpan = nextLayer.depth - currentLayer.depth;
            const progressInLayer = (game.depth - currentLayer.depth) / layerDepthSpan;
            
            // 4. Interpolate colors based on progress
            const r1 = parseInt(currentLayer.colors[0].slice(1, 3), 16);
            const g1 = parseInt(currentLayer.colors[0].slice(3, 5), 16);
            const b1 = parseInt(currentLayer.colors[0].slice(5, 7), 16);
            
            const r2 = parseInt(nextLayer.colors[0].slice(1, 3), 16);
            const g2 = parseInt(nextLayer.colors[0].slice(3, 5), 16);
            const b2 = parseInt(nextLayer.colors[0].slice(5, 7), 16);

            const r3 = parseInt(currentLayer.colors[1].slice(1, 3), 16);
            const g3 = parseInt(currentLayer.colors[1].slice(3, 5), 16);
            const b3 = parseInt(currentLayer.colors[1].slice(5, 7), 16);

            const r4 = parseInt(nextLayer.colors[1].slice(1, 3), 16);
            const g4 = parseInt(nextLayer.colors[1].slice(3, 5), 16);
            const b4 = parseInt(nextLayer.colors[1].slice(5, 7), 16);

            const topR = Math.round(r1 + (r2 - r1) * progressInLayer);
            const topG = Math.round(g1 + (g2 - g1) * progressInLayer);
            const topB = Math.round(b1 + (b2 - b1) * progressInLayer);

            const bottomR = Math.round(r3 + (r4 - r3) * progressInLayer);
            const bottomG = Math.round(g3 + (g4 - g3) * progressInLayer);
            const bottomB = Math.round(b3 + (b4 - b3) * progressInLayer);

            const topColor = `rgb(${topR}, ${topG}, ${topB})`;
            const bottomColor = `rgb(${bottomR}, ${bottomG}, ${bottomB})`;

            // 5. Create and apply the gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, topColor);
            gradient.addColorStop(1, bottomColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 6. Add procedural strata patterns based on depth
            ctx.save();
            for (let d = Math.floor(game.cameraY / 50) * 50; d < game.cameraY + canvas.height + 50; d += 50) {
                const y = d - game.cameraY;
                const currentDepthInMeters = d / 10;

                if (y > 0 && y < canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);

                    if (currentDepthInMeters < 1500) {
                        // Sedimentary layers: relatively straight lines
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.lineWidth = Math.random() * 2 + 1;
                        ctx.lineTo(canvas.width, y + (Math.random() - 0.5) * 5);
                    } else if (currentDepthInMeters < 3000) {
                        // Metamorphic layers: wavy, distorted lines
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                        ctx.lineWidth = Math.random() * 2.5 + 1;
                        ctx.quadraticCurveTo(
                            canvas.width / 2 + Math.sin(d / 100) * 50,
                            y + (Math.random() - 0.5) * 15,
                            canvas.width, 
                            y + (Math.random() - 0.5) * 10
                        );
                    } else {
                        // Igneous/Deeper layers: sharp, crystalline patterns
                        ctx.strokeStyle = 'rgba(255, 220, 180, 0.1)';
                        ctx.lineWidth = Math.random() * 1.5 + 0.5;
                        ctx.moveTo(Math.random() * 50, y);
                        for(let x = 50; x < canvas.width; x += Math.random() * 100 + 50) {
                            ctx.lineTo(x, y + (Math.random() - 0.5) * 25);
                        }
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();

            // 7. Add heat/magma effect for deep sections
            if (game.depth > 3000) {
                const heatIntensity = Math.min((game.depth - 3000) / 4000, 0.4);
                ctx.fillStyle = `rgba(255, 69, 0, ${heatIntensity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Glowing cracks for very deep sections
                if (game.depth > 5000) {
                    ctx.save();
                    const crackCount = Math.min(10, Math.floor((game.depth - 5000) / 200));
                    ctx.globalAlpha = Math.min((game.depth - 5000) / 3000, 0.7);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = Math.random() * 2 + 1;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FF4500';
                    for (let i = 0; i < crackCount; i++) {
                        const y = Math.random() * canvas.height;
                        const x_start = Math.random() * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(x_start, y);
                        ctx.bezierCurveTo(
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 200, y + (Math.random() - 0.5) * 100,
                            x_start + (Math.random() - 0.5) * 400, y + (Math.random() - 0.5) * 200
                        );
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            // --- END OF NEW BACKGROUND LOGIC ---

            // --- START BOREHOLE DRAWING ---
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Dark, semi-transparent for the tunnel
            ctx.lineWidth = 50; // Width of the borehole, wider than the drill
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            let firstVisibleSegment = true;
            game.pipeSegments.forEach(segment => {
                const screenY = segment.y - game.cameraY;
                // Only draw segments visible on screen
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisibleSegment) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisibleSegment = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });

            // Extend the tunnel to the current drill position
            if (game.pipeSegments.length > 0 && !firstVisibleSegment) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }

            ctx.stroke();
            ctx.restore();
            // --- END BOREHOLE DRAWING ---
            
            // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®æç”»
            ctx.save();
            ctx.strokeStyle = '#708090';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // ãƒ‘ã‚¤ãƒ—ã®æœ¬ä½“
            ctx.beginPath();
            let firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x, screenY);
                    }
                }
            });
            
            // æœ€å¾Œã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‹ã‚‰æ˜å‰Šæ©Ÿã¾ã§
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX, drillScreenY);
            }
            
            ctx.stroke();
            
            // ãƒ‘ã‚¤ãƒ—ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.strokeStyle = '#A9A9A9';
            ctx.lineWidth = 10;
            ctx.beginPath();
            firstVisible = true;
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50) {
                    if (firstVisible) {
                        ctx.moveTo(segment.x - 5, screenY);
                        firstVisible = false;
                    } else {
                        ctx.lineTo(segment.x - 5, screenY);
                    }
                }
            });
            
            if (game.pipeSegments.length > 0 && !firstVisible) {
                const drillScreenY = game.drillY - game.cameraY;
                ctx.lineTo(game.drillX - 5, drillScreenY);
            }
            
            ctx.stroke();
            
            // ãƒ‘ã‚¤ãƒ—ã®ç¶™ãç›®
            ctx.fillStyle = '#606060';
            game.pipeSegments.forEach((segment, index) => {
                const screenY = segment.y - game.cameraY;
                if (screenY > -50 && screenY < canvas.height + 50 && index % 50 === 0) {
                    ctx.beginPath();
                    ctx.arc(segment.x, screenY, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç¶™ãç›®ã®ãƒœãƒ«ãƒˆ
                    ctx.fillStyle = '#404040';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 / 4) * i;
                        const boltX = segment.x + Math.cos(angle) * 10;
                        const boltY = screenY + Math.sin(angle) * 10;
                        ctx.beginPath();
                        ctx.arc(boltX, boltY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#606060';
                }
            });
            
            ctx.restore();
            
            // ã‚‚ãã‚‰
            game.moles.forEach(mole => mole.draw());
            
            // æ–­å±¤
            game.faults.forEach(fault => fault.draw());
            
            // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆ
            game.oilPockets.forEach(oilPocket => oilPocket.draw());
            
            // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼
            game.oilMoney.forEach(oilMoney => {
                if (!oilMoney.collected) {
                    oilMoney.draw();
                }
            });
            
            // ãƒã‚°ãƒæºœã¾ã‚Š
            game.magmaPools.forEach(pool => pool.draw());
            
            // å²©
            game.rocks.forEach(rock => rock.draw());
            
            // è’¸æ°—å­”
            game.steamVents.forEach(vent => vent.draw());
            
            // ãƒ“ãƒ¼ãƒ 
            game.beams.forEach(beam => beam.draw());
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            game.particles.forEach(p => p.draw());
            
            // æ˜å‰Šæ©Ÿ
            const drillScreenY = game.drillY - game.cameraY;
            ctx.save();
            ctx.translate(game.drillX, drillScreenY);

            // ãƒ‰ãƒªãƒ«ã®å‚¾ãã‚’é©ç”¨
            let tiltAngle = 0;
            const maxTilt = Math.PI / 16; // å‚¾ãã®æœ€å¤§è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
            if (keys['ArrowLeft']) {
                tiltAngle = maxTilt; // å·¦ã‚­ãƒ¼ã§å³ã«å‚¾ã‘ã‚‹
            } else if (keys['ArrowRight']) {
                tiltAngle = -maxTilt; // å³ã‚­ãƒ¼ã§å·¦ã«å‚¾ã‘ã‚‹
            }
            ctx.rotate(tiltAngle);
            
            // PDCãƒ‰ãƒªãƒ«ãƒ“ãƒƒãƒˆï¼ˆå®Ÿéš›ã®ç”»åƒã‚’ä½¿ç”¨ã€å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰- ãƒ‰ãƒªãƒ«æœ¬ä½“ã®å¾Œã‚ã«é…ç½®
            ctx.save();
            ctx.translate(0, 70); // ãƒ‰ãƒªãƒ«æœ¬ä½“ã‹ã‚‰å°‘ã—ä¸‹ã«é…ç½®ï¼ˆ50ã‹ã‚‰70ã«å¤‰æ›´ï¼‰
            
            // ç”»åƒã‚’90åº¦å›è»¢ã•ã›ã¦ã€ã•ã‚‰ã«ä¸Šä¸‹ã«180åº¦å›è»¢ã€æœ€å¾Œã«30åº¦å›è»¢ã•ã›ã¦æ­£ã—ã„å‘ãã«ã™ã‚‹
            ctx.rotate(Math.PI / 2); // 90åº¦å›è»¢
            ctx.rotate(Math.PI); // ä¸Šä¸‹ã«180åº¦å›è»¢
            ctx.rotate(Math.PI / 6); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 8); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 8); // ã•ã‚‰ã«30åº¦å›è»¢
            ctx.rotate(Math.PI / 9); // ã•ã‚‰ã«30åº¦å›è»¢
             
        
        
           
            
            if (imageLoaded) {
                // ç”»åƒã®ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚ºã«ï¼‰
                const bitWidth = 100; // 60ã‹ã‚‰100ã«æ‹¡å¤§
                const bitHeight = 120; // 80ã‹ã‚‰120ã«æ‹¡å¤§
                
                // é«˜æ¸©æ™‚ã®åŠ¹æœ
                if (game.temperature > 500) {
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = game.temperature > 800 ? '#FF4500' : '#FFD700';
                }
                
                // é«˜æ¸©æ™‚ã®è‰²èª¿å¤‰æ›´
                if (game.temperature > 800) {
                    ctx.filter = 'hue-rotate(30deg) saturate(1.5) brightness(1.2)';
                } else if (game.temperature > 500) {
                    ctx.filter = 'saturate(1.2) brightness(1.1)';
                } else {
                    ctx.filter = 'none';
                }
                
                // PDCãƒ“ãƒƒãƒˆç”»åƒã‚’æç”»ï¼ˆ90åº¦å›è»¢å¾Œã®ä½ç½®èª¿æ•´ï¼‰
                ctx.drawImage(
                    drillBitImage, 
                    -bitWidth / 2, 
                    -bitHeight / 2, // ä¸­å¤®ã«é…ç½®
                    bitWidth, 
                    bitHeight
                );
                
                // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
                ctx.filter = 'none';
                
                // é«˜æ¸©æ™‚ã®è¿½åŠ åŠ¹æœï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰
                if (game.temperature > 800) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#FF4500';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bitWidth/2 + 8, bitHeight/2 + 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            } else {
                // ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§ã®ä»£æ›¿è¡¨ç¤º
                ctx.fillStyle = '#CD853F';
                ctx.fillRect(-40, -50, 80, 100); // ã‚ˆã‚Šå¤§ããªã‚µã‚¤ã‚º
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', 0, 0);
            }
            
            ctx.restore();
            
            // ãƒ‰ãƒªãƒ«æœ¬ä½“ï¼ˆPDCãƒ“ãƒƒãƒˆã®ä¸Šã«æç”»ï¼‰
            const gradient2 = ctx.createLinearGradient(-20, -30, 20, 30);
            gradient2.addColorStop(0, '#E0E0E0');
            gradient2.addColorStop(1, '#808080');
            ctx.fillStyle = gradient2;
            ctx.fillRect(-25, -40, 50, 80);
            
            // æ’æ°—
            ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
            for (let i = 0; i < 3; i++) {
                const offsetX = (Math.random() - 0.5) * 30;
                const offsetY = -50 - i * 10;
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, 5 + i * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // æ·±åº¦ãƒãƒ¼ã‚«ãƒ¼
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = 'bold 14px Arial';
            for (let d = Math.floor(game.cameraY / 100) * 100; d <= game.cameraY + canvas.height + 100; d += 100) {
                const y = d - game.cameraY;
                if (y > 0 && y < canvas.height) {
                    ctx.fillText(`${Math.floor(d / 10)}m`, 10, y);
                    ctx.fillRect(0, y, 40, 2);
                }
            }
            
            // ç”»é¢ç«¯ã®è­¦å‘Š
            if (game.drillX < 100 || game.drillX > canvas.width - 100) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                if (game.drillX < 100) {
                    ctx.fillRect(0, 0, 50, canvas.height);
                } else {
                    ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);
                }
            }
        }
        
        // æ·±åº¦ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿
        const depthBenchmarks = [
            { depth: 100, name: "ğŸ¢ 10éšå»ºã¦ãƒ“ãƒ«", description: "ä¸€èˆ¬çš„ãªã‚ªãƒ•ã‚£ã‚¹ãƒ“ãƒ«ã®é«˜ã•" },
            { depth: 143, name: "ğŸ—¼ ã‚»ãƒªã‚ªãƒ³", description: "ç§‹ç”°çœŒã§æœ€ã‚‚é«˜ã„ã‚¿ãƒ¯ãƒ¼" },
            { depth: 333, name: "ğŸ—¼ æ±äº¬ã‚¿ãƒ¯ãƒ¼", description: "é€†ã•ã¾ã«ã—ãŸæ±äº¬ã‚¿ãƒ¯ãƒ¼ã®é«˜ã•" },
            { depth: 450, name: "ğŸ¢ ã‚¨ãƒ³ãƒ‘ã‚¤ã‚¢ã‚¹ãƒ†ãƒ¼ãƒˆãƒ“ãƒ«", description: "ãƒ‹ãƒ¥ãƒ¼ãƒ¨ãƒ¼ã‚¯ã®è±¡å¾´çš„ãªé«˜å±¤ãƒ“ãƒ«" },
            { depth: 634, name: "ğŸ—¼ æ±äº¬ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼", description: "æ—¥æœ¬æœ€é«˜ã®é›»æ³¢å¡”" },
            { depth: 828, name: "ğŸ¢ ãƒ–ãƒ«ã‚¸ãƒ¥ãƒ»ãƒãƒªãƒ•ã‚¡", description: "ä¸–ç•Œä¸€é«˜ã„è¶…é«˜å±¤ãƒ“ãƒ«" },
            { depth: 1000, name: "ğŸš‡ åœ°ä¸‹é‰„é“ã®æ·±ã„é§…", description: "éƒ½å¸‚éƒ¨ã®æ·±ã„åœ°ä¸‹é§…ãƒ¬ãƒ™ãƒ«" },
            { depth: 1642, name: "ğŸ”ï¸ ãƒ„ã‚¤ãƒ³ã‚¿ãƒ¯ãƒ¼ã‚º", description: "ãƒãƒ¬ãƒ¼ã‚·ã‚¢ã®è±¡å¾´çš„ãªè¶…é«˜å±¤ãƒ“ãƒ«" },
            { depth: 2000, name: "â›°ï¸ å¯Œå£«å±±ã®åŠåˆ†", description: "æ—¥æœ¬æœ€é«˜å³°ã®ç´„åŠåˆ†ã®é«˜ã•" },
            { depth: 3000, name: "ğŸ„ æ·±æµ·ç”¨æ½œæ°´è‰¦", description: "æ·±æµ·æ¢æŸ»ç”¨æ½œæ°´è‰¦ã®åˆ°é”æ·±åº¦" },
            { depth: 4000, name: "ğŸŒŠ å¤ªå¹³æ´‹ã®å¹³å‡æ·±åº¦", description: "ä¸–ç•Œã®æµ·ã®å¹³å‡æ·±åº¦" },
            { depth: 5000, name: "ğŸ•³ï¸ ã‚½ãƒ“ã‚¨ãƒˆã®ã‚³ãƒ©åŠå³¶æœ€æ·±éƒ¨", description: "äººé¡æœ€æ·±ã®ç§‘å­¦æ˜å‰Šãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé–‹å§‹" },
            { depth: 6000, name: "ğŸŒ‹ åœ°æ®»ä¸‹éƒ¨", description: "å¤§é™¸åœ°æ®»ã®ä¸‹éƒ¨é ˜åŸŸ" },
            { depth: 7000, name: "ğŸŒŠ æ—¥æœ¬æµ·æºã®æ·±ã„éƒ¨åˆ†", description: "æ—¥æœ¬è¿‘æµ·ã®æ·±æµ·æº" },
            { depth: 8000, name: "ğŸ”ï¸ ã‚¨ãƒ™ãƒ¬ã‚¹ãƒˆå±±é ‚", description: "ä¸–ç•Œæœ€é«˜å³°ã®é«˜ã•" },
            { depth: 9000, name: "ğŸŒŠ æµ·æ´‹æ·±å±¤", description: "æ·±æµ·ã®æœ¬æ ¼çš„ãªé ˜åŸŸ" },
            { depth: 10000, name: "ğŸŒŠ ãƒãƒªã‚¢ãƒŠæµ·æºä»˜è¿‘", description: "ä¸–ç•Œæœ€æ·±ã®æµ·æºã«è¿‘ã¥ã" },
            { depth: 11000, name: "ğŸŒŠ ãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ£ãƒ¼æ·±æ·µ", description: "åœ°çƒä¸Šæœ€æ·±ã®å ´æ‰€" },
            { depth: 12262, name: "ğŸ•³ï¸ ã‚³ãƒ©åŠå³¶è¶…æ·±åº¦æ˜å‰Š", description: "ã‚½ãƒ“ã‚¨ãƒˆã®äººé¡æœ€æ·±æ˜å‰Šè¨˜éŒ²" },
            { depth: 15000, name: "ğŸŒ‹ åœ°æ®»ãƒ»ãƒãƒ³ãƒˆãƒ«å¢ƒç•Œä»˜è¿‘", description: "åœ°çƒå†…éƒ¨æ§‹é€ ã®å¢ƒç•Œé ˜åŸŸ" },
            { depth: 18000, name: "ğŸŒ ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®ç›´ç·šè·é›¢", description: "ç§‹ç”°ã‹ã‚‰ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®ç›´ç·šè·é›¢" }
        ];

        function showBenchmarkNotification(benchmark) {
            // ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é€šçŸ¥ã‚’è¡¨ç¤º
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                color: #FFD700;
                padding: 20px;
                border-radius: 15px;
                border: 3px solid #FF4500;
                text-align: center;
                z-index: 2000;
                box-shadow: 0 0 30px rgba(255, 69, 0, 0.8);
                animation: fadeInOut 4s ease-in-out;
                max-width: 80%;
                font-size: 16px;
            `;
            
            notification.innerHTML = `
                <h3 style="margin: 0 0 10px 0; color: #FF4500; font-size: 20px;">ğŸ‰ æ·±åº¦ ${benchmark.depth}m é”æˆï¼</h3>
                <div style="font-size: 18px; margin: 10px 0; color: #FFD700;">${benchmark.name}</div>
                <div style="font-size: 14px; color: #87CEEB;">${benchmark.description}</div>
            `;
            
            // CSSã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
            if (!document.getElementById('benchmarkAnimationStyle')) {
                const style = document.createElement('style');
                style.id = 'benchmarkAnimationStyle';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // 4ç§’å¾Œã«é™¤å»
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 4000);
        }

        function updateUI() {
            document.getElementById('depth').textContent = game.depth;
            document.getElementById('temperature').textContent = Math.floor(game.temperature);
            document.getElementById('drillSpeed').textContent = game.drillSpeed.toFixed(1);
            document.getElementById('drillEnergy').style.width = `${Math.max(0, (game.drillDurability / game.drillMaxDurability) * 100)}%`;
            
            // ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
            const currentBenchmark = depthBenchmarks.find(b => 
                game.depth >= b.depth && game.lastBenchmarkDepth < b.depth
            );
            
            if (currentBenchmark) {
                showBenchmarkNotification(currentBenchmark);
                game.lastBenchmarkDepth = currentBenchmark.depth;
            }
            
            // è€ä¹…åº¦ã«ã‚ˆã‚‹è‰²å¤‰æ›´
            const durabilityRatio = game.drillDurability / game.drillMaxDurability;
            if (durabilityRatio < 0.3) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #8B0000, #FF0000)';
            } else if (durabilityRatio < 0.6) {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF8C00, #FFD700)';
            } else {
                document.getElementById('drillEnergy').style.background = 'linear-gradient(to right, #FF4500, #FFD700)';
            }
            
            // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ã‚¹ãƒˆãƒƒã‚¯æ•°ã¨ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ã®è¡¨ç¤º
            document.getElementById('oilMoneyCount').textContent = game.oilMoneyStock;
            
            // ã‚³ãƒ³ãƒœæ•°ã®è¡¨ç¤º
            document.getElementById('comboCount').textContent = game.comboCount;
            
            // ä»Šå›ã®ãƒ—ãƒ¬ã‚¤è·é›¢è¡¨ç¤º
            document.getElementById('currentPlayDistance').textContent = Math.floor(game.maxDepth);
            
            // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ã®è¡¨ç¤ºæ›´æ–°
            if (game.starMode) {
                document.getElementById('beamStatus').textContent = `â­ ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ â­ (${Math.ceil(game.starModeTimer)}ç§’)`;
                document.getElementById('beamStatus').style.color = '#FFD700';
                document.getElementById('beamEnergy').style.width = `${(game.starModeTimer / game.starModeDuration) * 100}%`;
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #FFD700, #FFA500)';
            } else if (game.oilMoneyStock > 0) {
                document.getElementById('beamStatus').textContent = 'ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹ï¼';
                document.getElementById('beamStatus').style.color = '#90EE90';
                document.getElementById('beamEnergy').style.width = '100%';
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #32CD32, #90EE90)';
            } else {
                document.getElementById('beamStatus').textContent = 'ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼ã‚’é›†ã‚ã‚ˆã†ï¼';
                document.getElementById('beamStatus').style.color = '#FFFFFF';
                document.getElementById('beamEnergy').style.width = '0%';
                document.getElementById('beamEnergy').style.background = 'linear-gradient(to right, #654321, #8B4513)';
            }
        }
        
        function gameLoop() {
            if (!game.gameRunning) return;
            
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }
        
        
        async function gameOver(reason = null) {
            game.gameRunning = false;
            document.getElementById('finalDepth').textContent = game.maxDepth;
            document.getElementById('maxTemp').textContent = Math.floor(game.maxTemp);
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ç†ç”±ã‚’è¡¨ç¤º
            const gameOverDiv = document.getElementById('gameOver');
            const h2 = gameOverDiv.querySelector('h2');
            if (reason) {
                h2.textContent = reason;
            } else {
                h2.textContent = 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';
            }
            
            // ã‚¹ã‚³ã‚¢è¨ˆç®—
            const score = Math.floor(game.maxDepth * 10 + game.maxTemp * 5 + game.oilMoneyStock * 100 + game.comboCount * 50);
            
            // ä¸Šä½5ä½ã«å…¥ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const isTopRecord = await recordManager.checkIfTopRecord(game.maxDepth);
            
            // åå‰å…¥åŠ›ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºåˆ¶å¾¡
            const playerNameSection = document.getElementById('playerNameSection');
            if (isTopRecord) {
                playerNameSection.style.display = 'block';
                const saveMessage = document.createElement('div');
                saveMessage.textContent = 'ğŸ‰ ä¸Šä½5ä½ã«å…¥ã‚Šã¾ã—ãŸï¼åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                saveMessage.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    background: rgba(255, 215, 0, 0.9);
                    color: black;
                    padding: 10px;
                    border-radius: 5px;
                    font-size: 14px;
                    font-weight: bold;
                `;
                gameOverDiv.appendChild(saveMessage);
                
                setTimeout(() => {
                    if (saveMessage.parentNode) {
                        saveMessage.parentNode.removeChild(saveMessage);
                    }
                }, 5000);
            } else {
                playerNameSection.style.display = 'none';
            }
            
            // è¨˜éŒ²ã‚’ä¿å­˜
            try {
                await recordManager.saveRecord({
                    depth: game.maxDepth,
                    temperature: game.maxTemp,
                    oilMoneyStock: game.oilMoneyStock,
                    comboCount: game.comboCount,
                    score: score
                });
                
                // ä¿å­˜å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                if (!isTopRecord) {
                    const saveMessage = document.createElement('div');
                    saveMessage.textContent = 'è¨˜éŒ²ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼';
                    saveMessage.style.cssText = `
                        position: absolute;
                        top: 20px;
                        right: 20px;
                        background: rgba(0, 255, 0, 0.8);
                        color: white;
                        padding: 10px;
                        border-radius: 5px;
                        font-size: 14px;
                    `;
                    gameOverDiv.appendChild(saveMessage);
                    
                    setTimeout(() => {
                        if (saveMessage.parentNode) {
                            saveMessage.parentNode.removeChild(saveMessage);
                        }
                    }, 3000);
                }
                
            } catch (error) {
                console.error('è¨˜éŒ²ä¿å­˜ã«å¤±æ•—:', error);
                const errorMessage = document.createElement('div');
                errorMessage.textContent = 'è¨˜éŒ²ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ';
                errorMessage.style.cssText = `
                    position: absolute;
                    top: 20px;
                    right: 20px;
                    background: rgba(255, 0, 0, 0.8);
                    color: white;
                    padding: 10px;
                    border-radius: 5px;
                    font-size: 14px;
                `;
                gameOverDiv.appendChild(errorMessage);
                
                setTimeout(() => {
                    if (errorMessage.parentNode) {
                        errorMessage.parentNode.removeChild(errorMessage);
                    }
                }, 3000);
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        function resetGame() {
            // æ—¢å­˜ã®ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ã«åœæ­¢
            game.gameRunning = false;
            
            // æ—¢å­˜ã®éŸ³æ¥½ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
            if (audioManager.musicLoop) {
                audioManager.stopBackgroundMusic();
            }
            if (game.starMode) {
                audioManager.stopStarModeBGM();
            }
            
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ï¼ˆæ—¢å­˜ã®ãƒ«ãƒ¼ãƒ—ã‚’ç¢ºå®Ÿã«åœæ­¢ï¼‰
            setTimeout(() => {
                // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
                game = {
                    depth: 0,
                    energy: 0,
                    temperature: 15,
                    drillX: 600,
                    drillY: 0,
                    drillSpeed: 4.0, // åˆæœŸé€Ÿåº¦ã‚’4.0å€ã«å¢—åŠ 
                    drillDurability: 100,
                    drillMaxDurability: 100,
                    oilMoneyStock: 0,
                    starMode: false,
                    starModeTimer: 0,
                    starModeDuration: 5,
                    lastBenchmarkDepth: 0,
                    comboCount: 0,
                    comboTimer: 0,
                    comboMaxTime: 3,
                    cooling: 1,
                    particles: [],
                    rocks: [],
                    steamVents: [],
                    magmaPools: [],
                    faults: [], // æ–­å±¤
                    oilPockets: [], // ã‚ªã‚¤ãƒ«ãƒã‚±ãƒƒãƒˆ
                    oilMoney: [], // ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼
                    beams: [], // ãƒ“ãƒ¼ãƒ 
                    moles: [], // ã‚‚ãã‚‰
                    pipeSegments: [], // ãƒ‰ãƒªãƒ«ãƒ‘ã‚¤ãƒ—ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
                    maxDepth: 0,
                    maxTemp: 15,
                    gameRunning: true,
                    cameraY: 0,
                    generatedSpawns: new Set(),
                    upgrades: {
                        speed: { level: 1, cost: 10 },
                        durability: { level: 1, cost: 15 },
                        cooling: { level: 1, cost: 20 }
                    }
                };
                
                // UIè¦ç´ ã‚’éš ã™
                document.getElementById('gameOver').style.display = 'none';
                
                // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‚‰éš ã™
                const recordsList = document.getElementById('recordsList');
                if (recordsList) {
                    recordsList.style.display = 'none';
                }
                
                // æ–°ã—ã„BGMã‚’é–‹å§‹
                if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
                    audioManager.audioContext.resume();
                }
                audioManager.startBackgroundMusic();
                
                // UIã‚’æ›´æ–°
                updateUI();
                
                // æ–°ã—ã„ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹
                gameLoop();
            }, 50);
        }
        
        // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰æ©Ÿèƒ½ã¯ç¾åœ¨UIã«ãªã„ãŸã‚ã€ä¸€æ—¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¾ã™ã€‚
        /*
        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (game.energy >= game.upgrades.speed.cost) {
                game.energy -= game.upgrades.speed.cost;
                game.drillSpeed += 0.8;  // 0.3 â†’ 0.8ã«å¢—åŠ 
                game.upgrades.speed.level++;
                game.upgrades.speed.cost = Math.floor(game.upgrades.speed.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeDurability').addEventListener('click', () => {
            if (game.energy >= game.upgrades.durability.cost) {
                game.energy -= game.upgrades.durability.cost;
                game.drillMaxDurability += 50;
                game.drillDurability += 50;
                game.upgrades.durability.level++;
                game.upgrades.durability.cost = Math.floor(game.upgrades.durability.cost * 1.8);
                updateUI();
            }
        });
        
        document.getElementById('upgradeCooling').addEventListener('click', () => {
            if (game.energy >= game.upgrades.cooling.cost) {
                game.energy -= game.upgrades.cooling.cost;
                game.cooling += 0.5;
                game.upgrades.cooling.level++;
                game.upgrades.cooling.cost = Math.floor(game.upgrades.cooling.cost * 2);
                updateUI();
            }
        });
        */
        
        // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹/ãƒ“ãƒ¼ãƒ ç™ºå°„é–¢æ•°
        function handleSpaceKey() {
            if (!game.gameRunning) return;
            
            if (game.starMode) {
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ä¸­ï¼šãƒ“ãƒ¼ãƒ ç™ºå°„
                const beam = new Beam(game.drillX, game.drillY + 60, Math.PI / 2);
                game.beams.push(beam);
                
                // æ³¥æ°´ç™ºå°„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 15; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 25,
                        game.drillY + 50 + (Math.random() - 0.5) * 25,
                        Math.random() < 0.7 ? 'rock' : 'steam'
                    ));
                }
                
                // ç”»é¢åŠ¹æœ
                canvas.style.filter = 'brightness(1.3) sepia(0.5) saturate(1.5)';
                setTimeout(() => canvas.style.filter = '', 150);
                
                // ãƒ“ãƒ¼ãƒ ç™ºå°„éŸ³ã‚’å†ç”Ÿ
                audioManager.playSound('beam');
                
                console.log('â­ ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹ãƒ“ãƒ¼ãƒ ç™ºå°„ï¼');
            } else if (game.oilMoneyStock > 0) {
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹
                game.starMode = true;
                game.starModeTimer = game.starModeDuration;
                game.oilMoneyStock -= 1;
                
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                for (let i = 0; i < 50; i++) {
                    game.particles.push(new Particle(
                        game.drillX + (Math.random() - 0.5) * 100,
                        game.drillY + (Math.random() - 0.5) * 100,
                        'spark'
                    ));
                }
                
                // è±ªè¯ãªç”»é¢åŠ¹æœ
                canvas.style.filter = 'brightness(1.8) saturate(2) hue-rotate(45deg)';
                setTimeout(() => canvas.style.filter = '', 1000);
                
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹éŸ³ã‚’å†ç”Ÿ
                audioManager.playSound('starMode');
                
                // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹å°‚ç”¨BGMã‚’é–‹å§‹
                audioManager.startStarModeBGM();
                
                console.log('â­ ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹ï¼ 5ç§’é–“ç„¡åˆ¶é™ãƒ“ãƒ¼ãƒ ï¼');
            }
        }

        // ã‚­ãƒ¼å…¥åŠ›
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            
            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹é–‹å§‹/ãƒ“ãƒ¼ãƒ ç™ºå°„
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                handleSpaceKey();
            }
            
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
            }
            keys[e.key] = false;
        });
        
        // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œ
        let touchStartX = null;
        let touchStartTime = null;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartTime = Date.now();
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (touchStartX !== null) {
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                
                if (diff < -30) {
                    keys['ArrowLeft'] = true;
                    keys['ArrowRight'] = false;
                } else if (diff > 30) {
                    keys['ArrowRight'] = true;
                    keys['ArrowLeft'] = false;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }
            }
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', (e) => {
            // ã‚¿ãƒƒãƒ—åˆ¤å®šï¼ˆçŸ­æ™‚é–“ã§ç§»å‹•è·é›¢ãŒå°‘ãªã„å ´åˆï¼‰
            if (touchStartX !== null && touchStartTime !== null) {
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                const touchEndX = e.changedTouches[0].clientX;
                const touchDistance = Math.abs(touchEndX - touchStartX);
                
                // ã‚¿ãƒƒãƒ—åˆ¤å®š: 300msä»¥ä¸‹ã‹ã¤ç§»å‹•è·é›¢30pxä»¥ä¸‹
                if (touchDuration < 300 && touchDistance < 30 && game.gameRunning) {
                    handleSpaceKey();
                }
            }
            
            touchStartX = null;
            touchStartTime = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        });
        
        // ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const spaceButton = document.getElementById('spaceButton');
        
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });
        
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });
        
        // ã‚¹ãƒšãƒ¼ã‚¹ãƒœã‚¿ãƒ³ï¼ˆæ³¥æ°´ãƒ“ãƒ¼ãƒ ï¼‰
        spaceButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleSpaceKey();
        });
        
        spaceButton.addEventListener('click', (e) => {
            e.preventDefault();
            handleSpaceKey();
        });
        
        // ãƒã‚¦ã‚¹ã§ã‚‚å‹•ä½œã™ã‚‹ã‚ˆã†ã«
        leftButton.addEventListener('mousedown', () => keys['ArrowLeft'] = true);
        leftButton.addEventListener('mouseup', () => keys['ArrowLeft'] = false);
        rightButton.addEventListener('mousedown', () => keys['ArrowRight'] = true);
        rightButton.addEventListener('mouseup', () => keys['ArrowRight'] = false);
        
        // éŸ³å£°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        document.getElementById('muteButton').addEventListener('click', () => {
            audioManager.toggleMute();
            const button = document.getElementById('muteButton');
            button.textContent = audioManager.muted ? 'ğŸ”‡ éŸ³å£°OFF' : 'ğŸ”Š éŸ³å£°ON';
        });
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ãƒªã‚µã‚¤ã‚º
        async function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game.gameRunning = true;
            
            // AudioContextã‚’é–‹å§‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³å¾Œã«å¿…è¦ï¼‰
            if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
                audioManager.audioContext.resume();
            }
            
            // ç·æ˜å‰Šè·é›¢ã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤º
            try {
                const totalDistance = await recordManager.getTotalDistance();
                document.getElementById('totalDistance').textContent = totalDistance.toLocaleString();
            } catch (error) {
                console.error('ç·æ˜å‰Šè·é›¢ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                document.getElementById('totalDistance').textContent = '0';
            }
            
            // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯é–‹å§‹
            audioManager.startBackgroundMusic();
            
            resizeGame(); // ãƒªã‚µã‚¤ã‚ºã‚’å®Ÿè¡Œ
            gameLoop();
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åæ›´æ–°æ©Ÿèƒ½
        function updatePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            if (name) {
                recordManager.setPlayerName(name);
                alert('ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’ã€Œ' + name + 'ã€ã«è¨­å®šã—ã¾ã—ãŸ');
                nameInput.value = '';
            }
        }
        
        // ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºæ©Ÿèƒ½
        async function showRecords() {
            const recordsList = document.getElementById('recordsList');
            const topRecordsDiv = document.getElementById('topRecords');
            const playerRecordsDiv = document.getElementById('playerRecords');
            
            // è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            recordsList.style.display = recordsList.style.display === 'none' ? 'block' : 'none';
            
            if (recordsList.style.display === 'block') {
                try {
                    // ãƒˆãƒƒãƒ—5ã®è¨˜éŒ²ã‚’å–å¾—ï¼ˆæ·±åº¦ãƒ™ãƒ¼ã‚¹ï¼‰
                    const topRecords = await recordManager.getTopRecordsByDepth(5);
                    displayDepthRecords(topRecords, topRecordsDiv, true);
                    
                    // ç·æ˜å‰Šè·é›¢ã‚’å–å¾—
                    const totalDistance = await recordManager.getTotalDistance();
                    
                    // ç·æ˜å‰Šè·é›¢è¡¨ç¤ºã‚’è¿½åŠ 
                    const totalDistanceDiv = document.createElement('div');
                    totalDistanceDiv.innerHTML = `
                        <div style="background: rgba(135, 206, 235, 0.2); padding: 10px; margin: 10px 0; border-radius: 5px; text-align: center;">
                            <h4 style="margin: 0; color: #87CEEB;">ğŸŒ å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç·æ˜å‰Šè·é›¢</h4>
                            <div style="font-size: 18px; font-weight: bold; color: #FFD700;">${totalDistance.toLocaleString()} m</div>
                        </div>
                    `;
                    
                    // æ—¢å­˜ã®ç·è·é›¢è¡¨ç¤ºã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ 
                    const existingTotal = topRecordsDiv.querySelector('.total-distance');
                    if (existingTotal) {
                        existingTotal.remove();
                    }
                    totalDistanceDiv.classList.add('total-distance');
                    topRecordsDiv.appendChild(totalDistanceDiv);
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¨˜éŒ²ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    playerRecordsDiv.innerHTML = '<p>å€‹äººè¨˜éŒ²ã¯ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä¸Šä½5ä½ã®ã¿è¡¨ç¤ºã•ã‚Œã¾ã™</p>';
                    
                } catch (error) {
                    console.error('è¨˜éŒ²å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                    topRecordsDiv.innerHTML = '<p>è¨˜éŒ²ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>';
                    playerRecordsDiv.innerHTML = '<p>è¨˜éŒ²ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>';
                }
            }
        }
        
        // æ·±åº¦ãƒ™ãƒ¼ã‚¹ã®è¨˜éŒ²è¡¨ç¤ºãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function displayDepthRecords(records, container, showRank) {
            if (!records || records.length === 0) {
                container.innerHTML = '<p>è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div class="record-item">
                        ${showRank ? `<div class="record-rank">${index + 1}ä½</div>` : ''}
                        <div class="record-info">
                            <div><strong>${record.playerName}</strong></div>
                            <div>ğŸ† æ·±åº¦: ${record.depth}m</div>
                            <div>ğŸ’° ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼: ${record.oilMoneyStock} | ğŸ”¥ ã‚³ãƒ³ãƒœ: ${record.comboCount}</div>
                            <div>ğŸ“… æ—¥æ™‚: ${date}</div>
                        </div>
                        <div class="record-score">${record.depth}m</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // è¨˜éŒ²è¡¨ç¤ºãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆæ—§ç‰ˆãƒ»äº’æ›æ€§ã®ãŸã‚æ®‹å­˜ï¼‰
        function displayRecords(records, container, showRank) {
            if (!records || records.length === 0) {
                container.innerHTML = '<p>è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div class="record-item">
                        ${showRank ? `<div class="record-rank">${index + 1}ä½</div>` : ''}
                        <div class="record-info">
                            <div><strong>${record.playerName}</strong></div>
                            <div>æ·±åº¦: ${record.depth}m</div>
                            <div>ã‚ªã‚¤ãƒ«ãƒãƒãƒ¼: ${record.oilMoneyStock} | ã‚³ãƒ³ãƒœ: ${record.comboCount}</div>
                            <div>æ—¥æ™‚: ${date}</div>
                        </div>
                        <div class="record-score">${record.score}pt</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºæ©Ÿèƒ½
        async function showTitleRanking() {
            const titleRanking = document.getElementById('titleRanking');
            const titleRankingList = document.getElementById('titleRankingList');
            const titleTotalDistance = document.getElementById('titleTotalDistance');
            
            titleRanking.style.display = 'block';
            titleRankingList.innerHTML = '<p>èª­ã¿è¾¼ã¿ä¸­...</p>';
            
            try {
                // ãƒˆãƒƒãƒ—5ã®è¨˜éŒ²ã‚’å–å¾—
                const topRecords = await recordManager.getTopRecordsByDepth(5);
                displayTitleRanking(topRecords, titleRankingList);
                
                // ç·æ˜å‰Šè·é›¢ã‚’å–å¾—
                const totalDistance = await recordManager.getTotalDistance();
                titleTotalDistance.innerHTML = `
                    <div style="background: rgba(135, 206, 235, 0.2); padding: 10px; border-radius: 5px; text-align: center;">
                        <div style="color: #87CEEB; font-size: 14px;">ğŸŒ å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç·æ˜å‰Šè·é›¢</div>
                        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">${totalDistance.toLocaleString()} m</div>
                    </div>
                `;
                
            } catch (error) {
                console.error('ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                titleRankingList.innerHTML = '<p>ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>';
                titleTotalDistance.innerHTML = '';
            }
        }
        
        function hideTitleRanking() {
            document.getElementById('titleRanking').style.display = 'none';
        }
        
        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢å°‚ç”¨ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºé–¢æ•°
        function displayTitleRanking(records, container) {
            if (!records || records.length === 0) {
                container.innerHTML = '<p>ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div class="title-record-item">
                        <div class="title-record-rank">${index + 1}ä½</div>
                        <div class="title-record-info">
                            <div><strong>${record.playerName}</strong></div>
                            <div style="font-size: 14px; color: #ccc;">
                                æ—¥æ™‚: ${date}
                            </div>
                        </div>
                        <div class="title-record-depth">${record.depth}m</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹æ©Ÿèƒ½
        function backToTitle() {
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’éš ã™
            document.getElementById('gameOver').style.display = 'none';
            
            // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚’è¡¨ç¤º
            document.getElementById('startScreen').style.display = 'flex';
            
            // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‚‰éš ã™
            document.getElementById('titleRanking').style.display = 'none';
            
            // ã‚²ãƒ¼ãƒ è¨˜éŒ²ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‚‰éš ã™
            const recordsList = document.getElementById('recordsList');
            if (recordsList) {
                recordsList.style.display = 'none';
            }
            
            // BGMã‚’åœæ­¢
            if (audioManager.musicLoop) {
                audioManager.stopBackgroundMusic();
            }
            
            // ã‚¹ã‚¿ãƒ¼çŠ¶æ…‹BGMã‚’åœæ­¢
            if (game.starMode) {
                audioManager.stopStarModeBGM();
            }
        }
        
        // ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®è·é›¢ãƒšãƒ¼ã‚¸é–¢é€£ã®å®šæ•°
        const TOTAL_DISTANCE_TO_BRAZIL = 18000000; // 18,000 km in meters
        
        // ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®è·é›¢ãƒšãƒ¼ã‚¸è¡¨ç¤º
        async function showBrazilDistance() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('brazilDistancePage').style.display = 'block';
            
            // åœ°çƒã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æç”»
            drawEarthGraphic();
            
            // è·é›¢æƒ…å ±ã‚’æ›´æ–°
            await updateBrazilDistanceInfo();
            
            // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’èª­ã¿è¾¼ã¿
            await loadBrazilPageRanking();
        }
        
        // ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®è·é›¢ãƒšãƒ¼ã‚¸ã‚’éš ã™
        function hideBrazilDistance() {
            document.getElementById('brazilDistancePage').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        // åœ°çƒã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æç”»ï¼ˆåŠåˆ†ã«å‰²ã£ã¦æ˜å‰Šã®æ§˜å­ã‚’è¡¨ç¾ï¼‰
        function drawEarthGraphic() {
            const canvas = document.getElementById('earthCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 200;
            
            // åœ°çƒã‚’æç”»
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // åœ°çƒã®å½±
            ctx.beginPath();
            ctx.arc(centerX + 5, centerY + 5, radius, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fill();
            
            // åœ°çƒã®å¤–å´ï¼ˆæµ·ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#2196F3';
            ctx.fill();
            
            // åœ°çƒã®å¤§é™¸ï¼ˆç°¡ç•¥åŒ–ï¼‰
            ctx.fillStyle = '#4CAF50';
            
            // æ—¥æœ¬å‘¨è¾ºï¼ˆä¸Šéƒ¨ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY - 120, 20, 0, 2 * Math.PI);
            ctx.fill();
            
            // å—ç±³ï¼ˆä¸‹éƒ¨ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY + 120, 25, 0, 2 * Math.PI);
            ctx.fill();
            
            // ã‚¢ã‚¸ã‚¢å¤§é™¸ï¼ˆä¸Šéƒ¨ï¼‰
            ctx.beginPath();
            ctx.arc(centerX - 30, centerY - 80, 35, 0, 2 * Math.PI);
            ctx.fill();
            
            // åœ°çƒã®å†…éƒ¨æ§‹é€ ã‚’è¡¨ç¾ï¼ˆåŠåˆ†ã«åˆ‡ã£ãŸæ–­é¢ï¼‰
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI, false); // ä¸ŠåŠåˆ†ã®ã¿
            ctx.clip();
            
            // åœ°æ®»ï¼ˆèŒ¶è‰²ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#8B4513';
            ctx.fill();
            
            // ãƒãƒ³ãƒˆãƒ«ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 30, 0, 2 * Math.PI);
            ctx.fillStyle = '#FF4500';
            ctx.fill();
            
            // å¤–æ ¸ï¼ˆèµ¤ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 80, 0, 2 * Math.PI);
            ctx.fillStyle = '#DC143C';
            ctx.fill();
            
            // å†…æ ¸ï¼ˆé»„è‰²ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 120, 0, 2 * Math.PI);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
            
            ctx.restore();
            
            // æ˜å‰Šãƒˆãƒ³ãƒãƒ«ã®æç”»
            drawDrillingTunnel(ctx, centerX, centerY, radius);
            
            // åˆ†é›¢ç·šï¼ˆåœ°çƒã‚’åŠåˆ†ã«å‰²ã£ãŸç·šï¼‰
            ctx.beginPath();
            ctx.moveTo(centerX - radius, centerY);
            ctx.lineTo(centerX + radius, centerY);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç§‹ç”°çœŒã®ä½ç½®ï¼ˆåœ°çƒã®ä¸Šï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY - radius - 10, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#FF4500';
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ãƒ–ãƒ©ã‚¸ãƒ«ã®ä½ç½®ï¼ˆåœ°çƒã®ä¸‹ï¼‰
            ctx.beginPath();
            ctx.arc(centerX, centerY + radius + 10, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#32CD32';
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ç§‹ç”°çœŒ', centerX, centerY - radius - 20);
            ctx.fillText('ãƒ–ãƒ©ã‚¸ãƒ«', centerX, centerY + radius + 30);
            
            // å†…éƒ¨æ§‹é€ ã®ãƒ©ãƒ™ãƒ«
            ctx.fillStyle = '#FFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('åœ°æ®»', centerX - 170, centerY + 10);
            ctx.fillText('ãƒãƒ³ãƒˆãƒ«', centerX - 140, centerY + 10);
            ctx.fillText('å¤–æ ¸', centerX - 100, centerY + 10);
            ctx.fillText('å†…æ ¸', centerX - 60, centerY + 10);
        }
        
        // æ˜å‰Šãƒˆãƒ³ãƒãƒ«ã®æç”»
        async function drawDrillingTunnel(ctx, centerX, centerY, radius) {
            try {
                const totalDistance = await recordManager.getTotalDistance();
                const progressKm = Math.floor(totalDistance / 1000);
                const maxDistance = 18000; // 18,000 km
                
                // æ˜å‰Šã®é€²æ—ã‚’è¨ˆç®—
                const progress = Math.min(progressKm / maxDistance, 1.0);
                
                // ç§‹ç”°çœŒã‹ã‚‰ãƒ–ãƒ©ã‚¸ãƒ«ã¾ã§ã®å‚ç›´ãªæ˜å‰ŠçµŒè·¯
                const startX = centerX;
                const startY = centerY - radius - 10; // ç§‹ç”°çœŒã®ä½ç½®
                const endX = centerX;
                const endY = centerY + radius + 10; // ãƒ–ãƒ©ã‚¸ãƒ«ã®ä½ç½®
                
                const totalPathLength = endY - startY;
                const currentPathLength = progress * totalPathLength;
                const currentX = startX;
                const currentY = startY + currentPathLength;
                
                // æ˜å‰Šãƒˆãƒ³ãƒãƒ«ã®æç”»
                if (currentPathLength > 0) {
                    ctx.save();
                    
                    // æ˜å‰Šãƒˆãƒ³ãƒãƒ«ã®å¤–ç¸ï¼ˆå¤ªã„æš—ã„ç·šï¼‰
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.strokeStyle = '#8B0000';
                    ctx.lineWidth = 8;
                    ctx.stroke();
                    
                    // æ˜å‰Šãƒˆãƒ³ãƒãƒ«ï¼ˆç´°ã„èµ¤ç·šï¼‰
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.strokeStyle = '#FF6B6B';
                    ctx.lineWidth = 6;
                    ctx.stroke();
                    
                    // ç¾åœ¨åœ°ã‚’æ˜Ÿã§è¡¨ç¤º
                    if (currentPathLength > 5) {
                        drawStar(ctx, currentX, currentY, 8, '#FFD700', '#FF4500');
                    }
                    
                    ctx.restore();
                }
                
            } catch (error) {
                console.error('æ˜å‰Šãƒˆãƒ³ãƒãƒ«æç”»ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // æ˜Ÿã‚’æç”»ã™ã‚‹é–¢æ•°
        function drawStar(ctx, x, y, size, fillColor, strokeColor) {
            ctx.save();
            ctx.translate(x, y);
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5;
                const outerRadius = size;
                const innerRadius = size * 0.4;
                
                if (i === 0) {
                    ctx.moveTo(0, -outerRadius);
                } else {
                    ctx.lineTo(Math.sin(angle) * outerRadius, -Math.cos(angle) * outerRadius);
                }
                
                const innerAngle = angle + (2 * Math.PI) / 5;
                ctx.lineTo(Math.sin(innerAngle) * innerRadius, -Math.cos(innerAngle) * innerRadius);
            }
            ctx.closePath();
            
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }
        
        // è·é›¢æƒ…å ±ã‚’æ›´æ–°
        async function updateBrazilDistanceInfo() {
            try {
                const totalDistance = await recordManager.getTotalDistance();
                const progressKm = Math.floor(totalDistance / 1000);
                const remainingKm = Math.max(0, 18000 - progressKm);
                const progressPercentage = Math.min(100, (progressKm / 18000) * 100);
                
                document.getElementById('currentDistance').textContent = progressKm.toLocaleString();
                document.getElementById('remainingDistance').textContent = remainingKm.toLocaleString();
                document.getElementById('progressPercentage').textContent = progressPercentage.toFixed(2);
                document.getElementById('progressBar').style.width = progressPercentage + '%';
                
                // åœ°çƒã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’å†æç”»ï¼ˆæ˜å‰Šé€²æ—ã‚’åæ˜ ï¼‰
                drawEarthGraphic();
                
            } catch (error) {
                console.error('è·é›¢æƒ…å ±ã®æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                document.getElementById('currentDistance').textContent = '0';
                document.getElementById('remainingDistance').textContent = '18,000';
                document.getElementById('progressPercentage').textContent = '0';
            }
        }
        
        
        // ãƒ–ãƒ©ã‚¸ãƒ«ãƒšãƒ¼ã‚¸ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°èª­ã¿è¾¼ã¿
        async function loadBrazilPageRanking() {
            try {
                const topRecords = await recordManager.getTopRecordsByDepth(5);
                displayBrazilPageRanking(topRecords);
            } catch (error) {
                console.error('ãƒ–ãƒ©ã‚¸ãƒ«ãƒšãƒ¼ã‚¸ãƒ©ãƒ³ã‚­ãƒ³ã‚°èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                document.getElementById('brazilRankingList').innerHTML = '<p>ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>';
            }
        }
        
        // ãƒ–ãƒ©ã‚¸ãƒ«ãƒšãƒ¼ã‚¸ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º
        function displayBrazilPageRanking(records) {
            const container = document.getElementById('brazilRankingList');
            
            if (!records || records.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #ccc; margin: 20px 0;">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            let html = '';
            records.forEach((record, index) => {
                const date = record.timestamp ? new Date(record.timestamp.toDate()).toLocaleDateString() : 'N/A';
                html += `
                    <div style="background: rgba(255, 255, 255, 0.1); margin: 8px 0; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; min-height: 60px;">
                        <div style="font-weight: bold; color: #FFD700; min-width: 40px; font-size: 16px;">${index + 1}ä½</div>
                        <div style="flex: 1; margin-left: 12px; text-align: left;">
                            <div style="font-size: 16px; font-weight: bold; margin-bottom: 4px; color: #FFFFFF;">${record.playerName}</div>
                            <div style="font-size: 14px; color: #ccc; line-height: 1.3;">
                                ${date}
                            </div>
                        </div>
                        <div style="font-weight: bold; color: #FF4500; font-size: 18px; text-align: right;">${record.depth}m</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’è¨­å®š
        window.addEventListener('load', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.value = recordManager.playerName;
        });
    </script>
</body>
</html>